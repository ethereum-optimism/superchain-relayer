"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printCastCommand = exports.printTenderlySimulationLink = exports.doPhase = exports.doStep = exports.isStartOfPhase = exports.isStep = exports.liveDeployer = exports.doOwnershipTransfer = exports.printJsonTransaction = exports.getDeploymentAddress = exports.assertContractVariable = exports.getContractsFromArtifacts = exports.getContractFromArtifact = exports.asAdvancedContract = exports.deploy = void 0;
const assert_1 = __importDefault(require("assert"));
const url_1 = require("url");
const ethers_1 = require("ethers");
const core_utils_1 = require("@eth-optimism/core-utils");
require("hardhat-deploy");
require("@eth-optimism/hardhat-deploy-config");
require("@nomiclabs/hardhat-ethers");
const deploy = async ({ hre, name, iface, args, contract, postDeployAction, }) => {
    const { deployer } = await hre.getNamedAccounts();
    let result = await hre.deployments.getOrNull(name);
    let numDeployConfirmations;
    try {
        numDeployConfirmations = hre.deployConfig.numDeployConfirmations;
    }
    catch (e) {
        numDeployConfirmations = 1;
    }
    if (result) {
        console.log(`skipping ${name}, using existing at ${result.address}`);
    }
    else {
        result = await hre.deployments.deploy(name, {
            contract,
            from: deployer,
            args,
            log: true,
            waitConfirmations: numDeployConfirmations,
        });
        console.log(`Deployed ${name} at ${result.address}`);
        await hre.ethers.provider.waitForTransaction(result.transactionHash);
    }
    const code = await hre.ethers.provider.getCode(result.address);
    if (code === '0x') {
        throw new Error(`no code for ${result.address}`);
    }
    const created = (0, exports.asAdvancedContract)({
        confirmations: numDeployConfirmations,
        contract: new ethers_1.Contract(result.address, iface !== undefined
            ? (await hre.ethers.getContractFactory(iface)).interface
            : result.abi, hre.ethers.provider.getSigner(deployer)),
    });
    if (result.newlyDeployed) {
        if (postDeployAction) {
            await postDeployAction(created);
        }
    }
    return created;
};
exports.deploy = deploy;
const asAdvancedContract = (opts) => {
    const def = Object.defineProperty;
    Object.defineProperty = (obj, propName, prop) => {
        prop.writable = true;
        return def(obj, propName, prop);
    };
    const contract = new ethers_1.Contract(opts.contract.address, opts.contract.interface, opts.contract.signer || opts.contract.provider);
    Object.defineProperty = def;
    for (const fnName of Object.keys(contract.functions)) {
        const fn = contract[fnName].bind(contract);
        contract[fnName] = async (...args) => {
            let gasPrice = opts.gasPrice;
            if (contract.interface.getFunction(fnName).constant) {
                gasPrice = 0;
            }
            const tx = await fn(...args, {
                gasPrice,
            });
            if (typeof tx !== 'object' || typeof tx.wait !== 'function') {
                return tx;
            }
            const maxTimeout = 120;
            let timeout = 0;
            while (true) {
                await (0, core_utils_1.sleep)(1000);
                const receipt = await contract.provider.getTransactionReceipt(tx.hash);
                if (receipt === null) {
                    timeout++;
                    if (timeout > maxTimeout) {
                        throw new Error('timeout exceeded waiting for txn to be mined');
                    }
                }
                else if (receipt.confirmations >= (opts.confirmations || 0)) {
                    return tx;
                }
            }
        };
    }
    return contract;
};
exports.asAdvancedContract = asAdvancedContract;
const getContractFromArtifact = async (hre, name, opts = {}) => {
    const artifact = await hre.deployments.get(name);
    let iface = new hre.ethers.utils.Interface(artifact.abi);
    if (opts.iface) {
        const factory = await hre.ethers.getContractFactory(opts.iface);
        iface = factory.interface;
    }
    let signerOrProvider = hre.ethers.provider;
    if (opts.signerOrProvider) {
        if (typeof opts.signerOrProvider === 'string') {
            signerOrProvider = hre.ethers.provider.getSigner(opts.signerOrProvider);
        }
        else {
            signerOrProvider = opts.signerOrProvider;
        }
    }
    let numDeployConfirmations;
    try {
        numDeployConfirmations = hre.deployConfig.numDeployConfirmations;
    }
    catch (e) {
        numDeployConfirmations = 1;
    }
    return (0, exports.asAdvancedContract)({
        confirmations: numDeployConfirmations,
        contract: new hre.ethers.Contract(artifact.address, iface, signerOrProvider),
    });
};
exports.getContractFromArtifact = getContractFromArtifact;
const getContractsFromArtifacts = async (hre, configs) => {
    const contracts = [];
    for (const config of configs) {
        contracts.push(await (0, exports.getContractFromArtifact)(hre, config.name, config));
    }
    return contracts;
};
exports.getContractsFromArtifacts = getContractsFromArtifacts;
const assertContractVariable = async (contract, variable, expected) => {
    const temp = new ethers_1.ethers.Contract(contract.address, contract.interface, contract.provider);
    const actual = await temp.callStatic[variable]({
        from: ethers_1.ethers.constants.AddressZero,
    });
    if (ethers_1.ethers.utils.isAddress(expected)) {
        (0, assert_1.default)(actual.toLowerCase() === expected.toLowerCase(), `[FATAL] ${variable} is ${actual} but should be ${expected}`);
        return;
    }
    (0, assert_1.default)(actual === expected || (actual.eq && actual.eq(expected)), `[FATAL] ${variable} is ${actual} but should be ${expected}`);
};
exports.assertContractVariable = assertContractVariable;
const getDeploymentAddress = async (hre, name) => {
    const deployment = await hre.deployments.get(name);
    return deployment.address;
};
exports.getDeploymentAddress = getDeploymentAddress;
const printJsonTransaction = (tx) => {
    console.log('JSON transaction parameters:\n' +
        JSON.stringify({
            from: tx.from,
            to: tx.to,
            data: tx.data,
            value: tx.value,
            chainId: tx.chainId,
        }, null, 2));
};
exports.printJsonTransaction = printJsonTransaction;
const doOwnershipTransfer = async (opts) => {
    if (opts.isLiveDeployer) {
        console.log(`Setting ${opts.name} owner to MSD`);
        await opts.proxy[opts.transferFunc](opts.dictator.address);
    }
    else {
        const tx = await opts.proxy.populateTransaction[opts.transferFunc](opts.dictator.address);
        console.log(`
    Please transfer ${opts.name} (proxy) owner to MSD
      - ${opts.name} address: ${opts.proxy.address}
      - MSD address: ${opts.dictator.address}
    `);
        (0, exports.printJsonTransaction)(tx);
        (0, exports.printCastCommand)(tx);
        await (0, exports.printTenderlySimulationLink)(opts.dictator.provider, tx);
    }
};
exports.doOwnershipTransfer = doOwnershipTransfer;
const liveDeployer = async (opts) => {
    if (!!opts.disabled) {
        console.log('Live deployer manually disabled');
        return false;
    }
    const { deployer } = await opts.hre.getNamedAccounts();
    const ret = deployer.toLowerCase() === opts.hre.deployConfig.controller.toLowerCase();
    console.log('Setting live deployer to', ret);
    return ret;
};
exports.liveDeployer = liveDeployer;
const isStep = async (dictator, step) => {
    return (await dictator.currentStep()) === step;
};
exports.isStep = isStep;
const isStartOfPhase = async (dictator, phase) => {
    const phaseToStep = {
        1: 1,
        2: 3,
        3: 6,
    };
    return (await dictator.currentStep()) === phaseToStep[phase];
};
exports.isStartOfPhase = isStartOfPhase;
const doStep = async (opts) => {
    const isStepVal = await (0, exports.isStep)(opts.SystemDictator, opts.step);
    if (!isStepVal) {
        console.log(`Step already completed: ${opts.step}`);
        return;
    }
    console.log(opts.message);
    if (opts.isLiveDeployer) {
        console.log(`Executing step ${opts.step}...`);
        await opts.SystemDictator[`step${opts.step}`]();
    }
    else {
        const tx = await opts.SystemDictator.populateTransaction[`step${opts.step}`]();
        console.log(`Please execute step ${opts.step}...`);
        console.log(`MSD address: ${opts.SystemDictator.address}`);
        (0, exports.printJsonTransaction)(tx);
        (0, exports.printCastCommand)(tx);
        await (0, exports.printTenderlySimulationLink)(opts.SystemDictator.provider, tx);
    }
    await (0, core_utils_1.awaitCondition)(async () => {
        return (0, exports.isStep)(opts.SystemDictator, opts.step + 1);
    }, 30000, 1000);
    await opts.checks();
};
exports.doStep = doStep;
const doPhase = async (opts) => {
    const isStart = await (0, exports.isStartOfPhase)(opts.SystemDictator, opts.phase);
    if (!isStart) {
        console.log(`Start of phase ${opts.phase} already completed`);
        return;
    }
    console.log(opts.message);
    if (opts.isLiveDeployer) {
        console.log(`Executing phase ${opts.phase}...`);
        await opts.SystemDictator[`phase${opts.phase}`]();
    }
    else {
        const tx = await opts.SystemDictator.populateTransaction[`phase${opts.phase}`]();
        console.log(`Please execute phase ${opts.phase}...`);
        console.log(`MSD address: ${opts.SystemDictator.address}`);
        (0, exports.printJsonTransaction)(tx);
        await (0, exports.printTenderlySimulationLink)(opts.SystemDictator.provider, tx);
    }
    await (0, core_utils_1.awaitCondition)(async () => {
        return (0, exports.isStartOfPhase)(opts.SystemDictator, opts.phase + 1);
    }, 30000, 1000);
    await opts.checks();
};
exports.doPhase = doPhase;
const printTenderlySimulationLink = async (provider, tx) => {
    if (process.env.TENDERLY_PROJECT && process.env.TENDERLY_USERNAME) {
        console.log(`https://dashboard.tenderly.co/${process.env.TENDERLY_PROJECT}/${process.env.TENDERLY_USERNAME}/simulator/new?${new url_1.URLSearchParams({
            network: (await provider.getNetwork()).chainId.toString(),
            contractAddress: tx.to,
            rawFunctionInput: tx.data,
            from: tx.from,
        }).toString()}`);
    }
};
exports.printTenderlySimulationLink = printTenderlySimulationLink;
const printCastCommand = (tx) => {
    if (process.env.CAST_COMMANDS) {
        if (!!tx.value && tx.value.gt(0)) {
            console.log(`cast send ${tx.to} ${tx.data} --from ${tx.from} --value ${tx.value}`);
        }
        else {
            console.log(`cast send ${tx.to} ${tx.data} --from ${tx.from} `);
        }
    }
};
exports.printCastCommand = printCastCommand;
//# sourceMappingURL=deploy-utils.js.map