import {
  version
} from "./chunk-JVJS2F5M.js";
import {
  defaultConfig
} from "./chunk-72RMV4XG.js";
import {
  fromZodError
} from "./chunk-C6LX74DU.js";
import {
  findConfig,
  format,
  getAddressDocString,
  getIsUsingTypeScript,
  resolveConfig
} from "./chunk-7EQXH2DH.js";
import {
  info,
  log,
  spinner,
  success,
  warn
} from "./chunk-RRJI3FMR.js";
import "./chunk-UICA3PK6.js";

// src/commands/generate.ts
import { getAddress } from "@ethersproject/address";
import { Abi as AbiSchema } from "abitype/zod";
import { camelCase } from "change-case";
import { watch } from "chokidar";
import { default as dedent } from "dedent";
import { ensureDir, default as fse } from "fs-extra";
import { basename, dirname, resolve } from "pathe";
import pc from "picocolors";
import { z } from "zod";
var Generate = z.object({
  config: z.string().optional(),
  root: z.string().optional(),
  watch: z.boolean().optional()
});
async function generate(options = {}) {
  try {
    await Generate.parseAsync(options);
  } catch (error) {
    if (error instanceof z.ZodError)
      throw fromZodError(error, { prefix: "Invalid option" });
    throw error;
  }
  const configPath = await findConfig(options);
  if (!configPath) {
    if (options.config)
      throw new Error(`Config not found at ${pc.gray(options.config)}`);
    throw new Error("Config not found");
  }
  const resolvedConfigs = await resolveConfig({ configPath });
  const isTypeScript = await getIsUsingTypeScript();
  const watchers = [];
  const watchWriteDelay = 100;
  const watchOptions = {
    atomic: true,
    ignoreInitial: true,
    persistent: true
  };
  const outNames = /* @__PURE__ */ new Set();
  const isArrayConfig = Array.isArray(resolvedConfigs);
  const configs = isArrayConfig ? resolvedConfigs : [resolvedConfigs];
  for (const config of configs) {
    if (isArrayConfig)
      log(`Using config ${pc.gray(basename(configPath))}`);
    if (!config.out)
      throw new Error("out is required.");
    if (outNames.has(config.out))
      throw new Error(`out "${config.out}" must be unique.`);
    outNames.add(config.out);
    const plugins = (config.plugins ?? []).map((x, i) => ({
      ...x,
      id: `${x.name}-${i}`
    }));
    const spinner2 = spinner();
    spinner2.start("Validating plugins");
    for (const plugin of plugins) {
      await plugin.validate?.();
    }
    spinner2.succeed();
    const contractConfigs = config.contracts ?? [];
    const watchConfigs = [];
    spinner2.start("Resolving contracts");
    for (const plugin of plugins) {
      if (plugin.watch)
        watchConfigs.push(plugin.watch);
      if (plugin.contracts) {
        const contracts2 = await plugin.contracts();
        contractConfigs.push(...contracts2);
      }
    }
    const contractNames = /* @__PURE__ */ new Set();
    const contractMap = /* @__PURE__ */ new Map();
    for (const contractConfig of contractConfigs) {
      if (contractNames.has(contractConfig.name))
        throw new Error(
          `Contract name "${contractConfig.name}" must be unique.`
        );
      const contract = await getContract({ ...contractConfig, isTypeScript });
      contractMap.set(contract.name, contract);
      contractNames.add(contractConfig.name);
    }
    const contracts = [...contractMap.values()];
    if (!contracts.length && !options.watch) {
      spinner2.fail();
      warn("No contracts found.");
      return;
    }
    spinner2.succeed();
    const imports = [];
    const prepend = [];
    const content = [];
    const outputs = [];
    spinner2.start("Running plugins");
    for (const plugin of plugins) {
      if (!plugin.run)
        continue;
      const result = await plugin.run({
        contracts,
        isTypeScript,
        outputs
      });
      outputs.push({
        plugin: { name: plugin.name },
        ...result
      });
      if (!result.imports && !result.prepend && !result.content)
        continue;
      content.push(getBannerContent({ name: plugin.name }), result.content);
      result.imports && imports.push(result.imports);
      result.prepend && prepend.push(result.prepend);
    }
    spinner2.succeed();
    spinner2.start(`Writing to ${pc.gray(config.out)}`);
    await writeContracts({
      content,
      contracts,
      imports,
      prepend,
      filename: config.out
    });
    spinner2.succeed();
    if (options.watch) {
      if (!watchConfigs.length) {
        log(pc.gray("Used --watch flag, but no plugins are watching."));
        continue;
      }
      log();
      log("Setting up watch process");
      let timeout;
      for (const watchConfig of watchConfigs) {
        const paths = typeof watchConfig.paths === "function" ? await watchConfig.paths() : watchConfig.paths;
        const watcher2 = watch(paths, watchOptions);
        watcher2.on("all", async (event, path) => {
          if (event !== "change" && event !== "add" && event !== "unlink")
            return;
          let needsWrite = false;
          if (event === "change" || event === "add") {
            const eventFn = event === "change" ? watchConfig.onChange : watchConfig.onAdd;
            const config2 = await eventFn?.(path);
            if (!config2)
              return;
            const contract = await getContract({ ...config2, isTypeScript });
            contractMap.set(contract.name, contract);
            needsWrite = true;
          } else if (event === "unlink") {
            const name = await watchConfig.onRemove?.(path);
            if (!name)
              return;
            contractMap.delete(name);
            needsWrite = true;
          }
          if (needsWrite) {
            if (timeout)
              clearTimeout(timeout);
            timeout = setTimeout(async () => {
              timeout = null;
              const contracts2 = [...contractMap.values()];
              const imports2 = [];
              const prepend2 = [];
              const content2 = [];
              const outputs2 = [];
              for (const plugin of plugins) {
                if (!plugin.run)
                  continue;
                const result = await plugin.run({
                  contracts: contracts2,
                  isTypeScript,
                  outputs: outputs2
                });
                outputs2.push({
                  plugin: { name: plugin.name },
                  ...result
                });
                if (!result.imports && !result.prepend && !result.content)
                  continue;
                content2.push(
                  getBannerContent({ name: plugin.name }),
                  result.content
                );
                result.imports && imports2.push(result.imports);
                result.prepend && prepend2.push(result.prepend);
              }
              const spinner3 = spinner();
              spinner3.start(`Writing to ${pc.gray(config.out)}`);
              await writeContracts({
                content: content2,
                contracts: contracts2,
                imports: imports2,
                prepend: prepend2,
                filename: config.out
              });
              spinner3.succeed();
            }, watchWriteDelay);
            needsWrite = false;
          }
        });
        if (watchConfig.command)
          watcher2.on("ready", async () => {
            await watchConfig.command?.();
          });
        watcher2.config = watchConfig;
        watchers.push(watcher2);
      }
    }
  }
  if (!watchers.length)
    return;
  const watcher = watch(configPath).on("change", async (path) => {
    log(
      `> Found a change to config ${pc.gray(
        basename(path)
      )}. Restart process for changes to take effect.`
    );
  });
  watchers.push(watcher);
  process.once("SIGINT", shutdown);
  process.once("SIGTERM", shutdown);
  async function shutdown() {
    log();
    log("Shutting down watch process");
    const promises = [];
    for (const watcher2 of watchers) {
      if (watcher2.config?.onClose)
        promises.push(watcher2.config?.onClose?.());
      promises.push(watcher2.close());
    }
    await Promise.allSettled(promises);
    process.exit(0);
  }
}
async function getContract({
  abi,
  address,
  name,
  isTypeScript
}) {
  const constAssertion = isTypeScript ? " as const" : "";
  const abiName = `${camelCase(name)}ABI`;
  try {
    abi = await AbiSchema.parseAsync(abi);
  } catch (error) {
    if (error instanceof z.ZodError)
      throw fromZodError(error, {
        prefix: `Invalid ABI for contract "${name}"`
      });
    throw error;
  }
  const docString = typeof address === "object" ? dedent`\n
        /**
         ${getAddressDocString({ address })}
        */
      ` : "";
  let content = dedent`
    ${getBannerContent({ name })}

    ${docString}
    export const ${abiName} = ${JSON.stringify(abi)}${constAssertion}
  `;
  let meta = { abiName };
  if (address) {
    let resolvedAddress;
    try {
      const Address = z.string().regex(/^0x[a-fA-F0-9]{40}$/, { message: "Invalid address" }).transform((val) => getAddress(val));
      const MultiChainAddress = z.record(z.string(), Address);
      const AddressSchema = z.union([Address, MultiChainAddress]);
      resolvedAddress = await AddressSchema.parseAsync(address);
    } catch (error) {
      if (error instanceof z.ZodError)
        throw fromZodError(error, {
          prefix: `Invalid address for contract "${name}"`
        });
      throw error;
    }
    const addressName = `${camelCase(name)}Address`;
    const configName = `${camelCase(name)}Config`;
    meta = {
      ...meta,
      addressName,
      configName
    };
    const addressContent = typeof resolvedAddress === "string" ? JSON.stringify(resolvedAddress) : JSON.stringify(resolvedAddress, null, 2).replace(/"(\d*)":/gm, "$1:");
    content = dedent`
      ${content}

      ${docString}
      export const ${addressName} = ${addressContent}${constAssertion}

      ${docString}
      export const ${configName} = { address: ${addressName}, abi: ${abiName} }${constAssertion}
    `;
  }
  return { abi, address, content, meta, name };
}
async function writeContracts({
  content,
  contracts,
  imports,
  prepend,
  filename
}) {
  let code = dedent`
    // Generated by @wagmi/cli@${version} on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}
    ${imports.join("\n\n") ?? ""}

    ${prepend.join("\n\n") ?? ""}
  `;
  for (const contract of contracts) {
    code = dedent`
      ${code}

      ${contract.content}
    `;
  }
  code = dedent`
    ${code}
    
    ${content.join("\n\n") ?? ""}
  `;
  const cwd = process.cwd();
  const outPath = resolve(cwd, filename);
  await ensureDir(dirname(outPath));
  const formatted = await format(code);
  await fse.writeFile(outPath, formatted);
}
function getBannerContent({ name }) {
  return dedent`
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // ${name}
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  `;
}

// src/commands/init.ts
import dedent2 from "dedent";
import { default as fse2 } from "fs-extra";
import { relative, resolve as resolve2 } from "pathe";
import pc2 from "picocolors";
import { z as z2 } from "zod";
var Init = z2.object({
  config: z2.string().optional(),
  content: z2.object({}).optional(),
  root: z2.string().optional()
});
async function init(options = {}) {
  try {
    await Init.parseAsync(options);
  } catch (error) {
    if (error instanceof z2.ZodError)
      throw fromZodError(error, { prefix: "Invalid option" });
    throw error;
  }
  const configPath = await findConfig(options);
  if (configPath) {
    info(
      `Config already exists at ${pc2.gray(
        relative(process.cwd(), configPath)
      )}`
    );
    return configPath;
  }
  const spinner2 = spinner();
  spinner2.start("Creating config");
  const isUsingTypeScript = await getIsUsingTypeScript();
  const rootDir = resolve2(options.root || process.cwd());
  let outPath;
  if (options.config) {
    outPath = resolve2(rootDir, options.config);
  } else {
    const extension = isUsingTypeScript ? "ts" : "js";
    outPath = resolve2(rootDir, `wagmi.config.${extension}`);
  }
  let content;
  if (isUsingTypeScript) {
    const config = options.content ?? defaultConfig;
    content = dedent2(`
      import { defineConfig } from '@wagmi/cli'
      
      export default defineConfig(${JSON.stringify(config)})
    `);
  } else {
    const config = options.content ?? {
      ...defaultConfig,
      out: defaultConfig.out.replace(".ts", ".js")
    };
    content = dedent2(`
      // @ts-check

      /** @type {import('@wagmi/cli').Config} */
      export default ${JSON.stringify(config)}
    `);
  }
  const formatted = await format(content);
  await fse2.writeFile(outPath, formatted);
  spinner2.succeed();
  success(
    `Config created at ${pc2.gray(relative(process.cwd(), outPath))}`
  );
  return outPath;
}
export {
  generate,
  init
};
