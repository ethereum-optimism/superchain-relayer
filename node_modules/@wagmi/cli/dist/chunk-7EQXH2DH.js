// src/utils/loadEnv.ts
import { parse } from "dotenv";
import { expand } from "dotenv-expand";
import fs from "fs";
import path from "path";
function loadEnv(config = {}) {
  const mode = config.mode;
  if (mode === "local") {
    throw new Error(
      `"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`
    );
  }
  const envFiles = [
    `.env`,
    `.env.local`,
    ...mode ? [
      `.env.${mode}`,
      `.env.${mode}.local`
    ] : []
  ];
  const envDir = config.envDir ?? process.cwd();
  const parsed = Object.fromEntries(
    envFiles.flatMap((file) => {
      const path2 = lookupFile(envDir, [file], {
        pathOnly: true,
        rootDir: envDir
      });
      if (!path2)
        return [];
      return Object.entries(parse(fs.readFileSync(path2)));
    })
  );
  try {
    expand({ parsed });
  } catch (error) {
    if (error.message.includes("split")) {
      throw new Error(
        "dotenv-expand failed to expand env vars. Maybe you need to escape `$`?"
      );
    }
    throw error;
  }
  return parsed;
}
function lookupFile(dir, formats, options) {
  for (const format2 of formats) {
    const fullPath = path.join(dir, format2);
    if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
      const result = options?.pathOnly ? fullPath : fs.readFileSync(fullPath, "utf-8");
      if (!options?.predicate || options.predicate(result)) {
        return result;
      }
    }
  }
  const parentDir = path.dirname(dir);
  if (parentDir !== dir && (!options?.rootDir || parentDir.startsWith(options?.rootDir))) {
    return lookupFile(parentDir, formats, options);
  }
}

// src/utils/findConfig.ts
import { findUp } from "find-up";
import { default as fse } from "fs-extra";
import { resolve } from "pathe";
var configFiles = [
  "wagmi.config.ts",
  "wagmi.config.js",
  "wagmi.config.mjs",
  "wagmi.config.mts"
];
async function findConfig({ config, root } = {}) {
  const rootDir = resolve(root || process.cwd());
  if (config) {
    const path2 = resolve(rootDir, config);
    if (fse.pathExistsSync(path2))
      return path2;
    return;
  }
  return await findUp(configFiles, { cwd: rootDir });
}

// src/utils/format.ts
import prettier from "prettier";
async function format(content) {
  const config = await prettier.resolveConfig(process.cwd());
  return prettier.format(content, {
    arrowParens: "always",
    endOfLine: "lf",
    parser: "typescript",
    printWidth: 80,
    semi: false,
    singleQuote: true,
    tabWidth: 2,
    trailingComma: "all",
    ...config
  });
}

// src/utils/getAddressDocString.ts
import * as allChains from "@wagmi/chains";
import { capitalCase } from "change-case";
import dedent from "dedent";
var chainMap = {};
for (const chain of Object.values(allChains)) {
  if (typeof chain !== "object")
    continue;
  if (!("id" in chain))
    continue;
  chainMap[chain.id] = chain;
}
function getAddressDocString({
  address
}) {
  if (!address || typeof address === "string")
    return "";
  if (Object.keys(address).length === 1)
    return `* ${getLink({
      address: address[parseInt(Object.keys(address)[0])],
      chainId: parseInt(Object.keys(address)[0])
    })}`;
  const addresses = Object.entries(address).filter(
    (x) => chainMap[parseInt(x[0])]
  );
  if (addresses.length === 0)
    return "";
  if (addresses.length === 1 && addresses[0])
    return `* ${getLink({
      address: addresses[0][1],
      chainId: parseInt(addresses[0][0])
    })}`;
  return dedent`
    ${addresses.reduce((prev, curr) => {
    const chainId = parseInt(curr[0]);
    const address2 = curr[1];
    return `${prev}
* - ${getLink({ address: address2, chainId })}`;
  }, "")}
  `;
}
function getLink({ address, chainId }) {
  const chain = chainMap[chainId];
  if (!chain)
    return "";
  const blockExplorer = chain.blockExplorers?.default;
  if (!blockExplorer)
    return "";
  return `[__View Contract on ${capitalCase(chain.name)} ${capitalCase(
    blockExplorer.name
  )}__](${blockExplorer.url}/address/${address})`;
}

// src/utils/getIsUsingTypeScript.ts
import { findUp as findUp2 } from "find-up";
async function getIsUsingTypeScript() {
  try {
    const cwd = process.cwd();
    const tsconfig = await findUp2("tsconfig.json", { cwd });
    return !!tsconfig;
  } catch {
    return false;
  }
}

// src/utils/packages.ts
import { detect } from "detect-package-manager";
import { execa } from "execa";
async function getIsPackageInstalled({
  packageName,
  cwd = process.cwd()
}) {
  try {
    const packageManager = await getPackageManager();
    const command = packageManager === "yarn" ? ["why", packageName] : ["ls", packageName];
    const { stdout } = await execa(packageManager, command, { cwd });
    if (stdout !== "")
      return true;
    return false;
  } catch (error) {
    return false;
  }
}
async function getInstallCommand(packageName) {
  const packageManager = await getPackageManager();
  switch (packageManager) {
    case "yarn":
      return [packageManager, ["add", packageName]];
    case "npm":
      return [packageManager, ["install", "--save", packageName]];
    case "pnpm":
      return [packageManager, ["add", packageName]];
  }
}
async function getPackageManager() {
  const userAgent = process.env.npm_config_user_agent;
  if (userAgent) {
    if (userAgent.includes("pnpm"))
      return "pnpm";
    if (userAgent.includes("yarn"))
      return "yarn";
    if (userAgent.includes("npm"))
      return "npm";
  }
  return detect();
}

// src/utils/resolveConfig.ts
import { bundleRequire } from "bundle-require";
async function resolveConfig({
  configPath
}) {
  const res = await bundleRequire({
    filepath: configPath,
    ...process.env.NODE_ENV === "test" ? {
      require: (id) => import(id)
    } : {}
  });
  let config = res.mod.default;
  if (config.default)
    config = config.default;
  if (typeof config !== "function")
    return config;
  return await config();
}

export {
  findConfig,
  format,
  getAddressDocString,
  getIsUsingTypeScript,
  loadEnv,
  getIsPackageInstalled,
  getInstallCommand,
  getPackageManager,
  resolveConfig
};
