import {
  fromZodError
} from "../chunk-C6LX74DU.js";
import {
  getAddressDocString,
  getInstallCommand,
  getIsPackageInstalled,
  getPackageManager
} from "../chunk-7EQXH2DH.js";
import {
  log
} from "../chunk-RRJI3FMR.js";
import "../chunk-UICA3PK6.js";

// src/plugins/actions.ts
import { pascalCase } from "change-case";
import dedent from "dedent";
function actions(config = {}) {
  const actions2 = {
    getContract: true,
    prepareWriteContract: true,
    readContract: true,
    watchContractEvent: true,
    writeContract: true,
    ...config
  };
  return {
    name: "Core",
    async run({ contracts, isTypeScript, outputs }) {
      const imports = /* @__PURE__ */ new Set([]);
      const hasWriteContractMode = outputs.some(
        (x) => x.plugin.name === "React" && x.imports?.includes("WriteContractMode")
      );
      const content = [];
      for (const contract of contracts) {
        const baseActionName = pascalCase(contract.name);
        let typeParams = "";
        let omitted = "";
        const innerActionParams = {
          abi: contract.meta.abiName
        };
        if (contract.meta.addressName) {
          omitted = `| 'address'`;
          if (typeof contract.address === "object") {
            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName} }`;
            if (Object.keys(contract.address).length > 1) {
              innerActionParams["address"] = `${contract.meta.addressName}[config.chainId as keyof typeof ${contract.meta.addressName}]`;
            } else
              innerActionParams["address"] = `${contract.meta.addressName}[${Object.keys(contract.address)[0]}]`;
          } else if (contract.address)
            innerActionParams["address"] = contract.meta.addressName;
        }
        const innerActionConfig = Object.entries(innerActionParams).reduce(
          (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
          "{"
        ) + "...config}";
        const genDocString = (actionName, item) => {
          let description = `Wraps __{@link ${actionName}}__ with \`abi\` set to __{@link ${contract.meta.abiName}}__`;
          if (item)
            description += ` and \`${item.name}\` set to \`"${item.value}"\``;
          if (contract.address) {
            const docString = getAddressDocString({ address: contract.address });
            if (docString)
              return dedent`
              /**
              * ${description}.
              * 
              ${docString}
              */
              `;
          }
          return dedent`
          /**
           * ${description}.
           */
          `;
        };
        if (actions2.getContract) {
          imports.add("getContract");
          const docString = genDocString("getContract");
          let code;
          if (isTypeScript) {
            imports.add("GetContractArgs");
            code = dedent`
            ${docString}
            export function get${baseActionName}(
              config: Omit<GetContractArgs, 'abi'${omitted}>${typeParams},
            ) {
              return getContract(${innerActionConfig})
            }
            `;
          } else
            code = dedent`
            ${docString}
            export function use${baseActionName}(config) {
              return getContract(${innerActionConfig})
            }
            `;
          content.push(code);
        }
        let hasReadFunction, hasWriteFunction, hasEvent = false;
        for (const component of contract.abi) {
          if (component.type === "function")
            if (component.stateMutability === "view" || component.stateMutability === "pure")
              hasReadFunction = true;
            else
              hasWriteFunction = true;
          else if (component.type === "event")
            hasEvent = true;
          if (hasReadFunction && hasWriteFunction && hasEvent)
            break;
        }
        if (hasReadFunction) {
          if (actions2.readContract) {
            imports.add("readContract");
            const docString = genDocString("readContract");
            let code;
            if (isTypeScript) {
              imports.add("ReadContractConfig");
              code = dedent`
              ${docString}
              export function read${baseActionName}<
                TAbi extends readonly unknown[] = typeof ${contract.meta.abiName},
                TFunctionName extends string = string,
              >(
                config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi'${omitted}>${typeParams},
              ) {
                return readContract(${innerActionConfig} as unknown as ReadContractConfig<TAbi, TFunctionName>)
              }
              `;
            } else
              code = dedent`
              ${docString}
              export function read${baseActionName}(config) {
                return readContract(${innerActionConfig})
              }
              `;
            content.push(code);
          }
        }
        if (hasWriteFunction) {
          if (actions2.writeContract) {
            imports.add("writeContract");
            const docString = genDocString("writeContract");
            let code;
            if (isTypeScript) {
              const hasMultichainAddress = typeof contract.address === "object";
              const TChainId = hasMultichainAddress ? `TMode extends WriteContractMode, TChainId extends number = keyof typeof ${contract.meta.addressName}` : "";
              let typeParams_ = "";
              if (TChainId) {
                if (!hasWriteContractMode)
                  imports.add("WriteContractMode");
                typeParams_ = `& { mode: TMode; chainId?: TMode extends 'prepared' ? TChainId : keyof typeof ${contract.meta.addressName} }`;
              }
              imports.add("WriteContractArgs");
              imports.add("WriteContractPreparedArgs");
              imports.add("WriteContractUnpreparedArgs");
              code = dedent`
              ${docString}
              export function write${baseActionName}<
                TFunctionName extends string,
                ${TChainId}
              >(
                config:
                  | (Omit<WriteContractPreparedArgs<typeof ${contract.meta.abiName}, TFunctionName>, 'abi'${omitted}>${typeParams_})
                  | (Omit<WriteContractUnpreparedArgs<typeof ${contract.meta.abiName}, TFunctionName>, 'abi'${omitted}>${typeParams_}),
              ) {
                return writeContract(${innerActionConfig} as WriteContractArgs<typeof ${contract.meta.abiName}, TFunctionName>)
              }
              `;
            } else
              code = dedent`
              ${docString}
              export function write${baseActionName}(config) {
                return writeContract(${innerActionConfig})
              }
              `;
            content.push(code);
          }
          if (actions2.prepareWriteContract) {
            imports.add("prepareWriteContract");
            const docString = genDocString("prepareWriteContract");
            let code;
            if (isTypeScript) {
              imports.add("PrepareWriteContractConfig");
              code = dedent`
              ${docString}
              export function prepareWrite${baseActionName}<
                TAbi extends readonly unknown[] = typeof ${contract.meta.abiName},
                TFunctionName extends string = string,
              >(
                config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi'${omitted}>${typeParams},
              ) {
                return prepareWriteContract(${innerActionConfig} as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
              }
              `;
            } else
              code = dedent`
              ${docString}
              export function prepareWrite${baseActionName}(config) {
                return prepareWriteContract(${innerActionConfig})
              }
              `;
            content.push(code);
          }
        }
        if (hasEvent) {
          if (actions2.watchContractEvent) {
            imports.add("watchContractEvent");
            const docString = genDocString("watchContractEvent");
            let code;
            if (isTypeScript) {
              imports.add("WatchContractEventConfig");
              imports.add("WatchContractEventCallback");
              code = dedent`
              ${docString}
              export function watch${baseActionName}Event<
                TAbi extends readonly unknown[] = typeof ${contract.meta.abiName},
                TEventName extends string = string,
              >(
                config: Omit<WatchContractEventConfig<TAbi, TEventName>, 'abi'${omitted}>${typeParams},
                callback: WatchContractEventCallback<TAbi, TEventName>,
              ) {
                return watchContractEvent(${innerActionConfig} as WatchContractEventConfig<TAbi, TEventName>, callback)
              }
              `;
            } else
              code = dedent`
              ${docString}
              export function watch${baseActionName}Event(config, callback) {
                return watchContractEvent(${innerActionConfig}, callback)
              }
              `;
            content.push(code);
          }
        }
      }
      let packageName;
      if (config.overridePackageName)
        packageName = config.overridePackageName;
      if (await getIsPackageInstalled({ packageName: "wagmi" }))
        packageName = "wagmi/actions";
      else if (await getIsPackageInstalled({ packageName: "@wagmi/core" }))
        packageName = "@wagmi/core";
      else
        packageName = "@wagmi/core";
      const importValues = [...imports.values()];
      return {
        imports: importValues.length ? dedent`
            import { ${importValues.join(", ")} } from '${packageName}'
          ` : "",
        content: content.join("\n\n")
      };
    }
  };
}

// src/plugins/blockExplorer.ts
import { camelCase } from "change-case";
import { z } from "zod";

// src/plugins/fetch.ts
import { default as fse } from "fs-extra";
import { default as fetch_ } from "node-fetch";
import { join } from "pathe";
import { homedir } from "os";
function fetch({
  cacheDuration = 18e5,
  contracts: contractConfigs,
  getCacheKey = ({ contract }) => JSON.stringify(contract),
  name = "Fetch",
  parse = ({ response }) => response.json(),
  request,
  timeoutDuration = 5e3
}) {
  return {
    async contracts() {
      const cacheDir = join(homedir(), ".wagmi-cli/plugins/fetch/cache");
      await fse.ensureDir(cacheDir);
      const timestamp = Date.now() + cacheDuration;
      const contracts = [];
      for (const contract of contractConfigs) {
        const cacheKey = getCacheKey({ contract });
        const cacheFilePath = join(cacheDir, `${cacheKey}.json`);
        const cachedFile = await fse.readJSON(cacheFilePath).catch(() => null);
        let abi;
        if (cachedFile?.timestamp > Date.now())
          abi = cachedFile.abi;
        else {
          const AbortController = globalThis.AbortController || (await import("abort-controller")).default;
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), timeoutDuration);
          try {
            const { url, init } = await request(contract);
            const response = await fetch_(url, {
              ...init,
              signal: controller.signal
            });
            abi = await parse({ response });
            await fse.writeJSON(cacheFilePath, { abi, timestamp });
          } catch (error) {
            try {
              abi = (await fse.readJSON(cacheFilePath)).abi;
            } catch {
            }
            if (!abi)
              throw error;
          } finally {
            clearTimeout(timeout);
          }
        }
        contracts.push({ abi, address: contract.address, name: contract.name });
      }
      return contracts;
    },
    name
  };
}

// src/plugins/blockExplorer.ts
var BlockExplorerResponse = z.discriminatedUnion("status", [
  z.object({
    status: z.literal("1"),
    message: z.literal("OK"),
    result: z.string().transform((val) => JSON.parse(val))
  }),
  z.object({
    status: z.literal("0"),
    message: z.literal("NOTOK"),
    result: z.string()
  })
]);
function blockExplorer({
  apiKey,
  baseUrl,
  cacheDuration,
  contracts,
  getAddress = ({ address }) => {
    if (typeof address === "string")
      return address;
    return Object.values(address)[0];
  },
  name = "Block Explorer"
}) {
  return fetch({
    cacheDuration,
    contracts,
    name,
    getCacheKey({ contract }) {
      if (typeof contract.address === "string")
        return `${camelCase(name)}:${contract.address}`;
      return `${camelCase(name)}:${JSON.stringify(contract.address)}`;
    },
    async parse({ response }) {
      const json = await response.json();
      const parsed = await BlockExplorerResponse.safeParseAsync(json);
      if (!parsed.success)
        throw fromZodError(parsed.error, { prefix: "Invalid response" });
      if (parsed.data.status === "0")
        throw new Error(parsed.data.result);
      return parsed.data.result;
    },
    request({ address }) {
      if (!address)
        throw new Error("address is required");
      return {
        url: `${baseUrl}?module=contract&action=getabi&address=${getAddress({
          address
        })}${apiKey ? `&apikey=${apiKey}` : ""}`
      };
    }
  });
}

// src/plugins/erc.ts
var erc20ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint8" }]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    type: "function",
    name: "increaseAllowance",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "addedValue",
        type: "uint256"
      }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    type: "function",
    name: "decreaseAllowance",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "subtractedValue",
        type: "uint256"
      }
    ],
    outputs: [{ type: "bool" }]
  }
];
var erc721ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: true,
        name: "tokenId",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "ApprovalForAll",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        name: "approved",
        type: "bool"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        name: "tokenId",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "payable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    type: "function",
    name: "getApproved",
    stateMutability: "view",
    inputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: [{ type: "address" }]
  },
  {
    type: "function",
    name: "isApprovedForAll",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "operator",
        type: "address"
      }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    type: "function",
    name: "ownerOf",
    stateMutability: "view",
    inputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "owner",
        type: "address"
      }
    ]
  },
  {
    type: "function",
    name: "safeTransferFrom",
    stateMutability: "payable",
    inputs: [
      {
        name: "from",
        type: "address"
      },
      {
        name: "to",
        type: "address"
      },
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "safeTransferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "from",
        type: "address"
      },
      {
        name: "to",
        type: "address"
      },
      {
        name: "id",
        type: "uint256"
      },
      {
        name: "data",
        type: "bytes"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "setApprovalForAll",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "operator",
        type: "address"
      },
      {
        name: "approved",
        type: "bool"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "string" }]
  },
  {
    type: "function",
    name: "tokenByIndex",
    stateMutability: "view",
    inputs: [
      {
        name: "index",
        type: "uint256"
      }
    ],
    outputs: [{ type: "uint256" }]
  },
  {
    type: "function",
    name: "tokenByIndex",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "index",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "tokenURI",
    stateMutability: "view",
    inputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: [{ type: "string" }]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [{ type: "uint256" }]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "payable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: []
  }
];
var erc4626ABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: false,
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [{ type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "asset",
    outputs: [
      {
        name: "assetTokenAddress",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    name: "convertToAssets",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    name: "convertToShares",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      }
    ],
    name: "deposit",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "caller",
        type: "address"
      }
    ],
    name: "maxDeposit",
    outputs: [
      {
        name: "maxAssets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "caller",
        type: "address"
      }
    ],
    name: "maxMint",
    outputs: [
      {
        name: "maxShares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "maxRedeem",
    outputs: [
      {
        name: "maxShares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "maxWithdraw",
    outputs: [
      {
        name: "maxAssets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    name: "previewDeposit",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    name: "previewMint",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    name: "previewRedeem",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    name: "previewWithdraw",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      },
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "redeem",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "totalAssets",
    outputs: [
      {
        name: "totalManagedAssets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "to",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [{ type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "from",
        type: "address"
      },
      {
        name: "to",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [{ type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      },
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "withdraw",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
function erc(config = {}) {
  const standards = {
    20: true,
    721: true,
    4626: false,
    ...config
  };
  return {
    contracts() {
      const contracts = [];
      if (standards[20])
        contracts.push({
          name: "ERC20",
          abi: erc20ABI
        });
      if (standards[721])
        contracts.push({
          name: "ERC721",
          abi: erc721ABI
        });
      if (standards[4626])
        contracts.push({
          name: "ERC4626",
          abi: erc4626ABI
        });
      return contracts;
    },
    name: "ERC"
  };
}

// src/plugins/etherscan.ts
var apiUrls = {
  [1]: "https://api.etherscan.io/api",
  [5]: "https://api-goerli.etherscan.io/api",
  [10]: "https://api-optimistic.etherscan.io/api",
  [69]: "https://api-goerli-optimistic.etherscan.io/api",
  [137]: "https://api.polygonscan.com/api",
  [80001]: "https://api-testnet.polygonscan.com/api",
  [42161]: "https://api.arbiscan.io/api",
  [421613]: "https://api-goerli.arbiscan.io/api",
  [56]: "https://api.bscscan.com/api",
  [97]: "https://api-testnet.bscscan.com/api",
  [128]: "https://api.hecoinfo.com/api",
  [256]: "https://api-testnet.hecoinfo.com/api",
  [250]: "https://api.ftmscan.com/api",
  [4002]: "https://api-testnet.ftmscan.com/api",
  [43114]: "https://api.snowtrace.io/api",
  [43113]: "https://api-testnet.snowtrace.io/api",
  [42220]: "https://api.celoscan.io/api",
  [44787]: "https://api-alfajores.celoscan.io/api"
};
function etherscan({
  apiKey,
  cacheDuration,
  chainId,
  contracts: contracts_
}) {
  const contracts = contracts_.map((x) => ({
    ...x,
    address: typeof x.address === "string" ? { [chainId]: x.address } : x.address
  }));
  return blockExplorer({
    apiKey,
    baseUrl: apiUrls[chainId],
    cacheDuration,
    contracts,
    getAddress({ address }) {
      if (!address)
        throw new Error("address is required");
      if (typeof address === "string")
        return address;
      const contractAddress = address[chainId];
      if (!contractAddress)
        throw new Error(
          `No address found for chainId "${chainId}". Make sure chainId "${chainId}" is set as an address.`
        );
      return contractAddress;
    },
    name: "Etherscan"
  });
}

// src/plugins/foundry.ts
import dedent2 from "dedent";
import { execa, execaCommandSync } from "execa";
import { default as fse2 } from "fs-extra";
import { globby } from "globby";
import { basename, extname, join as join2, resolve } from "pathe";
import pc from "picocolors";
import { z as z2 } from "zod";
var defaultExcludes = [
  "Common.sol/**",
  "Components.sol/**",
  "Script.sol/**",
  "StdAssertions.sol/**",
  "StdError.sol/**",
  "StdCheats.sol/**",
  "StdMath.sol/**",
  "StdJson.sol/**",
  "StdStorage.sol/**",
  "StdUtils.sol/**",
  "Vm.sol/**",
  "console.sol/**",
  "console2.sol/**",
  "test.sol/**",
  "**.s.sol/*.json",
  "**.t.sol/*.json"
];
var FoundryConfigSchema = z2.object({
  out: z2.string().default("out"),
  src: z2.string().default("src")
});
function foundry({
  artifacts,
  deployments = {},
  exclude = defaultExcludes,
  forge: {
    clean = false,
    build = true,
    path: forgeExecutable = "forge",
    rebuild = true
  } = {},
  include = ["*.json"],
  namePrefix = "",
  project: project_
} = {}) {
  function getContractName(artifactPath, usePrefix = true) {
    const filename = basename(artifactPath);
    const extension = extname(artifactPath);
    return `${usePrefix ? namePrefix : ""}${filename.replace(extension, "")}`;
  }
  async function getContract(artifactPath) {
    const artifact = await fse2.readJSON(artifactPath);
    return {
      abi: artifact.abi,
      address: deployments[getContractName(artifactPath, false)],
      name: getContractName(artifactPath)
    };
  }
  async function getArtifactPaths(artifactsDirectory2) {
    return await globby([
      ...include.map((x) => `${artifactsDirectory2}/**/${x}`),
      ...exclude.map((x) => `!${artifactsDirectory2}/**/${x}`)
    ]);
  }
  const project = resolve(process.cwd(), project_ ?? "");
  let config = {
    out: "out",
    src: "src"
  };
  try {
    config = FoundryConfigSchema.parse(
      JSON.parse(
        execaCommandSync(`${forgeExecutable} config --json --root ${project}`).stdout
      )
    );
  } catch {
  } finally {
    config = {
      ...config,
      out: artifacts ?? config.out
    };
  }
  const artifactsDirectory = join2(project, config.out);
  return {
    async contracts() {
      if (clean)
        await execa(forgeExecutable, ["clean", "--root", project]);
      if (build)
        await execa(forgeExecutable, ["build", "--root", project]);
      if (!fse2.pathExistsSync(artifactsDirectory))
        throw new Error("Artifacts not found.");
      const artifactPaths = await getArtifactPaths(artifactsDirectory);
      const contracts = [];
      for (const artifactPath of artifactPaths) {
        const contract = await getContract(artifactPath);
        if (!contract.abi?.length)
          continue;
        contracts.push(contract);
      }
      return contracts;
    },
    name: "Foundry",
    async validate() {
      if (!await fse2.pathExists(project))
        throw new Error(`Foundry project ${pc.gray(project_)} not found.`);
      if (clean || build || rebuild)
        try {
          await execa(forgeExecutable, ["--version"]);
        } catch (error) {
          throw new Error(dedent2`
            forge must be installed to use Foundry plugin.
            To install, follow the instructions at https://book.getfoundry.sh/getting-started/installation
          `);
        }
    },
    watch: {
      command: rebuild ? async () => {
        log(
          `${pc.magenta("Foundry")} Watching project at ${pc.gray(
            project
          )}`
        );
        const subprocess = execa(forgeExecutable, [
          "build",
          "--watch",
          "--root",
          project
        ]);
        subprocess.stdout?.on("data", (data) => {
          process.stdout.write(`${pc.magenta("Foundry")} ${data}`);
        });
        process.once("SIGINT", shutdown);
        process.once("SIGTERM", shutdown);
        function shutdown() {
          subprocess?.cancel();
        }
      } : void 0,
      paths: [
        ...include.map((x) => `${artifactsDirectory}/**/${x}`),
        ...exclude.map((x) => `!${artifactsDirectory}/**/${x}`)
      ],
      async onAdd(path) {
        return getContract(path);
      },
      async onChange(path) {
        return getContract(path);
      },
      async onRemove(path) {
        return getContractName(path);
      }
    }
  };
}

// src/plugins/hardhat.ts
import dedent3 from "dedent";
import { execa as execa2 } from "execa";
import { default as fse3 } from "fs-extra";
import { globby as globby2 } from "globby";
import { basename as basename2, extname as extname2, join as join3, resolve as resolve2 } from "pathe";
import pc2 from "picocolors";
var defaultExcludes2 = ["build-info/**", "*.dbg.json"];
function hardhat({
  artifacts = "artifacts",
  deployments = {},
  exclude = defaultExcludes2,
  commands = {},
  include = ["*.json"],
  namePrefix = "",
  project: project_,
  sources = "contracts"
}) {
  function getContractName(artifact) {
    return `${namePrefix}${artifact.contractName}`;
  }
  async function getContract(artifactPath) {
    const artifact = await fse3.readJSON(artifactPath);
    return {
      abi: artifact.abi,
      address: deployments[artifact.contractName],
      name: getContractName(artifact)
    };
  }
  async function getArtifactPaths(artifactsDirectory2) {
    return await globby2([
      ...include.map((x) => `${artifactsDirectory2}/**/${x}`),
      ...exclude.map((x) => `!${artifactsDirectory2}/**/${x}`)
    ]);
  }
  const project = resolve2(process.cwd(), project_);
  const artifactsDirectory = join3(project, artifacts);
  const sourcesDirectory = join3(project, sources);
  const { build = true, clean = false, rebuild = true } = commands;
  return {
    async contracts() {
      if (clean) {
        const packageManager = await getPackageManager();
        const [command, ...options] = (typeof clean === "boolean" ? `${packageManager} hardhat clean` : clean).split(" ");
        await execa2(command, options, { cwd: project });
      }
      if (build) {
        const packageManager = await getPackageManager();
        const [command, ...options] = (typeof build === "boolean" ? `${packageManager} hardhat compile` : build).split(" ");
        await execa2(command, options, { cwd: project });
      }
      if (!fse3.pathExistsSync(artifactsDirectory))
        throw new Error("Artifacts not found.");
      const artifactPaths = await getArtifactPaths(artifactsDirectory);
      const contracts = [];
      for (const artifactPath of artifactPaths) {
        const contract = await getContract(artifactPath);
        if (!contract.abi?.length)
          continue;
        contracts.push(contract);
      }
      return contracts;
    },
    name: "Hardhat",
    async validate() {
      if (!await fse3.pathExists(project))
        throw new Error(`Hardhat project ${pc2.gray(project)} not found.`);
      const packageName = "hardhat";
      const isPackageInstalled = await getIsPackageInstalled({
        packageName,
        cwd: project
      });
      if (isPackageInstalled)
        return;
      const [packageManager, command] = await getInstallCommand(packageName);
      throw new Error(dedent3`
        ${packageName} must be installed to use Hardhat plugin.
        To install, run: ${packageManager} ${command.join(" ")}
      `);
    },
    watch: {
      command: rebuild ? async () => {
        log(
          `${pc2.blue("Hardhat")} Watching project at ${pc2.gray(project)}`
        );
        const [command, ...options] = (typeof rebuild === "boolean" ? `${await getPackageManager()} hardhat compile` : rebuild).split(" ");
        const { watch } = await import("chokidar");
        const watcher = watch(sourcesDirectory, {
          atomic: true,
          awaitWriteFinish: true,
          ignoreInitial: true,
          persistent: true
        });
        watcher.on("all", async (event, path) => {
          if (event !== "change" && event !== "add" && event !== "unlink")
            return;
          log(
            `${pc2.blue("Hardhat")} Detected ${event} at ${basename2(path)}`
          );
          const subprocess = execa2(command, options, {
            cwd: project
          });
          subprocess.stdout?.on("data", (data) => {
            process.stdout.write(`${pc2.blue("Hardhat")} ${data}`);
          });
        });
        process.once("SIGINT", shutdown);
        process.once("SIGTERM", shutdown);
        async function shutdown() {
          await watcher.close();
        }
      } : void 0,
      paths: [
        artifactsDirectory,
        ...include.map((x) => `${artifactsDirectory}/**/${x}`),
        ...exclude.map((x) => `!${artifactsDirectory}/**/${x}`)
      ],
      async onAdd(path) {
        return getContract(path);
      },
      async onChange(path) {
        return getContract(path);
      },
      async onRemove(path) {
        const filename = basename2(path);
        const extension = extname2(path);
        const removedContractName = `${namePrefix}${filename.replace(
          extension,
          ""
        )}`;
        const artifactPaths = await getArtifactPaths(artifactsDirectory);
        for (const artifactPath of artifactPaths) {
          const contract = await getContract(artifactPath);
          if (contract.name === removedContractName)
            return;
        }
        return removedContractName;
      }
    }
  };
}

// src/plugins/react.ts
import { pascalCase as pascalCase2 } from "change-case";
import dedent4 from "dedent";
function react(config = {}) {
  const hooks = {
    useContract: true,
    useContractEvent: true,
    useContractItemEvent: true,
    useContractRead: true,
    useContractFunctionRead: true,
    useContractWrite: true,
    useContractFunctionWrite: true,
    usePrepareContractWrite: true,
    usePrepareContractFunctionWrite: true,
    ...config
  };
  return {
    name: "React",
    async run({ contracts, isTypeScript, outputs }) {
      const imports = /* @__PURE__ */ new Set([]);
      const actionsImports = /* @__PURE__ */ new Set([]);
      const hasWriteContractMode = outputs.some(
        (x) => x.plugin.name === "Actions" && x.imports?.includes("WriteContractMode")
      );
      const content = [];
      for (const contract of contracts) {
        const baseHookName = pascalCase2(contract.name);
        let typeParams = "";
        let innerContent = "";
        let omitted = "";
        const innerHookParams = {
          abi: contract.meta.abiName
        };
        if (contract.meta.addressName) {
          omitted = `| 'address'`;
          if (typeof contract.address === "object") {
            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}  }`;
            if (Object.keys(contract.address).length > 1) {
              innerHookParams["address"] = `${contract.meta.addressName}[chainId as keyof typeof ${contract.meta.addressName}]`;
              imports.add("useNetwork");
              innerContent = dedent4`
                const { chain } = useNetwork()
                const chainId = config.chainId ?? chain?.id
              `;
            } else
              innerHookParams["address"] = `${contract.meta.addressName}[${Object.keys(contract.address)[0]}]`;
          } else if (contract.address)
            innerHookParams["address"] = contract.meta.addressName;
        }
        const innerHookConfig = Object.entries(innerHookParams).reduce(
          (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
          "{"
        ) + "...config}";
        const genDocString = (hookName, item) => {
          let description = `Wraps __{@link ${hookName}}__ with \`abi\` set to __{@link ${contract.meta.abiName}}__`;
          if (item)
            description += ` and \`${item.name}\` set to \`"${item.value}"\``;
          if (contract.address) {
            const docString = getAddressDocString({ address: contract.address });
            if (docString)
              return dedent4`
              /**
              * ${description}.
              * 
              ${docString}
              */
              `;
          }
          return dedent4`
          /**
           * ${description}.
           */
          `;
        };
        if (hooks.useContract) {
          imports.add("useContract");
          const docString = genDocString("useContract");
          let code;
          if (isTypeScript) {
            imports.add("UseContractConfig");
            code = dedent4`
            ${docString}
            export function use${baseHookName}(
              config: Omit<UseContractConfig, 'abi'${omitted}>${typeParams} = {} as any,
            ) {
              ${innerContent}
              return useContract(${innerHookConfig})
            }
            `;
          } else
            code = dedent4`
            ${docString}
            export function use${baseHookName}(config = {}) {
              ${innerContent}
              return useContract(${innerHookConfig})
            }
            `;
          content.push(code);
        }
        let hasReadFunction, hasWriteFunction, hasEvent = false;
        for (const component of contract.abi) {
          if (component.type === "function")
            if (component.stateMutability === "view" || component.stateMutability === "pure")
              hasReadFunction = true;
            else
              hasWriteFunction = true;
          else if (component.type === "event")
            hasEvent = true;
          if (hasReadFunction && hasWriteFunction && hasEvent)
            break;
        }
        if (hasReadFunction) {
          if (hooks.useContractRead) {
            imports.add("useContractRead");
            const docString = genDocString("useContractRead");
            let code;
            if (isTypeScript) {
              imports.add("UseContractReadConfig");
              actionsImports.add("ReadContractResult");
              code = dedent4`
              ${docString}
              export function use${baseHookName}Read<
                TFunctionName extends string,
                TSelectData = ReadContractResult<typeof ${contract.meta.abiName}, TFunctionName>
              >(
                config: Omit<UseContractReadConfig<typeof ${contract.meta.abiName}, TFunctionName, TSelectData>, 'abi'${omitted}>${typeParams} = {} as any,
              ) {
                ${innerContent}
                return useContractRead(${innerHookConfig} as UseContractReadConfig<typeof ${contract.meta.abiName}, TFunctionName, TSelectData>)
              }
              `;
            } else
              code = dedent4`
              ${docString}
              export function use${baseHookName}Read(config = {}) {
                ${innerContent}
                return useContractRead(${innerHookConfig})
              }
              `;
            content.push(code);
          }
          if (hooks.useContractFunctionRead) {
            const contractNames = /* @__PURE__ */ new Set();
            for (const item of contract.abi) {
              if (item.type === "function" && (item.stateMutability === "view" || item.stateMutability === "pure")) {
                if (contractNames.has(item.name))
                  continue;
                contractNames.add(item.name);
                const config2 = Object.entries({
                  ...innerHookParams,
                  functionName: `'${item.name}'`
                }).reduce(
                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
                  "{"
                ) + "...config}";
                imports.add("useContractRead");
                const docString = genDocString("useContractRead", {
                  name: "functionName",
                  value: item.name
                });
                let code;
                if (isTypeScript) {
                  imports.add("UseContractReadConfig");
                  actionsImports.add("ReadContractResult");
                  code = dedent4`
                  ${docString}
                  export function use${baseHookName}${pascalCase2(item.name)}<TSelectData = ReadContractResult<typeof ${contract.meta.abiName}, '${item.name}'>>(
                    config: Omit<UseContractReadConfig<typeof ${contract.meta.abiName}, '${item.name}', TSelectData>, 'abi'${omitted} | 'functionName'>${typeParams} = {} as any,
                  ) {
                    ${innerContent}
                    return useContractRead(${config2} as UseContractReadConfig<typeof ${contract.meta.abiName}, '${item.name}', TSelectData>)
                  }
                  `;
                } else {
                  code = dedent4`
                  ${docString}
                  export function use${baseHookName}${pascalCase2(item.name)}Read(config = {}) {
                    ${innerContent}
                    return useContractRead(${config2})
                  }
                  `;
                }
                content.push(code);
              }
            }
          }
        }
        if (hasWriteFunction) {
          if (hooks.useContractWrite) {
            imports.add("useContractWrite");
            const docString = genDocString("useContractWrite");
            let code;
            if (isTypeScript) {
              const hasMultichainAddress = typeof contract.address === "object";
              const TChainId = hasMultichainAddress ? `TChainId extends number = keyof typeof ${contract.meta.addressName}` : "";
              let typeParams_ = "";
              if (TChainId)
                typeParams_ = "address?: never; chainId?: TChainId;";
              imports.add("UseContractWriteConfig");
              if (!hasWriteContractMode)
                actionsImports.add("WriteContractMode");
              actionsImports.add("PrepareWriteContractResult");
              code = dedent4`
              ${docString}
              export function use${baseHookName}Write<
                TMode extends WriteContractMode,
                TFunctionName extends string,
                ${TChainId}
              >(
                config: TMode extends 'prepared'
                  ? UseContractWriteConfig<
                      TMode,
                      PrepareWriteContractResult<typeof ${contract.meta.abiName}, string>['abi'],
                      TFunctionName
                    >${TChainId ? ` & { address?: \`0x\${string}\`; chainId?: TChainId; }` : ""}
                  : UseContractWriteConfig<TMode, typeof ${contract.meta.abiName}, TFunctionName> & {
                      abi?: never
                      ${typeParams_}
                    } = {} as any,
              ) {
                ${innerContent}
                return useContractWrite<TMode, typeof ${contract.meta.abiName}, TFunctionName>(${innerHookConfig} as any)
              }
              `;
            } else
              code = dedent4`
              ${docString}
              export function use${baseHookName}Write(config = {}) {
                ${innerContent}
                return useContractWrite(${innerHookConfig})
              }
              `;
            content.push(code);
          }
          if (hooks.useContractFunctionWrite) {
            const contractNames = /* @__PURE__ */ new Set();
            for (const item of contract.abi) {
              if (item.type === "function" && (item.stateMutability === "nonpayable" || item.stateMutability === "payable")) {
                if (contractNames.has(item.name))
                  continue;
                contractNames.add(item.name);
                const config2 = Object.entries({
                  ...innerHookParams,
                  functionName: `'${item.name}'`
                }).reduce(
                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
                  "{"
                ) + "...config}";
                imports.add("useContractWrite");
                const docString = genDocString("useContractWrite", {
                  name: "functionName",
                  value: item.name
                });
                let code;
                if (isTypeScript) {
                  const hasMultichainAddress = typeof contract.address === "object";
                  const TChainId = hasMultichainAddress ? `TChainId extends number = keyof typeof ${contract.meta.addressName}` : "";
                  let preparedTypeParams = `functionName?: '${item.name}'`;
                  let unpreparedTypeParams = `functionName?: '${item.name}'`;
                  if (TChainId) {
                    preparedTypeParams = `address?: \`0x\${string}\`; chainId?: TChainId; functionName?: '${item.name}'`;
                    unpreparedTypeParams = `address?: never; chainId?: TChainId; functionName?: '${item.name}'`;
                  }
                  imports.add("UseContractWriteConfig");
                  if (!hasWriteContractMode)
                    actionsImports.add("WriteContractMode");
                  actionsImports.add("PrepareWriteContractResult");
                  code = dedent4`
                  ${docString}
                  export function use${baseHookName}${pascalCase2(item.name)}<
                    TMode extends WriteContractMode,
                    ${TChainId}
                  >(
                    config: TMode extends 'prepared'
                    ? UseContractWriteConfig<
                        TMode,
                        PrepareWriteContractResult<typeof ${contract.meta.abiName}, '${item.name}'>['abi'],
                        '${item.name}'
                      > & {${preparedTypeParams}}
                    : UseContractWriteConfig<TMode, typeof ${contract.meta.abiName}, '${item.name}'> & {
                        abi?: never
                        ${unpreparedTypeParams}
                      } = {} as any,
                  ) {
                    ${innerContent}
                    return useContractWrite<TMode, typeof ${contract.meta.abiName}, '${item.name}'>(${config2} as any)
                  }
                  `;
                } else {
                  code = dedent4`
                  ${docString}
                  export function use${baseHookName}${pascalCase2(item.name)}(config = {}) {
                    ${innerContent}
                    return useContractWrite(${config2})
                  }
                  `;
                }
                content.push(code);
              }
            }
          }
          if (hooks.usePrepareContractWrite) {
            imports.add("usePrepareContractWrite");
            const docString = genDocString("usePrepareContractWrite");
            let code;
            if (isTypeScript) {
              imports.add("UsePrepareContractWriteConfig");
              code = dedent4`
              ${docString}
              export function usePrepare${baseHookName}Write<
                TFunctionName extends string,
              >(
                config: Omit<UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, TFunctionName>, 'abi'${omitted}>${typeParams} = {} as any,
              ) {
                ${innerContent}
                return usePrepareContractWrite(${innerHookConfig} as UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, TFunctionName>)
              }
              `;
            } else
              code = dedent4`
              ${docString}
              export function usePrepare${baseHookName}Write(config = {}) {
                ${innerContent}
                return usePrepareContractWrite(${innerHookConfig})
              }
              `;
            content.push(code);
          }
          if (hooks.usePrepareContractFunctionWrite) {
            const contractNames = /* @__PURE__ */ new Set();
            for (const item of contract.abi) {
              if (item.type === "function" && (item.stateMutability === "nonpayable" || item.stateMutability === "payable")) {
                if (contractNames.has(item.name))
                  continue;
                contractNames.add(item.name);
                const config2 = Object.entries({
                  ...innerHookParams,
                  functionName: `'${item.name}'`
                }).reduce(
                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
                  "{"
                ) + "...config}";
                imports.add("usePrepareContractWrite");
                const docString = genDocString("usePrepareContractWrite", {
                  name: "functionName",
                  value: item.name
                });
                let code;
                if (isTypeScript) {
                  imports.add("UsePrepareContractWriteConfig");
                  code = dedent4`
                  ${docString}
                  export function usePrepare${baseHookName}${pascalCase2(item.name)}(
                    config: Omit<UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, '${item.name}'>, 'abi'${omitted} | 'functionName'>${typeParams} = {} as any,
                  ) {
                    ${innerContent}
                    return usePrepareContractWrite(${config2} as UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, '${item.name}'>)
                  }
                  `;
                } else {
                  code = dedent4`
                  ${docString}
                  export function usePrepare${baseHookName}${pascalCase2(item.name)}(config = {}) {
                    ${innerContent}
                    return usePrepareContractWrite(${config2})
                  }
                  `;
                }
                content.push(code);
              }
            }
          }
        }
        if (hasEvent) {
          if (hooks.useContractEvent) {
            imports.add("useContractEvent");
            const docString = genDocString("useContractEvent");
            let code;
            if (isTypeScript) {
              imports.add("UseContractEventConfig");
              code = dedent4`
              ${docString}
              export function use${baseHookName}Event<
                TEventName extends string,
              >(
                config: Omit<UseContractEventConfig<typeof ${contract.meta.abiName}, TEventName>, 'abi'${omitted}>${typeParams} = {} as any,
              ) {
                ${innerContent}
                return useContractEvent(${innerHookConfig} as UseContractEventConfig<typeof ${contract.meta.abiName}, TEventName>)
              }
              `;
            } else
              code = dedent4`
              ${docString}
              export function use${baseHookName}Event(config = {}) {
                ${innerContent}
                return useContractEvent(${innerHookConfig})
              }
              `;
            content.push(code);
          }
          if (hooks.useContractItemEvent) {
            const contractNames = /* @__PURE__ */ new Set();
            for (const item of contract.abi) {
              if (item.type === "event") {
                if (contractNames.has(item.name))
                  continue;
                contractNames.add(item.name);
                const config2 = Object.entries({
                  ...innerHookParams,
                  eventName: `'${item.name}'`
                }).reduce(
                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
                  "{"
                ) + "...config}";
                imports.add("useContractEvent");
                const docString = genDocString("useContractEvent", {
                  name: "eventName",
                  value: item.name
                });
                let code;
                if (isTypeScript) {
                  imports.add("UseContractEventConfig");
                  code = dedent4`
                  ${docString}
                  export function use${baseHookName}${pascalCase2(item.name)}Event(
                    config: Omit<UseContractEventConfig<typeof ${contract.meta.abiName}, '${item.name}'>, 'abi'${omitted} | 'eventName'>${typeParams} = {} as any,
                  ) {
                    ${innerContent}
                    return useContractEvent(${config2} as UseContractEventConfig<typeof ${contract.meta.abiName}, '${item.name}'>)
                  }
                  `;
                } else {
                  code = dedent4`
                  ${docString}
                  export function use${baseHookName}${pascalCase2(item.name)}Event(config = {}) {
                    ${innerContent}
                    return useContractEvent(${config2})
                  }
                  `;
                }
                content.push(code);
              }
            }
          }
        }
      }
      const importValues = [...imports.values()];
      const actionsImportValues = [...actionsImports.values()];
      return {
        imports: (importValues.length ? `import { ${importValues.join(", ")} } from 'wagmi'
` : "") + (actionsImportValues.length ? `import { ${actionsImportValues.join(
          ", "
        )} } from 'wagmi/actions'` : ""),
        content: content.join("\n\n")
      };
    }
  };
}

// src/plugins/sourcify.ts
import { Abi as AbiSchema } from "abitype/zod";
import { z as z3 } from "zod";
var SourcifyResponse = z3.object({
  compiler: z3.object({
    version: z3.string()
  }),
  language: z3.string(),
  output: z3.object({
    abi: AbiSchema,
    devdoc: z3.any(),
    userdoc: z3.any()
  }),
  settings: z3.any(),
  sources: z3.any(),
  version: z3.number()
});
function sourcify({
  cacheDuration,
  chainId,
  contracts: contracts_
}) {
  const contracts = contracts_.map((x) => ({
    ...x,
    address: typeof x.address === "string" ? { [chainId]: x.address } : x.address
  }));
  return fetch({
    cacheDuration,
    contracts,
    async parse({ response }) {
      if (response.status === 404)
        throw new Error("Contract not found in Sourcify repository.");
      const json = await response.json();
      const parsed = await SourcifyResponse.safeParseAsync(json);
      if (!parsed.success)
        throw fromZodError(parsed.error, { prefix: "Invalid response" });
      if (parsed.data.output.abi)
        return parsed.data.output.abi;
      throw new Error("contract not found");
    },
    request({ address }) {
      if (!address)
        throw new Error("address is required");
      let contractAddress;
      if (typeof address === "string")
        contractAddress = address;
      if (typeof address === "object")
        contractAddress = address[chainId];
      if (!contractAddress)
        throw new Error(
          `No address found for chainId "${chainId}". Make sure chainId "${chainId}" is set as an address.`
        );
      return {
        url: `https://repo.sourcify.dev/contracts/full_match/${chainId}/${contractAddress}/metadata.json`
      };
    }
  });
}
export {
  actions,
  blockExplorer,
  erc,
  etherscan,
  fetch,
  foundry,
  hardhat,
  react,
  sourcify
};
