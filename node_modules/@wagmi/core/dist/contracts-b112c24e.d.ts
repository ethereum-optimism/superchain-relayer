import { Abi, AbiStateMutability, Narrow, Address, ExtractAbiFunctionNames, AbiFunction, ExtractAbiFunction, AbiParametersToPrimitiveTypes, AbiParameterToPrimitiveType, AbiEvent, AbiParameter, ResolvedConfig } from 'abitype';
import { ethers } from 'ethers';

/**
 * Count occurrences of {@link TType} in {@link TArray}
 *
 * @param TArray - Array to count occurrences in
 * @param TType - Type to count occurrences of
 * @returns Number of occurrences of {@link TType} in {@link TArray}
 *
 * @example
 * type Result = CountOccurrences<['foo', 'bar', 'foo'], 'foo'>
 */
type CountOccurrences<TArray extends readonly unknown[], TType> = FilterNever<[
    ...{
        [K in keyof TArray]: TArray[K] extends TType ? TArray[K] : never;
    }
]>['length'];
/**
 * Removes all occurrences of `never` from {@link TArray}
 *
 * @param TArray - Array to filter
 * @returns Array with `never` removed
 *
 * @example
 * type Result = FilterNever<[1, 2, never, 3, never, 4]>
 */
type FilterNever<TArray extends readonly unknown[]> = TArray['length'] extends 0 ? [] : TArray extends [infer THead, ...infer TRest] ? IsNever<THead> extends true ? FilterNever<TRest> : [THead, ...FilterNever<TRest>] : never;
/**
 * Check if {@link T} is `never`
 *
 * @param T - Type to check
 * @returns `true` if {@link T} is `never`, otherwise `false`
 *
 * @example
 * type Result = IsNever<'foo'>
 */
type IsNever<T> = [T] extends [never] ? true : false;
/**
 * Checks if {@link T} is `unknown`
 *
 * @param T - Type to check
 * @returns `true` if {@link T} is `unknown`, otherwise `false`
 *
 * @example
 * type Result = IsUnknown<unknown>
 */
type IsUnknown<T> = unknown extends T ? true : false;
/**
 * Joins {@link Items} into string separated by {@link Separator}
 *
 * @param Items - Items to join
 * @param Separator - Separator to use
 * @returns Joined string
 *
 * @example
 * type Result = Join<['foo', 'bar'], '-'>
 */
type Join<Items extends string[], Separator extends string | number> = Items extends [infer First, ...infer Rest] ? First extends string ? Rest extends string[] ? Rest extends [] ? `${First}` : `${First}${Separator}${Join<Rest, Separator>}` : never : never : '';
/**
 * Converts {@link Union} to intersection
 *
 * @param Union - Union to convert
 * @returns Intersection of {@link Union}
 *
 * @example
 * type Result = UnionToIntersection<'foo' | 'bar'>
 */
type UnionToIntersection<Union> = (Union extends unknown ? (arg: Union) => unknown : never) extends (arg: infer R) => unknown ? R : never;

type Contract<TAbi extends Abi | readonly unknown[] = Abi | readonly unknown[], TFunctionName extends string = string> = {
    abi: TAbi;
    functionName: TFunctionName;
};
type GetConfig<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TAbiStateMutability extends AbiStateMutability = AbiStateMutability> = {
    /** Contract ABI */
    abi: Narrow<TAbi>;
    /** Contract address */
    address: Address;
    /** Function to invoke on the contract */
    functionName: GetFunctionName<TAbi, TFunctionName, TAbiStateMutability>;
} & GetArgs<TAbi, TFunctionName>;
type GetFunctionName<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TAbiStateMutability extends AbiStateMutability = AbiStateMutability> = TAbi extends Abi ? ExtractAbiFunctionNames<TAbi, TAbiStateMutability> extends infer AbiFunctionNames ? AbiFunctionNames | (TFunctionName extends AbiFunctionNames ? TFunctionName : never) | (Abi extends TAbi ? string : never) : never : TFunctionName;
type GetArgs<TAbi extends Abi | readonly unknown[], TFunctionName extends string, TAbiFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : AbiFunction & {
    type: 'function';
}, TArgs = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? {
    /**
     * Arguments to pass contract method
     *
     * Use a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) on {@link abi} for type inference.
     */
    args?: readonly unknown[];
} : TArgs extends readonly [] ? {
    args?: never;
} : {
    /** Arguments to pass contract method */ args: TArgs;
};
type GetReturnType<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TAbiFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : AbiFunction & {
    type: 'function';
}, TArgs = AbiParametersToPrimitiveTypes<TAbiFunction['outputs']>, FailedToParseArgs = ([TArgs] extends [never] ? true : false) | (readonly unknown[] extends TArgs ? true : false)> = true extends FailedToParseArgs ? unknown : TArgs extends readonly [] ? void : TArgs extends readonly [infer Arg] ? Arg : TArgs & {
    [Output in TAbiFunction['outputs'][number] as Output extends {
        name: infer Name extends string;
    } ? Name extends '' ? never : Name : never]: AbiParameterToPrimitiveType<Output>;
};
type MAXIMUM_DEPTH = 20;
/**
 * ContractsConfig reducer recursively unwraps function arguments to infer/enforce type param
 */
type ContractsConfig<TContracts extends Contract[], TProperties extends Record<string, any> = object, Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? (GetConfig & TProperties)[] : TContracts extends [] ? [] : TContracts extends [infer Head extends Contract] ? [
    ...Result,
    GetConfig<Head['abi'], Head['functionName'], 'pure' | 'view'> & TProperties
] : TContracts extends [
    infer Head extends Contract,
    ...infer Tail extends Contract[]
] ? ContractsConfig<[
    ...Tail
], TProperties, [
    ...Result,
    GetConfig<Head['abi'], Head['functionName'], 'pure' | 'view'> & TProperties
], [
    ...Depth,
    1
]> : unknown[] extends TContracts ? TContracts : TContracts extends GetConfig<infer TAbi, infer TFunctionName>[] ? (GetConfig<TAbi, TFunctionName> & TProperties)[] : (GetConfig & TProperties)[];
/**
 * ContractsResult reducer recursively maps type param to results
 */
type ContractsResult<TContracts extends Contract[], Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? GetReturnType[] : TContracts extends [] ? [] : TContracts extends [infer Head extends Contract] ? [...Result, GetReturnType<Head['abi'], Head['functionName']>] : TContracts extends [
    infer Head extends Contract,
    ...infer Tail extends Contract[]
] ? ContractsResult<[
    ...Tail
], [
    ...Result,
    GetReturnType<Head['abi'], Head['functionName']>
], [
    ...Depth,
    1
]> : TContracts extends GetConfig<infer TAbi, infer TFunctionName>[] ? GetReturnType<TAbi, TFunctionName>[] : GetReturnType[];
/**
 * Get name for {@link AbiFunction} or {@link AbiEvent}
 *
 * @param TAbiItem - {@link AbiFunction} or {@link AbiEvent}
 * @param IsSignature - Whether to return the signature instead of the name
 * @returns Name or signature of function or event
 *
 * @example
 * type Result = AbiItemName<{ type: 'function'; name: 'Foo'; â€¦ }>
 */
type AbiItemName<TAbiItem extends (AbiFunction & {
    type: 'function';
}) | AbiEvent, IsSignature extends boolean = false> = IsSignature extends true ? TAbiItem['inputs'] extends infer TAbiParameters extends readonly AbiParameter[] ? `${TAbiItem['name']}(${Join<[
    ...{
        [K in keyof TAbiParameters]: TAbiParameters[K]['type'];
    }
], ','>})` : never : TAbiItem['name'];
/**
 * Get overrides for {@link AbiStateMutability}
 *
 * @param TAbiStateMutability - {@link AbiStateMutability}
 * @returns Overrides for {@link TAbiStateMutability}
 *
 * @example
 * type Result = GetOverridesForAbiStateMutability<'pure'>
 */
type GetOverridesForAbiStateMutability<TAbiStateMutability extends AbiStateMutability> = {
    nonpayable: Overrides & {
        from?: Address;
    };
    payable: PayableOverrides & {
        from?: Address;
    };
    pure: CallOverrides;
    view: CallOverrides;
}[TAbiStateMutability];
interface Overrides extends ethers.Overrides {
    gasLimit?: ResolvedConfig['BigIntType'];
    gasPrice?: ResolvedConfig['BigIntType'];
    maxFeePerGas?: ResolvedConfig['BigIntType'];
    maxPriorityFeePerGas?: ResolvedConfig['BigIntType'];
    nonce?: ResolvedConfig['IntType'];
}
interface PayableOverrides extends Overrides {
    value?: ResolvedConfig['IntType'] | ResolvedConfig['BigIntType'];
}
interface CallOverrides extends PayableOverrides {
    blockTag?: ethers.CallOverrides['blockTag'];
    from?: Address;
}
type Event<TAbiEvent extends AbiEvent> = Omit<ethers.Event, 'args' | 'event' | 'eventSignature'> & {
    args: AbiParametersToPrimitiveTypes<TAbiEvent['inputs']>;
    event: TAbiEvent['name'];
    eventSignature: AbiItemName<TAbiEvent, true>;
};

export { AbiItemName as A, CountOccurrences as C, Event as E, GetConfig as G, IsUnknown as I, UnionToIntersection as U, GetOverridesForAbiStateMutability as a, Contract as b, ContractsConfig as c, ContractsResult as d, GetReturnType as e, GetFunctionName as f, GetArgs as g };
