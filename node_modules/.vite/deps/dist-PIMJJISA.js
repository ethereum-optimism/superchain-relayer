import {
  require_util
} from "./chunk-BG2UDF42.js";
import {
  require_events
} from "./chunk-PFNBEZCN.js";
import {
  require_bn,
  require_inherits_browser
} from "./chunk-SA2S7KCV.js";
import "./chunk-DUNJSBVX.js";
import {
  require_buffer
} from "./chunk-UEV5ASBE.js";
import "./chunk-4TQWJ3HO.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-JZQ37OGZ.js";

// node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js
var require_wallet_logo = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletLogo = void 0;
    var walletLogo = (type, width) => {
      let height;
      switch (type) {
        case "standard":
          height = width;
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
        case "circle":
          height = width;
          return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
        case "text":
          height = (0.1 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogo":
          height = (0.25 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        case "textLight":
          height = (0.1 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogoLight":
          height = (0.25 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        default:
          height = width;
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
      }
    };
    exports.walletLogo = walletLogo;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js
var require_ScopedLocalStorage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopedLocalStorage = void 0;
    var ScopedLocalStorage = class {
      constructor(scope) {
        this.scope = scope;
      }
      setItem(key, value) {
        localStorage.setItem(this.scopedKey(key), value);
      }
      getItem(key) {
        return localStorage.getItem(this.scopedKey(key));
      }
      removeItem(key) {
        localStorage.removeItem(this.scopedKey(key));
      }
      clear() {
        const prefix = this.scopedKey("");
        const keysToRemove = [];
        for (let i3 = 0; i3 < localStorage.length; i3++) {
          const key = localStorage.key(i3);
          if (typeof key === "string" && key.startsWith(prefix)) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach((key) => localStorage.removeItem(key));
      }
      scopedKey(key) {
        return `${this.scope}:${key}`;
      }
    };
    exports.ScopedLocalStorage = ScopedLocalStorage;
  }
});

// node_modules/@metamask/safe-event-emitter/index.js
var require_safe_event_emitter = __commonJS({
  "node_modules/@metamask/safe-event-emitter/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    function safeApply(handler, context, args) {
      try {
        Reflect.apply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr) {
      const n2 = arr.length;
      const copy = new Array(n2);
      for (let i3 = 0; i3 < n2; i3 += 1) {
        copy[i3] = arr[i3];
      }
      return copy;
    }
    var SafeEventEmitter = class extends events_1.EventEmitter {
      emit(type, ...args) {
        let doError = type === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er;
          if (args.length > 0) {
            [er] = args;
          }
          if (er instanceof Error) {
            throw er;
          }
          const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
          err.context = er;
          throw err;
        }
        const handler = events[type];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply(handler, this, args);
        } else {
          const len = handler.length;
          const listeners = arrayClone(handler);
          for (let i3 = 0; i3 < len; i3 += 1) {
            safeApply(listeners[i3], this, args);
          }
        }
        return true;
      }
    };
    exports.default = SafeEventEmitter;
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_3) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k3, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k3);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k3, { value: replace });
          arr.push([parent, k3, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k3, replace]);
        }
      } else {
        parent[k3] = replace;
        arr.push([parent, k3, val]);
      }
    }
    function decirc(val, k3, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i3;
      if (typeof val === "object" && val !== null) {
        for (i3 = 0; i3 < stack.length; i3++) {
          if (stack[i3] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k3, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i3 = 0; i3 < val.length; i3++) {
            decirc(val[i3], i3, i3, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            decirc(val[key], key, i3, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a3, b3) {
      if (a3 < b3) {
        return -1;
      }
      if (a3 > b3) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_3) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k3, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i3;
      if (typeof val === "object" && val !== null) {
        for (i3 = 0; i3 < stack.length; i3++) {
          if (stack[i3] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k3, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_3) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i3 = 0; i3 < val.length; i3++) {
            deterministicDecirc(val[i3], i3, i3, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            deterministicDecirc(val[key], key, i3, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k3, val]);
            parent[k3] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k3, v3) {
        return v3;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i3 = 0; i3 < replacerStack.length; i3++) {
            var part = replacerStack[i3];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i3, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_3, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/DiagnosticLogger.js
var require_DiagnosticLogger = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/DiagnosticLogger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENTS = void 0;
    exports.EVENTS = {
      STARTED_CONNECTING: "walletlink_sdk.started.connecting",
      CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
      DISCONNECTED: "walletlink_sdk.disconnected",
      METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
      LINKED: "walletlink_sdk.linked",
      FAILURE: "walletlink_sdk.generic_failure",
      SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
      ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
      SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
      UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
      SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
      GENERAL_ERROR: "walletlink_sdk.general_error",
      WEB3_REQUEST: "walletlink_sdk.web3.request",
      WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
      WEB3_RESPONSE: "walletlink_sdk.web3.response",
      UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer2 = require_buffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i3 = 0; i3 < remainder; i3++) {
          block[assigned + i3] = data[offset + i3];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s3, b3, c3, d3) {
      if (s3 === 0)
        return b3 & c3 | ~b3 & d3;
      if (s3 === 2)
        return b3 & c3 | b3 & d3 | c3 & d3;
      return b3 ^ c3 ^ d3;
    }
    Sha.prototype._update = function(M2) {
      var W2 = this._w;
      var a3 = this._a | 0;
      var b3 = this._b | 0;
      var c3 = this._c | 0;
      var d3 = this._d | 0;
      var e3 = this._e | 0;
      for (var i3 = 0; i3 < 16; ++i3)
        W2[i3] = M2.readInt32BE(i3 * 4);
      for (; i3 < 80; ++i3)
        W2[i3] = W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16];
      for (var j3 = 0; j3 < 80; ++j3) {
        var s3 = ~~(j3 / 20);
        var t3 = rotl5(a3) + ft(s3, b3, c3, d3) + e3 + W2[j3] + K[s3] | 0;
        e3 = d3;
        d3 = c3;
        c3 = rotl30(b3);
        b3 = a3;
        a3 = t3;
      }
      this._a = a3 + this._a | 0;
      this._b = b3 + this._b | 0;
      this._c = c3 + this._c | 0;
      this._d = d3 + this._d | 0;
      this._e = e3 + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s3, b3, c3, d3) {
      if (s3 === 0)
        return b3 & c3 | ~b3 & d3;
      if (s3 === 2)
        return b3 & c3 | b3 & d3 | c3 & d3;
      return b3 ^ c3 ^ d3;
    }
    Sha1.prototype._update = function(M2) {
      var W2 = this._w;
      var a3 = this._a | 0;
      var b3 = this._b | 0;
      var c3 = this._c | 0;
      var d3 = this._d | 0;
      var e3 = this._e | 0;
      for (var i3 = 0; i3 < 16; ++i3)
        W2[i3] = M2.readInt32BE(i3 * 4);
      for (; i3 < 80; ++i3)
        W2[i3] = rotl1(W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16]);
      for (var j3 = 0; j3 < 80; ++j3) {
        var s3 = ~~(j3 / 20);
        var t3 = rotl5(a3) + ft(s3, b3, c3, d3) + e3 + W2[j3] + K[s3] | 0;
        e3 = d3;
        d3 = c3;
        c3 = rotl30(b3);
        b3 = a3;
        a3 = t3;
      }
      this._a = a3 + this._a | 0;
      this._b = b3 + this._b | 0;
      this._c = c3 + this._c | 0;
      this._d = d3 + this._d | 0;
      this._e = e3 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x3, y3, z3) {
      return z3 ^ x3 & (y3 ^ z3);
    }
    function maj(x3, y3, z3) {
      return x3 & y3 | z3 & (x3 | y3);
    }
    function sigma0(x3) {
      return (x3 >>> 2 | x3 << 30) ^ (x3 >>> 13 | x3 << 19) ^ (x3 >>> 22 | x3 << 10);
    }
    function sigma1(x3) {
      return (x3 >>> 6 | x3 << 26) ^ (x3 >>> 11 | x3 << 21) ^ (x3 >>> 25 | x3 << 7);
    }
    function gamma0(x3) {
      return (x3 >>> 7 | x3 << 25) ^ (x3 >>> 18 | x3 << 14) ^ x3 >>> 3;
    }
    function gamma1(x3) {
      return (x3 >>> 17 | x3 << 15) ^ (x3 >>> 19 | x3 << 13) ^ x3 >>> 10;
    }
    Sha256.prototype._update = function(M2) {
      var W2 = this._w;
      var a3 = this._a | 0;
      var b3 = this._b | 0;
      var c3 = this._c | 0;
      var d3 = this._d | 0;
      var e3 = this._e | 0;
      var f3 = this._f | 0;
      var g3 = this._g | 0;
      var h3 = this._h | 0;
      for (var i3 = 0; i3 < 16; ++i3)
        W2[i3] = M2.readInt32BE(i3 * 4);
      for (; i3 < 64; ++i3)
        W2[i3] = gamma1(W2[i3 - 2]) + W2[i3 - 7] + gamma0(W2[i3 - 15]) + W2[i3 - 16] | 0;
      for (var j3 = 0; j3 < 64; ++j3) {
        var T1 = h3 + sigma1(e3) + ch(e3, f3, g3) + K[j3] + W2[j3] | 0;
        var T22 = sigma0(a3) + maj(a3, b3, c3) | 0;
        h3 = g3;
        g3 = f3;
        f3 = e3;
        e3 = d3 + T1 | 0;
        d3 = c3;
        c3 = b3;
        b3 = a3;
        a3 = T1 + T22 | 0;
      }
      this._a = a3 + this._a | 0;
      this._b = b3 + this._b | 0;
      this._c = c3 + this._c | 0;
      this._d = d3 + this._d | 0;
      this._e = e3 + this._e | 0;
      this._f = f3 + this._f | 0;
      this._g = g3 + this._g | 0;
      this._h = h3 + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(32);
      H2.writeInt32BE(this._a, 0);
      H2.writeInt32BE(this._b, 4);
      H2.writeInt32BE(this._c, 8);
      H2.writeInt32BE(this._d, 12);
      H2.writeInt32BE(this._e, 16);
      H2.writeInt32BE(this._f, 20);
      H2.writeInt32BE(this._g, 24);
      H2.writeInt32BE(this._h, 28);
      return H2;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(28);
      H2.writeInt32BE(this._a, 0);
      H2.writeInt32BE(this._b, 4);
      H2.writeInt32BE(this._c, 8);
      H2.writeInt32BE(this._d, 12);
      H2.writeInt32BE(this._e, 16);
      H2.writeInt32BE(this._f, 20);
      H2.writeInt32BE(this._g, 24);
      return H2;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x3, y3, z3) {
      return z3 ^ x3 & (y3 ^ z3);
    }
    function maj(x3, y3, z3) {
      return x3 & y3 | z3 & (x3 | y3);
    }
    function sigma0(x3, xl) {
      return (x3 >>> 28 | xl << 4) ^ (xl >>> 2 | x3 << 30) ^ (xl >>> 7 | x3 << 25);
    }
    function sigma1(x3, xl) {
      return (x3 >>> 14 | xl << 18) ^ (x3 >>> 18 | xl << 14) ^ (xl >>> 9 | x3 << 23);
    }
    function Gamma0(x3, xl) {
      return (x3 >>> 1 | xl << 31) ^ (x3 >>> 8 | xl << 24) ^ x3 >>> 7;
    }
    function Gamma0l(x3, xl) {
      return (x3 >>> 1 | xl << 31) ^ (x3 >>> 8 | xl << 24) ^ (x3 >>> 7 | xl << 25);
    }
    function Gamma1(x3, xl) {
      return (x3 >>> 19 | xl << 13) ^ (xl >>> 29 | x3 << 3) ^ x3 >>> 6;
    }
    function Gamma1l(x3, xl) {
      return (x3 >>> 19 | xl << 13) ^ (xl >>> 29 | x3 << 3) ^ (x3 >>> 6 | xl << 26);
    }
    function getCarry(a3, b3) {
      return a3 >>> 0 < b3 >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M2) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i3 = 0; i3 < 32; i3 += 2) {
        W2[i3] = M2.readInt32BE(i3 * 4);
        W2[i3 + 1] = M2.readInt32BE(i3 * 4 + 4);
      }
      for (; i3 < 160; i3 += 2) {
        var xh = W2[i3 - 15 * 2];
        var xl = W2[i3 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i3 - 2 * 2];
        xl = W2[i3 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i3 - 7 * 2];
        var Wi7l = W2[i3 - 7 * 2 + 1];
        var Wi16h = W2[i3 - 16 * 2];
        var Wi16l = W2[i3 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i3] = Wih;
        W2[i3 + 1] = Wil;
      }
      for (var j3 = 0; j3 < 160; j3 += 2) {
        Wih = W2[j3];
        Wil = W2[j3 + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j3];
        var Kil = K[j3 + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(64);
      function writeInt64BE(h3, l3, offset) {
        H2.writeInt32BE(h3, offset);
        H2.writeInt32BE(l3, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H2;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    var inherits = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(48);
      function writeInt64BE(h3, l3, offset) {
        H2.writeInt32BE(h3, offset);
        H2.writeInt32BE(l3, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H2;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha256();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha512();
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i3 = 0; i3 < boundLength; i3++) {
        boundArgs.push("$" + i3);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e3) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e3) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x3) {
      return x3.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    try {
      null.error;
    } catch (e3) {
      errorProto = getProto(getProto(e3));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last2 = $strSlice(string, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i3 = 1, isOwn = true; i3 < parts.length; i3 += 1) {
        var part = parts[i3];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i3 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from2, noIndent) {
        if (from2) {
          seen = $arrSlice.call(seen);
          seen.push(from2);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s3 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i3 = 0; i3 < attrs.length; i3++) {
          s3 += " " + attrs[i3].name + "=" + wrapQuotes(quote(attrs[i3].value), "double", opts);
        }
        s3 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s3 += "...";
        }
        s3 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s3;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate2(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s3, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s3 + quoteChar;
    }
    function quote(s3) {
      return $replace.call(String(s3), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m3 = $match.call(functionToString.call(f3), /^function\s*([\w$]+)/);
      if (m3) {
        return m3[1];
      }
      return null;
    }
    function indexOf(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i3 = 0, l3 = xs.length; i3 < l3; i3++) {
        if (xs[i3] === x3) {
          return i3;
        }
      }
      return -1;
    }
    function isMap(x3) {
      if (!mapSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize.call(x3);
        try {
          setSize.call(x3);
        } catch (s3) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e3) {
      }
      return false;
    }
    function isWeakMap(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s3) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e3) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isSet(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize.call(x3);
        } catch (m3) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e3) {
      }
      return false;
    }
    function isWeakSet(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s3) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e3) {
      }
      return false;
    }
    function isElement(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s3 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s3, "single", opts);
    }
    function lowbyte(c3) {
      var n2 = c3.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i3 = 0; i3 < xs.length; i3++) {
        if (indexOf(xs[i3], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i3 = 0; i3 < obj.length; i3++) {
          xs[i3] = has(obj, i3) ? inspect(obj[i3], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k3 = 0; k3 < syms.length; k3++) {
          symMap["$" + syms[k3]] = syms[k3];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j3 = 0; j3 < syms.length; j3++) {
          if (isEnumerable.call(obj, syms[j3])) {
            xs.push("[" + inspect(syms[j3]) + "]: " + inspect(obj[syms[j3]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i3 = 0; i3 < 256; ++i3) {
        array.push("%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue2) {
      while (queue2.length > 1) {
        var item = queue2.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j3 = 0; j3 < obj.length; ++j3) {
            if (typeof obj[j3] !== "undefined") {
              compacted.push(obj[j3]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i3 = 0; i3 < source.length; ++i3) {
        if (typeof source[i3] !== "undefined") {
          obj[i3] = source[i3];
        }
      }
      return obj;
    };
    var merge3 = function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray2(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray2(target) && isArray2(source)) {
        source.forEach(function(item, i3) {
          if (has.call(target, i3)) {
            var targetItem = target[i3];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i3] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i3] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge4(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e3) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i3 = 0; i3 < string.length; ++i3) {
        var c3 = string.charCodeAt(i3);
        if (c3 === 45 || c3 === 46 || c3 === 95 || c3 === 126 || c3 >= 48 && c3 <= 57 || c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 122 || format === formats.RFC1738 && (c3 === 40 || c3 === 41)) {
          out += string.charAt(i3);
          continue;
        }
        if (c3 < 128) {
          out = out + hexTable[c3];
          continue;
        }
        if (c3 < 2048) {
          out = out + (hexTable[192 | c3 >> 6] + hexTable[128 | c3 & 63]);
          continue;
        }
        if (c3 < 55296 || c3 >= 57344) {
          out = out + (hexTable[224 | c3 >> 12] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63]);
          continue;
        }
        i3 += 1;
        c3 = 65536 + ((c3 & 1023) << 10 | string.charCodeAt(i3) & 1023);
        out += hexTable[240 | c3 >> 18] + hexTable[128 | c3 >> 12 & 63] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue2 = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i3 = 0; i3 < queue2.length; ++i3) {
        var item = queue2[i3];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j3 = 0; j3 < keys.length; ++j3) {
          var key = keys[j3];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue2.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue2);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a3, b3) {
      return [].concat(a3, b3);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i3 = 0; i3 < val.length; i3 += 1) {
          mapped.push(fn(val[i3]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge3
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils2();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat2(prefix) {
        return prefix;
      }
    };
    var isArray2 = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v3) {
      return typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || typeof v3 === "symbol" || typeof v3 === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i3 = 0; i3 < valuesArray.length; ++i3) {
              valuesJoined += (i3 === 0 ? "" : ",") + formatter(encoder(valuesArray[i3], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray2(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray2(filter2)) {
        objKeys = filter2;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j3 = 0; j3 < objKeys.length; ++j3) {
        var key = objKeys[j3];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter2 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray2(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i3 = 0; i3 < objKeys.length; ++i3) {
        var key = objKeys[i3];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i3;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i3 = 0; i3 < parts.length; ++i3) {
          if (parts[i3].indexOf("utf8=") === 0) {
            if (parts[i3] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i3] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i3;
            i3 = parts.length;
          }
        }
      }
      for (i3 = 0; i3 < parts.length; ++i3) {
        if (i3 === skipIndex) {
          continue;
        }
        var part = parts[i3];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i3 = chain.length - 1; i3 >= 0; --i3) {
        var obj;
        var root = chain[i3];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i3 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i3 < options.depth) {
        i3 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i3 = 0; i3 < keys.length; ++i3) {
        var key = keys[i3];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/types.js
var require_types = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderType = exports.RegExpString = exports.IntNumber = exports.BigIntString = exports.AddressString = exports.HexString = exports.OpaqueType = void 0;
    function OpaqueType() {
      return (value) => value;
    }
    exports.OpaqueType = OpaqueType;
    exports.HexString = OpaqueType();
    exports.AddressString = OpaqueType();
    exports.BigIntString = OpaqueType();
    function IntNumber(num) {
      return Math.floor(num);
    }
    exports.IntNumber = IntNumber;
    exports.RegExpString = OpaqueType();
    var ProviderType;
    (function(ProviderType2) {
      ProviderType2["CoinbaseWallet"] = "CoinbaseWallet";
      ProviderType2["MetaMask"] = "MetaMask";
      ProviderType2["Unselected"] = "";
    })(ProviderType = exports.ProviderType || (exports.ProviderType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/util.js
var require_util3 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/util.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInIFrame = exports.createQrUrl = exports.getFavicon = exports.range = exports.isBigNumber = exports.ensureParsedJSONObject = exports.ensureBN = exports.ensureRegExpString = exports.ensureIntNumber = exports.ensureBuffer = exports.ensureAddressString = exports.ensureEvenLengthHexString = exports.ensureHexString = exports.isHexString = exports.prepend0x = exports.strip0x = exports.has0xPrefix = exports.hexStringFromIntNumber = exports.intNumberFromHexString = exports.bigIntStringFromBN = exports.hexStringFromBuffer = exports.hexStringToUint8Array = exports.uint8ArrayToHex = exports.randomBytesHex = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var qs_1 = require_lib();
    var types_1 = require_types();
    var INT_STRING_REGEX = /^[0-9]*$/;
    var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    function randomBytesHex(length) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
    }
    exports.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value) {
      return [...value].map((b3) => b3.toString(16).padStart(2, "0")).join("");
    }
    exports.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
      return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    exports.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
      const hex = buf.toString("hex");
      return (0, types_1.HexString)(includePrefix ? "0x" + hex : hex);
    }
    exports.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn) {
      return (0, types_1.BigIntString)(bn.toString(10));
    }
    exports.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
      return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    exports.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
      return (0, types_1.HexString)("0x" + new bn_js_1.default(num).toString(16));
    }
    exports.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
      return str.startsWith("0x") || str.startsWith("0X");
    }
    exports.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
      if (has0xPrefix(hex)) {
        return hex.slice(2);
      }
      return hex;
    }
    exports.strip0x = strip0x;
    function prepend0x(hex) {
      if (has0xPrefix(hex)) {
        return "0x" + hex.slice(2);
      }
      return "0x" + hex;
    }
    exports.prepend0x = prepend0x;
    function isHexString(hex) {
      if (typeof hex !== "string") {
        return false;
      }
      const s3 = strip0x(hex).toLowerCase();
      return HEXADECIMAL_STRING_REGEX.test(s3);
    }
    exports.isHexString = isHexString;
    function ensureHexString(hex, includePrefix = false) {
      if (typeof hex === "string") {
        const s3 = strip0x(hex).toLowerCase();
        if (HEXADECIMAL_STRING_REGEX.test(s3)) {
          return (0, types_1.HexString)(includePrefix ? "0x" + s3 : s3);
        }
      }
      throw new Error(`"${String(hex)}" is not a hexadecimal string`);
    }
    exports.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
      let h3 = ensureHexString(hex, false);
      if (h3.length % 2 === 1) {
        h3 = (0, types_1.HexString)("0" + h3);
      }
      return includePrefix ? (0, types_1.HexString)("0x" + h3) : h3;
    }
    exports.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
      if (typeof str === "string") {
        const s3 = strip0x(str).toLowerCase();
        if (isHexString(s3) && s3.length === 40) {
          return (0, types_1.AddressString)(prepend0x(s3));
        }
      }
      throw new Error(`Invalid Ethereum address: ${String(str)}`);
    }
    exports.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
      if (Buffer.isBuffer(str)) {
        return str;
      }
      if (typeof str === "string") {
        if (isHexString(str)) {
          const s3 = ensureEvenLengthHexString(str, false);
          return Buffer.from(s3, "hex");
        } else {
          return Buffer.from(str, "utf8");
        }
      }
      throw new Error(`Not binary data: ${String(str)}`);
    }
    exports.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
      if (typeof num === "number" && Number.isInteger(num)) {
        return (0, types_1.IntNumber)(num);
      }
      if (typeof num === "string") {
        if (INT_STRING_REGEX.test(num)) {
          return (0, types_1.IntNumber)(Number(num));
        }
        if (isHexString(num)) {
          return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
        }
      }
      throw new Error(`Not an integer: ${String(num)}`);
    }
    exports.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
      if (regExp instanceof RegExp) {
        return (0, types_1.RegExpString)(regExp.toString());
      }
      throw new Error(`Not a RegExp: ${String(regExp)}`);
    }
    exports.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
      if (val !== null && (bn_js_1.default.isBN(val) || isBigNumber(val))) {
        return new bn_js_1.default(val.toString(10), 10);
      }
      if (typeof val === "number") {
        return new bn_js_1.default(ensureIntNumber(val));
      }
      if (typeof val === "string") {
        if (INT_STRING_REGEX.test(val)) {
          return new bn_js_1.default(val, 10);
        }
        if (isHexString(val)) {
          return new bn_js_1.default(ensureEvenLengthHexString(val, false), 16);
        }
      }
      throw new Error(`Not an integer: ${String(val)}`);
    }
    exports.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
      if (typeof val === "string") {
        return JSON.parse(val);
      }
      if (typeof val === "object") {
        return val;
      }
      throw new Error(`Not a JSON string or an object: ${String(val)}`);
    }
    exports.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
      if (val == null || typeof val.constructor !== "function") {
        return false;
      }
      const { constructor } = val;
      return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
    }
    exports.isBigNumber = isBigNumber;
    function range2(start, stop) {
      return Array.from({ length: stop - start }, (_3, i3) => start + i3);
    }
    exports.range = range2;
    function getFavicon() {
      const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
      const { protocol, host } = document.location;
      const href = el ? el.getAttribute("href") : null;
      if (!href || href.startsWith("javascript:")) {
        return null;
      }
      if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
        return href;
      }
      if (href.startsWith("//")) {
        return protocol + href;
      }
      return `${protocol}//${host}${href}`;
    }
    exports.getFavicon = getFavicon;
    function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version, chainId) {
      const sessionIdKey = isParentConnection ? "parent-id" : "id";
      const query = (0, qs_1.stringify)({
        [sessionIdKey]: sessionId,
        secret: sessionSecret,
        server: serverUrl,
        v: version,
        chainId
      });
      const qrUrl = `${serverUrl}/#/link?${query}`;
      return qrUrl;
    }
    exports.createQrUrl = createQrUrl;
    function isInIFrame() {
      try {
        return window.frameElement !== null;
      } catch (e3) {
        return false;
      }
    }
    exports.isInIFrame = isInIFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Session.js
var require_Session = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var sha_js_1 = require_sha2();
    var util_1 = require_util3();
    var STORAGE_KEY_SESSION_ID = "session:id";
    var STORAGE_KEY_SESSION_SECRET = "session:secret";
    var STORAGE_KEY_SESSION_LINKED = "session:linked";
    var Session = class {
      constructor(storage, id, secret, linked) {
        this._storage = storage;
        this._id = id || (0, util_1.randomBytesHex)(16);
        this._secret = secret || (0, util_1.randomBytesHex)(32);
        this._key = new sha_js_1.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex");
        this._linked = !!linked;
      }
      static load(storage) {
        const id = storage.getItem(STORAGE_KEY_SESSION_ID);
        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
        if (id && secret) {
          return new Session(storage, id, secret, linked === "1");
        }
        return null;
      }
      /**
       * Takes in a session ID and returns the sha256 hash of it.
       * @param sessionId session ID
       */
      static hash(sessionId) {
        return new sha_js_1.sha256().update(sessionId).digest("hex");
      }
      get id() {
        return this._id;
      }
      get secret() {
        return this._secret;
      }
      get key() {
        return this._key;
      }
      get linked() {
        return this._linked;
      }
      set linked(val) {
        this._linked = val;
        this.persistLinked();
      }
      save() {
        this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
        this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
        this.persistLinked();
        return this;
      }
      persistLinked() {
        this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
      }
    };
    exports.Session = Session;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js
var require_WalletSDKRelayAbstract = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelayAbstract = exports.APP_VERSION_KEY = exports.LOCAL_STORAGE_ADDRESSES_KEY = exports.WALLET_USER_NAME_KEY = void 0;
    var eth_rpc_errors_1 = require_dist();
    exports.WALLET_USER_NAME_KEY = "walletUsername";
    exports.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
    exports.APP_VERSION_KEY = "AppVersion";
    var WalletSDKRelayAbstract = class {
      async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
        if (!jsonRpcUrl)
          throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(jsonRpcUrl, {
          method: "POST",
          body: JSON.stringify(request),
          mode: "cors",
          headers: { "Content-Type": "application/json" }
        }).then((res) => res.json()).then((json) => {
          if (!json) {
            throw eth_rpc_errors_1.ethErrors.rpc.parse({});
          }
          const response = json;
          const { error } = response;
          if (error) {
            throw (0, eth_rpc_errors_1.serializeError)(error);
          }
          return response;
        });
      }
    };
    exports.WalletSDKRelayAbstract = WalletSDKRelayAbstract;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = null != arguments[i3] ? arguments[i3] : {};
        i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v3) {
        const entry = {
          data: v3,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v3) {
        const entry = {
          data: v3,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s3) {
        if (this.length === 0)
          return "";
        var p3 = this.head;
        var ret = "" + p3.data;
        while (p3 = p3.next)
          ret += s3 + p3.data;
        return ret;
      }
      concat(n2) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n2 >>> 0);
        var p3 = this.head;
        var i3 = 0;
        while (p3) {
          copyBuffer(p3.data, ret, i3);
          i3 += p3.data.length;
          p3 = p3.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n2, hasStrings) {
        var ret;
        if (n2 < this.head.data.length) {
          ret = this.head.data.slice(0, n2);
          this.head.data = this.head.data.slice(n2);
        } else if (n2 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
        }
        return ret;
      }
      first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n2) {
        var p3 = this.head;
        var c3 = 1;
        var ret = p3.data;
        n2 -= ret.length;
        while (p3 = p3.next) {
          const str = p3.data;
          const nb = n2 > str.length ? str.length : n2;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n2);
          n2 -= nb;
          if (n2 === 0) {
            if (nb === str.length) {
              ++c3;
              if (p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = str.slice(nb);
            }
            break;
          }
          ++c3;
        }
        this.length -= c3;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n2) {
        const ret = Buffer2.allocUnsafe(n2);
        var p3 = this.head;
        var c3 = 1;
        p3.data.copy(ret);
        n2 -= p3.data.length;
        while (p3 = p3.next) {
          const buf = p3.data;
          const nb = n2 > buf.length ? buf.length : n2;
          buf.copy(ret, ret.length - n2, 0, nb);
          n2 -= nb;
          if (n2 === 0) {
            if (nb === buf.length) {
              ++c3;
              if (p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = buf.slice(nb);
            }
            break;
          }
          ++c3;
        }
        this.length -= c3;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [custom](_3, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      const readableDestroyed = this._readableState && this._readableState.destroyed;
      const writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, (err2) => {
        if (!cb && err2) {
          if (!this._writableState) {
            process.nextTick(emitErrorAndCloseNT, this, err2);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, this, err2);
          } else {
            process.nextTick(emitCloseNT, this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      const rState = stream._readableState;
      const wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i3) {
          return String(i3);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          const name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config2(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_3) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      this.next = null;
      this.entry = null;
      this.finish = () => {
        onCorkedFinish(this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      const isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l3 = state.bufferedRequestCount;
        var buffer2 = new Array(l3);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final((err) => {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            const rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      const keys = objectKeys(Writable.prototype);
      for (v3 = 0; v3 < keys.length; v3++) {
        const method = keys[v3];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var v3;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r4;
      var i3;
      if (this.lastNeed) {
        r4 = this.fillLast(buf);
        if (r4 === void 0)
          return "";
        i3 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i3 = 0;
      }
      if (i3 < buf.length)
        return r4 ? r4 + this.text(buf, i3) : this.text(buf, i3);
      return r4 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i3) {
      var j3 = buf.length - 1;
      if (j3 < i3)
        return 0;
      var nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j3 < i3 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j3 < i3 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p3) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p3 = this.lastTotal - this.lastNeed;
      var r4 = utf8CheckExtraBytes(this, buf, p3);
      if (r4 !== void 0)
        return r4;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p3, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p3, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i3) {
      var total = utf8CheckIncomplete(this, buf, i3);
      if (!this.lastNeed)
        return buf.toString("utf8", i3);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i3, end);
    }
    function utf8End(buf) {
      var r4 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r4 + "";
      return r4;
    }
    function utf16Text(buf, i3) {
      if ((buf.length - i3) % 2 === 0) {
        var r4 = buf.toString("utf16le", i3);
        if (r4) {
          var c3 = r4.charCodeAt(r4.length - 1);
          if (c3 >= 55296 && c3 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r4.slice(0, -1);
          }
        }
        return r4;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i3, buf.length - 1);
    }
    function utf16End(buf) {
      var r4 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r4 + this.lastChar.toString("utf16le", 0, end);
      }
      return r4;
    }
    function base64Text(buf, i3) {
      var n2 = (buf.length - i3) % 3;
      if (n2 === 0)
        return buf.toString("base64", i3);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i3, buf.length - n2);
    }
    function base64End(buf) {
      var r4 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r4 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r4;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      let called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      let readable = opts.readable || opts.readable !== false && stream.readable;
      let writable = opts.writable || opts.writable !== false && stream.writable;
      const onlegacyfinish = () => {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      const onfinish = () => {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      const onend = () => {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      const onclose = () => {
        let err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      const resolve = iter[kLastResolve];
      if (resolve !== null) {
        const data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return (resolve, reject) => {
        lastPromise.then(() => {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({
      get stream() {
        return this[kStream];
      },
      next() {
        const error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise((resolve, reject) => {
            process.nextTick(() => {
              if (this[kError]) {
                reject(this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        const lastPromise = this[kLastPromise];
        let promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          const data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      return() {
        return new Promise((resolve, reject) => {
          this[kStream].destroy(null, (err) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }
    }, AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = (stream) => {
      const iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, {
        [kStream]: {
          value: stream,
          writable: true
        },
        [kLastResolve]: {
          value: null,
          writable: true
        },
        [kLastReject]: {
          value: null,
          writable: true
        },
        [kError]: {
          value: null,
          writable: true
        },
        [kEnded]: {
          value: stream._readableState.endEmitted,
          writable: true
        },
        // the function passed to new Promise
        // is cached so we avoid allocating a new
        // closure at every run
        [kHandlePromise]: {
          value: (resolve, reject) => {
            const data = iterator2[kStream].read();
            if (data) {
              iterator2[kLastPromise] = null;
              iterator2[kLastResolve] = null;
              iterator2[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator2[kLastResolve] = resolve;
              iterator2[kLastReject] = reject;
            }
          },
          writable: true
        }
      });
      iterator2[kLastPromise] = null;
      finished(stream, (err) => {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          const reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        const resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from2;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      let p3 = this._readableState.buffer.head;
      let content = "";
      while (p3 !== null) {
        content += decoder.write(p3.data);
        p3 = p3.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 >= MAX_HWM) {
        n2 = MAX_HWM;
      } else {
        n2--;
        n2 |= n2 >>> 1;
        n2 |= n2 >>> 2;
        n2 |= n2 >>> 4;
        n2 |= n2 >>> 8;
        n2 |= n2 >>> 16;
        n2++;
      }
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n2 !== n2) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n2 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 <= state.length)
        return n2;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n2) {
      debug("read", n2);
      n2 = parseInt(n2, 10);
      var state = this._readableState;
      var nOrig = n2;
      if (n2 !== 0)
        state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state);
      if (n2 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n2 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n2 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n2 > 0)
        ret = fromList(n2, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n2 = 0;
      } else {
        state.length -= n2;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n2 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i3 = 0; i3 < len; i3++)
          dests[i3].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      stream.on("end", () => {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            this.push(chunk);
        }
        this.push(null);
      });
      stream.on("data", (chunk) => {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i3 in stream) {
        if (this[i3] === void 0 && typeof stream[i3] === "function") {
          this[i3] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i3);
        }
      }
      for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
        stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
      }
      this._read = (n3) => {
        debug("wrapped _read", n3);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    });
    function fromList(n2, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n2, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          const wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from2 === void 0) {
          from2 = require_from_browser();
        }
        return from2(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x3) {
      for (var i3 = 0, l3 = xs.length; i3 < l3; i3++) {
        if (xs[i3] === x3)
          return i3;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush((er, data) => {
          done(this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n2) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, (err2) => {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      let called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback(...arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      let closed = false;
      stream.on("close", () => {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, (err) => {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      let destroyed = false;
      return (err) => {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from2, to) {
      return from2.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      const callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      let error;
      const destroys = streams.map(function(stream, i3) {
        const reading = i3 < streams.length - 1;
        const writing = i3 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports, module) {
    var { Transform } = require_readable_browser();
    module.exports = (KeccakState) => class Keccak extends Transform {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush(callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      update(data, encoding) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      }
      // remove result from memory
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      // because sometimes we need hash right now and little later
      _clone() {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports, module) {
    var { Transform } = require_readable_browser();
    module.exports = (KeccakState) => class Shake extends Transform {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush() {
      }
      _read(size) {
        this.push(this.squeeze(size));
      }
      update(data, encoding) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports, module) {
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s3) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
        const hi0 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
        const lo1 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
        const hi1 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
        const lo2 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
        const hi2 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
        const lo3 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
        const hi3 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
        const lo4 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
        const hi4 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s3[0] ^ lo;
        const t1shi0 = s3[1] ^ hi;
        const t1slo5 = s3[10] ^ lo;
        const t1shi5 = s3[11] ^ hi;
        const t1slo10 = s3[20] ^ lo;
        const t1shi10 = s3[21] ^ hi;
        const t1slo15 = s3[30] ^ lo;
        const t1shi15 = s3[31] ^ hi;
        const t1slo20 = s3[40] ^ lo;
        const t1shi20 = s3[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s3[2] ^ lo;
        const t1shi1 = s3[3] ^ hi;
        const t1slo6 = s3[12] ^ lo;
        const t1shi6 = s3[13] ^ hi;
        const t1slo11 = s3[22] ^ lo;
        const t1shi11 = s3[23] ^ hi;
        const t1slo16 = s3[32] ^ lo;
        const t1shi16 = s3[33] ^ hi;
        const t1slo21 = s3[42] ^ lo;
        const t1shi21 = s3[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s3[4] ^ lo;
        const t1shi2 = s3[5] ^ hi;
        const t1slo7 = s3[14] ^ lo;
        const t1shi7 = s3[15] ^ hi;
        const t1slo12 = s3[24] ^ lo;
        const t1shi12 = s3[25] ^ hi;
        const t1slo17 = s3[34] ^ lo;
        const t1shi17 = s3[35] ^ hi;
        const t1slo22 = s3[44] ^ lo;
        const t1shi22 = s3[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s3[6] ^ lo;
        const t1shi3 = s3[7] ^ hi;
        const t1slo8 = s3[16] ^ lo;
        const t1shi8 = s3[17] ^ hi;
        const t1slo13 = s3[26] ^ lo;
        const t1shi13 = s3[27] ^ hi;
        const t1slo18 = s3[36] ^ lo;
        const t1shi18 = s3[37] ^ hi;
        const t1slo23 = s3[46] ^ lo;
        const t1shi23 = s3[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s3[8] ^ lo;
        const t1shi4 = s3[9] ^ hi;
        const t1slo9 = s3[18] ^ lo;
        const t1shi9 = s3[19] ^ hi;
        const t1slo14 = s3[28] ^ lo;
        const t1shi14 = s3[29] ^ hi;
        const t1slo19 = s3[38] ^ lo;
        const t1shi19 = s3[39] ^ hi;
        const t1slo24 = s3[48] ^ lo;
        const t1shi24 = s3[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s3[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s3[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s3[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s3[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s3[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s3[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s3[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s3[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s3[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s3[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s3[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s3[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s3[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s3[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s3[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s3[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s3[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s3[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s3[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s3[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s3[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s3[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s3[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s3[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s3[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s3[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s3[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s3[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s3[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s3[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s3[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s3[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s3[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s3[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s3[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s3[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s3[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s3[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s3[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s3[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s3[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s3[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s3[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s3[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s3[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s3[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s3[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s3[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s3[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s3[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s3[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s3[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports, module) {
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i3 = 0; i3 < 50; ++i3)
        this.state[i3] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i3 = 0; i3 < data.length; ++i3) {
        this.state[~~(this.count / 4)] ^= data[i3] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer.alloc(length);
      for (let i3 = 0; i3 < length; ++i3) {
        output[i3] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i3 = 0; i3 < 50; ++i3)
        dest.state[i3] = this.state[i3];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/keccak/js.js"(exports, module) {
    module.exports = require_api()(require_keccak2());
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js
var require_util4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js"(exports, module) {
    var createKeccakHash = require_js();
    var BN = require_bn();
    function zeros(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    }
    function setLength(msg, length, right) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v3) {
      if (!Buffer.isBuffer(v3)) {
        if (Array.isArray(v3)) {
          v3 = Buffer.from(v3);
        } else if (typeof v3 === "string") {
          if (isHexString(v3)) {
            v3 = Buffer.from(padToEven(stripHexPrefix(v3)), "hex");
          } else {
            v3 = Buffer.from(v3);
          }
        } else if (typeof v3 === "number") {
          v3 = intToBuffer(v3);
        } else if (v3 === null || v3 === void 0) {
          v3 = Buffer.allocUnsafe(0);
        } else if (BN.isBN(v3)) {
          v3 = v3.toArrayLike(Buffer);
        } else if (v3.toArray) {
          v3 = Buffer.from(v3.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v3;
    }
    function bufferToHex(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a3, bits) {
      a3 = toBuffer(a3);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a3).digest();
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros,
      setLength,
      setLengthRight,
      isHexString,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js"(exports, module) {
    var util = require_util4();
    var BN = require_bn();
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (util.isHexString(arg)) {
          return new BN(util.stripHexPrefix(arg), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type, arg) {
      var size, num, ret, i3;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray2(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i3 in arg) {
          ret.push(encodeSingle(type, arg[i3]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return util.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray2(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i3 in types) {
        var type = elementaryName(types[i3]);
        var value = values[i3];
        var cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size, num;
      var ret = [];
      for (var i3 = 0; i3 < types.length; i3++) {
        var type = elementaryName(types[i3]);
        var value = values[i3];
        if (type === "bytes") {
          ret.push(value);
        } else if (type === "string") {
          ret.push(new Buffer(value, "utf8"));
        } else if (type === "bool") {
          ret.push(new Buffer(value ? "01" : "00", "hex"));
        } else if (type === "address") {
          ret.push(util.setLength(value, 20));
        } else if (type.startsWith("bytes")) {
          size = parseTypeN(type);
          if (size < 1 || size > 32) {
            throw new Error("Invalid bytes<N> width: " + size);
          }
          ret.push(util.setLengthRight(value, size));
        } else if (type.startsWith("uint")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid uint<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toArrayLike(Buffer, "be", size / 8));
        } else if (type.startsWith("int")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid int<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toTwos(size).toArrayLike(Buffer, "be", size / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js"(exports, module) {
    var util = require_util4();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      /**
       * Encodes an object by encoding and concatenating each of its members
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of an object
       */
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name, type, value) => {
            if (types[type] !== void 0) {
              return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type, value, types, useV4))];
            }
            if (value === void 0)
              throw new Error(`missing value for field ${name} of type ${type}`);
            if (type === "bytes") {
              return ["bytes32", util.keccak(value)];
            }
            if (type === "string") {
              if (typeof value === "string") {
                value = Buffer.from(value, "utf8");
              }
              return ["bytes32", util.keccak(value)];
            }
            if (type.lastIndexOf("]") === type.length - 1) {
              const parsedType = type.slice(0, type.lastIndexOf("["));
              const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(
                typeValuePairs.map(([type2]) => type2),
                typeValuePairs.map(([, value2]) => value2)
              ))];
            }
            return [type, value];
          };
          for (const field of types[primaryType]) {
            const [type, value] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data[field.name];
            if (value !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value === "string") {
                  value = Buffer.from(value, "utf8");
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      /**
       * Encodes the type of an object by encoding a comma delimited list of its members
       *
       * @param {string} primaryType - Root type to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of the type of an object
       */
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
          const children = types[type];
          if (!children) {
            throw new Error("No type definition specified: " + type);
          }
          result += type + "(" + types[type].map(({ name, type: type2 }) => type2 + " " + name).join(",") + ")";
        }
        return result;
      },
      /**
       * Finds all types within a type defintion object
       *
       * @param {string} primaryType - Root type
       * @param {Object} types - Type definitions
       * @param {Array} results - current set of accumulated types
       * @returns {Array} - Set of all types found in the type definition
       */
      findTypeDependencies(primaryType, types, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types[primaryType] === void 0) {
          return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results;
      },
      /**
       * Hashes an object
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to hash
       * @param {Object} types - Type definitions
       * @returns {Buffer} - Hash of an object
       */
      hashStruct(primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      /**
       * Hashes the type of an object
       *
       * @param {string} primaryType - Root type to hash
       * @param {Object} types - Type definitions
       * @returns {string} - Hash of an object
       */
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      /**
       * Removes properties from a message object that are not defined per EIP-712
       *
       * @param {Object} data - typed message object
       * @returns {Object} - typed message object with only allowed fields
       */
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      /**
       * Returns the hash of a typed message as per EIP-712 for signing
       *
       * @param {Object} typedData - Types message data to sign
       * @returns {string} - sha3 hash for signing
       */
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer.concat(parts));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data = typedData.map(function(e3) {
        return e3.type === "bytes" ? util.toBuffer(e3.value) : e3.value;
      });
      const types = typedData.map(function(e3) {
        return e3.type;
      });
      const schema = typedData.map(function(e3) {
        if (!e3.name)
          throw error;
        return e3.type + " " + e3.name;
      });
      return abi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi.soliditySHA3(types, data)
        ]
      );
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js
var require_FilterPolyfill = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterFromParam = exports.FilterPolyfill = void 0;
    var types_1 = require_types();
    var util_1 = require_util3();
    var TIMEOUT = 5 * 60 * 1e3;
    var JSONRPC_TEMPLATE = {
      jsonrpc: "2.0",
      id: 0
    };
    var FilterPolyfill = class {
      constructor(provider) {
        this.logFilters = /* @__PURE__ */ new Map();
        this.blockFilters = /* @__PURE__ */ new Set();
        this.pendingTransactionFilters = /* @__PURE__ */ new Set();
        this.cursors = /* @__PURE__ */ new Map();
        this.timeouts = /* @__PURE__ */ new Map();
        this.nextFilterId = (0, types_1.IntNumber)(1);
        this.provider = provider;
      }
      async newFilter(param) {
        const filter2 = filterFromParam(param);
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, filter2.fromBlock);
        console.log(`Installing new log filter(${id}):`, filter2, "initial cursor position:", cursor);
        this.logFilters.set(id, filter2);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      async newBlockFilter() {
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, "latest");
        console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);
        this.blockFilters.add(id);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      async newPendingTransactionFilter() {
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, "latest");
        console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);
        this.pendingTransactionFilters.add(id);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      uninstallFilter(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        console.log(`Uninstalling filter (${id})`);
        this.deleteFilter(id);
        return true;
      }
      getFilterChanges(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        if (this.timeouts.has(id)) {
          this.setFilterTimeout(id);
        }
        if (this.logFilters.has(id)) {
          return this.getLogFilterChanges(id);
        } else if (this.blockFilters.has(id)) {
          return this.getBlockFilterChanges(id);
        } else if (this.pendingTransactionFilters.has(id)) {
          return this.getPendingTransactionFilterChanges(id);
        }
        return Promise.resolve(filterNotFoundError());
      }
      async getFilterLogs(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        const filter2 = this.logFilters.get(id);
        if (!filter2) {
          return filterNotFoundError();
        }
        return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
      }
      makeFilterId() {
        return (0, types_1.IntNumber)(++this.nextFilterId);
      }
      sendAsyncPromise(request) {
        return new Promise((resolve, reject) => {
          this.provider.sendAsync(request, (err, response) => {
            if (err) {
              return reject(err);
            }
            if (Array.isArray(response) || response == null) {
              return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
            }
            resolve(response);
          });
        });
      }
      deleteFilter(id) {
        console.log(`Deleting filter (${id})`);
        this.logFilters.delete(id);
        this.blockFilters.delete(id);
        this.pendingTransactionFilters.delete(id);
        this.cursors.delete(id);
        this.timeouts.delete(id);
      }
      async getLogFilterChanges(id) {
        const filter2 = this.logFilters.get(id);
        const cursorPosition = this.cursors.get(id);
        if (!cursorPosition || !filter2) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        if (cursorPosition > filter2.toBlock) {
          return emptyResult();
        }
        console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id}`);
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
          paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
        ] }));
        if (Array.isArray(response.result)) {
          const blocks = response.result.map((log) => (0, util_1.intNumberFromHexString)(log.blockNumber || "0x0"));
          const highestBlock = Math.max(...blocks);
          if (highestBlock && highestBlock > cursorPosition) {
            const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);
            console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id, newCursorPosition);
          }
        }
        return response;
      }
      async getBlockFilterChanges(id) {
        const cursorPosition = this.cursors.get(id);
        if (!cursorPosition) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id})`);
        const blocks = (await Promise.all(
          // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
          (0, util_1.range)(cursorPosition, currentBlockHeight + 1).map((i3) => this.getBlockHashByNumber((0, types_1.IntNumber)(i3)))
        )).filter((hash) => !!hash);
        const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks.length);
        console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id, newCursorPosition);
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
      }
      async getPendingTransactionFilterChanges(_id) {
        return Promise.resolve(emptyResult());
      }
      async setInitialCursorPosition(id, startBlock) {
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
        this.cursors.set(id, initialCursorPosition);
        return initialCursorPosition;
      }
      setFilterTimeout(id) {
        const existing = this.timeouts.get(id);
        if (existing) {
          window.clearTimeout(existing);
        }
        const timeout2 = window.setTimeout(() => {
          console.log(`Filter (${id}) timed out`);
          this.deleteFilter(id);
        }, TIMEOUT);
        this.timeouts.set(id, timeout2);
      }
      async getCurrentBlockHeight() {
        const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
        return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));
      }
      async getBlockHashByNumber(blockNumber) {
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false] }));
        if (response.result && typeof response.result.hash === "string") {
          return (0, util_1.ensureHexString)(response.result.hash);
        }
        return null;
      }
    };
    exports.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
        addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
        topics: param.topics || []
      };
    }
    exports.filterFromParam = filterFromParam;
    function paramFromFilter(filter2) {
      const param = {
        fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
        topics: filter2.topics
      };
      if (filter2.addresses !== null) {
        param.address = filter2.addresses;
      }
      return param;
    }
    function intBlockHeightFromHexBlockHeight(value) {
      if (value === void 0 || value === "latest" || value === "pending") {
        return "latest";
      } else if (value === "earliest") {
        return (0, types_1.IntNumber)(0);
      } else if ((0, util_1.isHexString)(value)) {
        return (0, util_1.intNumberFromHexString)(value);
      }
      throw new Error(`Invalid block option: ${String(value)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value) {
      if (value === "latest") {
        return value;
      }
      return (0, util_1.hexStringFromIntNumber)(value);
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js
var require_JSONRPC = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["eth_accounts"] = "eth_accounts";
      JSONRPCMethod2["eth_coinbase"] = "eth_coinbase";
      JSONRPCMethod2["net_version"] = "net_version";
      JSONRPCMethod2["eth_chainId"] = "eth_chainId";
      JSONRPCMethod2["eth_uninstallFilter"] = "eth_uninstallFilter";
      JSONRPCMethod2["eth_requestAccounts"] = "eth_requestAccounts";
      JSONRPCMethod2["eth_sign"] = "eth_sign";
      JSONRPCMethod2["eth_ecRecover"] = "eth_ecRecover";
      JSONRPCMethod2["personal_sign"] = "personal_sign";
      JSONRPCMethod2["personal_ecRecover"] = "personal_ecRecover";
      JSONRPCMethod2["eth_signTransaction"] = "eth_signTransaction";
      JSONRPCMethod2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      JSONRPCMethod2["eth_sendTransaction"] = "eth_sendTransaction";
      JSONRPCMethod2["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      JSONRPCMethod2["eth_signTypedData_v2"] = "eth_signTypedData_v2";
      JSONRPCMethod2["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      JSONRPCMethod2["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      JSONRPCMethod2["eth_signTypedData"] = "eth_signTypedData";
      JSONRPCMethod2["cbWallet_arbitrary"] = "walletlink_arbitrary";
      JSONRPCMethod2["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      JSONRPCMethod2["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      JSONRPCMethod2["wallet_watchAsset"] = "wallet_watchAsset";
      JSONRPCMethod2["eth_subscribe"] = "eth_subscribe";
      JSONRPCMethod2["eth_unsubscribe"] = "eth_unsubscribe";
      JSONRPCMethod2["eth_newFilter"] = "eth_newFilter";
      JSONRPCMethod2["eth_newBlockFilter"] = "eth_newBlockFilter";
      JSONRPCMethod2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      JSONRPCMethod2["eth_getFilterChanges"] = "eth_getFilterChanges";
      JSONRPCMethod2["eth_getFilterLogs"] = "eth_getFilterLogs";
    })(JSONRPCMethod = exports.JSONRPCMethod || (exports.JSONRPCMethod = {}));
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, opts) => function() {
      const P3 = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i3 = 0; i3 < arguments.length; i3++) {
        args[i3] = arguments[i3];
      }
      return new P3((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i3 = 1; i3 < arguments.length; i3++) {
                results[i3 - 1] = arguments[i3];
              }
              if (err) {
                results.unshift(err);
                reject(results);
              } else {
                resolve(results);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i3 = 0; i3 < arguments.length; i3++) {
                results[i3] = arguments[i3];
              }
              resolve(results);
            } else {
              resolve(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter2 = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x3 = obj[key];
        ret[key] = typeof x3 === "function" && filter2(key) ? processFn(x3, opts) : x3;
      }
      return ret;
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i3 = 0; i3 < arguments.length; i3++) {
        var source = arguments[i3];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports, module) {
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max2 = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
      return function createRandomId() {
        idCounter = idCounter % max2;
        return idCounter++;
      };
    }
  }
});

// node_modules/eth-query/index.js
var require_eth_query = __commonJS({
  "node_modules/eth-query/index.js"(exports, module) {
    var extend = require_immutable();
    var createRandomId = require_json_rpc_random_id()();
    module.exports = EthQuery;
    function EthQuery(provider) {
      const self2 = this;
      self2.currentProvider = provider;
    }
    EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
    EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
    EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
    EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
    EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
    EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
    EthQuery.prototype.syncing = generateFnFor("eth_syncing");
    EthQuery.prototype.coinbase = generateFnFor("eth_coinbase");
    EthQuery.prototype.mining = generateFnFor("eth_mining");
    EthQuery.prototype.hashrate = generateFnFor("eth_hashrate");
    EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice");
    EthQuery.prototype.accounts = generateFnFor("eth_accounts");
    EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber");
    EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
    EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
    EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
    EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
    EthQuery.prototype.sign = generateFnFor("eth_sign");
    EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
    EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
    EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas");
    EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
    EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
    EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
    EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
    EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
    EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
    EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
    EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
    EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers");
    EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL");
    EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
    EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
    EthQuery.prototype.newFilter = generateFnFor("eth_newFilter");
    EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
    EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
    EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
    EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
    EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
    EthQuery.prototype.getLogs = generateFnFor("eth_getLogs");
    EthQuery.prototype.getWork = generateFnFor("eth_getWork");
    EthQuery.prototype.submitWork = generateFnFor("eth_submitWork");
    EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
    EthQuery.prototype.sendAsync = function(opts, cb) {
      const self2 = this;
      self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
        if (!err && response.error)
          err = new Error("EthQuery - RPC Error - " + response.error.message);
        if (err)
          return cb(err);
        cb(null, response.result);
      });
    };
    function generateFnFor(methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function generateFnWithDefaultBlockFor(argCount, methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        if (args.length < argCount)
          args.push("latest");
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function createPayload(data) {
      return extend({
        // defaults
        id: createRandomId(),
        jsonrpc: "2.0",
        params: []
        // user-specified
      }, data);
    }
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e3) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_3) {
        if (_3 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e3) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e3) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e3) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e3) {
        if (e3 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator2, receiver) {
      for (var i3 = 0, len = array.length; i3 < len; i3++) {
        if (hasOwnProperty.call(array, i3)) {
          if (receiver == null) {
            iterator2(array[i3], i3, array);
          } else {
            iterator2.call(receiver, array[i3], i3, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator2, receiver) {
      for (var i3 = 0, len = string.length; i3 < len; i3++) {
        if (receiver == null) {
          iterator2(string.charAt(i3), i3, string);
        } else {
          iterator2.call(receiver, string.charAt(i3), i3, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator2, receiver) {
      for (var k3 in object) {
        if (hasOwnProperty.call(object, k3)) {
          if (receiver == null) {
            iterator2(object[k3], k3, object);
          } else {
            iterator2.call(receiver, object[k3], k3, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator2, thisArg) {
      if (!isCallable(iterator2)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator2, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator2, receiver);
      } else {
        forEachObject(list, iterator2, receiver);
      }
    };
    module.exports = forEach;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g3 = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i3 = 0; i3 < possibleNames.length; i3++) {
        if (typeof g3[possibleNames[i3]] === "function") {
          out[out.length] = possibleNames[i3];
        }
      }
      return out;
    };
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e3) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var gOPD = require_gopd();
    var g3 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i3 = 0; i3 < array.length; i3 += 1) {
        if (array[i3] === value) {
          return i3;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g3[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e3) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g3 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g3[typedArray] === "function") {
          var arr = new g3[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name = getter.call(value);
            if (name === typedArray) {
              foundName = name;
            }
          } catch (e3) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types2 = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f3) {
      return f3.call.bind(f3);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e3) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise2(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise2;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util5 = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i3 = 0; i3 < keys.length; i3++) {
        descriptors[keys[i3]] = Object.getOwnPropertyDescriptor(obj, keys[i3]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f3) {
      if (!isString(f3)) {
        var objects = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          objects.push(inspect(arguments[i3]));
        }
        return objects.join(" ");
      }
      var i3 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f3).replace(formatRegExp, function(x4) {
        if (x4 === "%%")
          return "%";
        if (i3 >= len)
          return x4;
        switch (x4) {
          case "%s":
            return String(args[i3++]);
          case "%d":
            return Number(args[i3++]);
          case "%j":
            try {
              return JSON.stringify(args[i3++]);
            } catch (_3) {
              return "[Circular]";
            }
          default:
            return x4;
        }
      });
      for (var x3 = args[i3]; i3 < len; x3 = args[++i3]) {
        if (isNull(x3) || !isObject2(x3)) {
          str += " " + x3;
        } else {
          str += " " + inspect(x3);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction2(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate2(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n2 = value.name ? ": " + value.name : "";
        base = " [Function" + n2 + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate2(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i3 = 0, l3 = value.length; i3 < l3; ++i3) {
        if (hasOwnProperty(value, String(i3))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i3),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types2();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject2;
    function isDate2(d3) {
      return isObject2(d3) && objectToString(d3) === "[object Date]";
    }
    exports.isDate = isDate2;
    exports.types.isDate = isDate2;
    function isError(e3) {
      return isObject2(e3) && (objectToString(e3) === "[object Error]" || e3 instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o3) {
      return Object.prototype.toString.call(o3);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp2() {
      var d3 = new Date();
      var time = [
        pad(d3.getHours()),
        pad(d3.getMinutes()),
        pad(d3.getSeconds())
      ].join(":");
      return [d3.getDate(), months[d3.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp2(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject2(add))
        return origin;
      var keys = Object.keys(add);
      var i3 = keys.length;
      while (i3--) {
        origin[keys[i3]] = add[keys[i3]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          args.push(arguments[i3]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          args.push(arguments[i3]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/safe-event-emitter/index.js
var require_safe_event_emitter2 = __commonJS({
  "node_modules/safe-event-emitter/index.js"(exports, module) {
    var util = require_util5();
    var EventEmitter = require_events();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    module.exports = SafeEventEmitter;
    function SafeEventEmitter() {
      EventEmitter.call(this);
    }
    util.inherits(SafeEventEmitter, EventEmitter);
    SafeEventEmitter.prototype.emit = function(type) {
      var args = [];
      for (var i3 = 1; i3 < arguments.length; i3++)
        args.push(arguments[i3]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i3 = 0; i3 < len; ++i3)
          safeApply(listeners[i3], this, args);
      }
      return true;
    };
    function safeApply(handler, context, args) {
      try {
        ReflectApply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i3 = 0; i3 < n2; ++i3)
        copy[i3] = arr[i3];
      return copy;
    }
  }
});

// node_modules/eth-block-tracker/src/base.js
var require_base = __commonJS({
  "node_modules/eth-block-tracker/src/base.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter2();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      //
      // public
      //
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      // dont allow module consumer to remove our internal event listeners
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      //
      // to be implemented in subclass
      //
      _start() {
      }
      _end() {
      }
      //
      // private
      //
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/eth-block-tracker/src/polling.js"(exports, module) {
    var pify = require_pify();
    var BaseBlockTracker = require_base();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      //
      // public
      //
      // trigger block polling
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      //
      // private
      //
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout2(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout2(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module.exports = PollingBlockTracker;
    function timeout2(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/json-rpc-engine/dist/getUniqueId.js
var require_getUniqueId = __commonJS({
  "node_modules/json-rpc-engine/dist/getUniqueId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUniqueId = void 0;
    var MAX = 4294967295;
    var idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
    }
    exports.getUniqueId = getUniqueId;
  }
});

// node_modules/json-rpc-engine/dist/idRemapMiddleware.js
var require_idRemapMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/idRemapMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIdRemapMiddleware = void 0;
    var getUniqueId_1 = require_getUniqueId();
    function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
          req.id = originalId;
          res.id = originalId;
          done();
        });
      };
    }
    exports.createIdRemapMiddleware = createIdRemapMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/createAsyncMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAsyncMiddleware = void 0;
    function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((runReturnHandlersCallback) => {
            returnHandlerCallback = runReturnHandlersCallback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        try {
          await asyncMiddleware(req, res, asyncNext);
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        } catch (error) {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        }
      };
    }
    exports.createAsyncMiddleware = createAsyncMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    }
    exports.createScaffoldMiddleware = createScaffoldMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/JsonRpcEngine.js
var require_JsonRpcEngine = __commonJS({
  "node_modules/json-rpc-engine/dist/JsonRpcEngine.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcEngine = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter());
    var eth_rpc_errors_1 = require_dist();
    var JsonRpcEngine = class extends safe_event_emitter_1.default {
      constructor() {
        super();
        this._middleware = [];
      }
      /**
       * Add a middleware function to the engine's middleware stack.
       *
       * @param middleware - The middleware function to add.
       */
      push(middleware) {
        this._middleware.push(middleware);
      }
      handle(req, cb) {
        if (cb && typeof cb !== "function") {
          throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
          if (cb) {
            return this._handleBatch(req, cb);
          }
          return this._handleBatch(req);
        }
        if (cb) {
          return this._handle(req, cb);
        }
        return this._promiseHandle(req);
      }
      /**
       * Returns this engine as a middleware function that can be pushed to other
       * engines.
       *
       * @returns This engine as a middleware function.
       */
      asMiddleware() {
        return async (req, res, next, end) => {
          try {
            const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            if (isComplete) {
              await JsonRpcEngine._runReturnHandlers(returnHandlers);
              return end(middlewareError);
            }
            return next(async (handlerCallback) => {
              try {
                await JsonRpcEngine._runReturnHandlers(returnHandlers);
              } catch (error) {
                return handlerCallback(error);
              }
              return handlerCallback();
            });
          } catch (error) {
            return end(error);
          }
        };
      }
      async _handleBatch(reqs, cb) {
        try {
          const responses = await Promise.all(
            // 1. Begin executing each request in the order received
            reqs.map(this._promiseHandle.bind(this))
          );
          if (cb) {
            return cb(null, responses);
          }
          return responses;
        } catch (error) {
          if (cb) {
            return cb(error);
          }
          throw error;
        }
      }
      /**
       * A promise-wrapped _handle.
       */
      _promiseHandle(req) {
        return new Promise((resolve) => {
          this._handle(req, (_err, res) => {
            resolve(res);
          });
        });
      }
      /**
       * Ensures that the request object is valid, processes it, and passes any
       * error and the response object to the given callback.
       *
       * Does not reject.
       */
      async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
          return cb(error2, { id: void 0, jsonrpc: "2.0", error: error2 });
        }
        if (typeof callerReq.method !== "string") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
          return cb(error2, { id: callerReq.id, jsonrpc: "2.0", error: error2 });
        }
        const req = Object.assign({}, callerReq);
        const res = {
          id: req.id,
          jsonrpc: req.jsonrpc
        };
        let error = null;
        try {
          await this._processRequest(req, res);
        } catch (_error) {
          error = _error;
        }
        if (error) {
          delete res.result;
          if (!res.error) {
            res.error = eth_rpc_errors_1.serializeError(error);
          }
        }
        return cb(error, res);
      }
      /**
       * For the given request and response, runs all middleware and their return
       * handlers, if any, and ensures that internal request processing semantics
       * are satisfied.
       */
      async _processRequest(req, res) {
        const [error, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        if (error) {
          throw error;
        }
      }
      /**
       * Serially executes the given stack of middleware.
       *
       * @returns An array of any error encountered during middleware execution,
       * a boolean indicating whether the request was completed, and an array of
       * middleware-defined return handlers.
       */
      static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        for (const middleware of middlewareStack) {
          [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
          if (isComplete) {
            break;
          }
        }
        return [error, isComplete, returnHandlers.reverse()];
      }
      /**
       * Runs an individual middleware.
       *
       * @returns An array of any error encountered during middleware exection,
       * and a boolean indicating whether the request should end.
       */
      static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
          const end = (err) => {
            const error = err || res.error;
            if (error) {
              res.error = eth_rpc_errors_1.serializeError(error);
            }
            resolve([error, true]);
          };
          const next = (returnHandler) => {
            if (res.error) {
              end(res.error);
            } else {
              if (returnHandler) {
                if (typeof returnHandler !== "function") {
                  end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
                }
                returnHandlers.push(returnHandler);
              }
              resolve([null, false]);
            }
          };
          try {
            middleware(req, res, next, end);
          } catch (error) {
            end(error);
          }
        });
      }
      /**
       * Serially executes array of return handlers. The request and response are
       * assumed to be in their scope.
       */
      static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
          await new Promise((resolve, reject) => {
            handler((err) => err ? reject(err) : resolve());
          });
        }
      }
      /**
       * Throws an error if the response has neither a result nor an error, or if
       * the "isComplete" flag is falsy.
       */
      static _checkForCompletion(req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
        }
      }
    };
    exports.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request) {
      return JSON.stringify(request, null, 2);
    }
  }
});

// node_modules/json-rpc-engine/dist/mergeMiddleware.js
var require_mergeMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/mergeMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMiddleware = void 0;
    var JsonRpcEngine_1 = require_JsonRpcEngine();
    function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
    }
    exports.mergeMiddleware = mergeMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/json-rpc-engine/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m3, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_idRemapMiddleware(), exports);
    __exportStar(require_createAsyncMiddleware(), exports);
    __exportStar(require_createScaffoldMiddleware(), exports);
    __exportStar(require_getUniqueId(), exports);
    __exportStar(require_JsonRpcEngine(), exports);
    __exportStar(require_mergeMiddleware(), exports);
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    var __extends2;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v3) {
          return exports2[id] = previous ? previous(id, v3) : v3;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p3 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p3))
            d3[p3] = b3[p3];
      };
      __extends2 = function(d3, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics2(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p3 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p3))
              t3[p3] = s3[p3];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
            t3[p3] = s3[p3];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
            if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
              t3[p3[i3]] = s3[p3[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r4 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r4 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d3 = decorators[i3])
              r4 = (c3 < 3 ? d3(r4) : c3 > 3 ? d3(target, key, r4) : d3(target, key)) || r4;
        return c3 > 3 && r4 && Object.defineProperty(target, key, r4), r4;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f3) {
          if (f3 !== void 0 && typeof f3 !== "function")
            throw new TypeError("Function expected");
          return f3;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _3, done = false;
        for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
          var context = {};
          for (var p3 in contextIn)
            context[p3] = p3 === "access" ? {} : contextIn[p3];
          for (var p3 in contextIn.access)
            context.access[p3] = contextIn.access[p3];
          context.addInitializer = function(f3) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f3 || null));
          };
          var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_3 = accept(result.get))
              descriptor.get = _3;
            if (_3 = accept(result.set))
              descriptor.set = _3;
            if (_3 = accept(result.init))
              initializers.push(_3);
          } else if (_3 = accept(result)) {
            if (kind === "field")
              initializers.push(_3);
            else
              descriptor[key] = _3;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i3 = 0; i3 < initializers.length; i3++) {
          value = useValue ? initializers[i3].call(thisArg, value) : initializers[i3].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey = function(x3) {
        return typeof x3 === "symbol" ? x3 : "".concat(x3);
      };
      __setFunctionName = function(f3, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f3, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _3 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y3, t3, g3;
        return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
          return this;
        }), g3;
        function verb(n2) {
          return function(v3) {
            return step([n2, v3]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (g3 && (g3 = 0, op[0] && (_3 = 0)), _3)
            try {
              if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _3.label++;
                  return { value: op[1], done: false };
                case 5:
                  _3.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _3.ops.pop();
                  _3.trys.pop();
                  continue;
                default:
                  if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _3 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _3.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _3.label < t3[1]) {
                    _3.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _3.label < t3[2]) {
                    _3.label = t3[2];
                    _3.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _3.ops.pop();
                  _3.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _3);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m3, o3) {
        for (var p3 in m3)
          if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p3))
            __createBinding(o3, m3, p3);
      };
      __createBinding = Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m3[k3];
      };
      __values = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o3[s3], i3 = 0;
        if (m3)
          return m3.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m3)
          return o3;
        var i3 = m3.call(o3), r4, ar = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r4 = i3.next()).done)
            ar.push(r4.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r4 && !r4.done && (m3 = i3["return"]))
              m3.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
          ar = ar.concat(__read(arguments[i3]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r4 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
            r4[k3] = a3[j3];
        return r4;
      };
      __spreadArray = function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i3 = 0, l3 = from2.length, ar; i3 < l3; i3++) {
            if (ar || !(i3 in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i3);
              ar[i3] = from2[i3];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      __await = function(v3) {
        return this instanceof __await ? (this.v = v3, this) : new __await(v3);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g3 = generator.apply(thisArg, _arguments || []), i3, q3 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g3[n2])
            i3[n2] = function(v3) {
              return new Promise(function(a3, b3) {
                q3.push([n2, v3, a3, b3]) > 1 || resume(n2, v3);
              });
            };
        }
        function resume(n2, v3) {
          try {
            step(g3[n2](v3));
          } catch (e3) {
            settle(q3[0][3], e3);
          }
        }
        function step(r4) {
          r4.value instanceof __await ? Promise.resolve(r4.value.v).then(fulfill, reject) : settle(q3[0][2], r4);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v3) {
          if (f3(v3), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p3;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v3) {
            return (p3 = !p3) ? { value: __await(o3[n2](v3)), done: false } : f3 ? f3(v3) : v3;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o3[Symbol.asyncIterator], i3;
        return m3 ? m3.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v3) {
            return new Promise(function(resolve, reject) {
              v3 = o3[n2](v3), settle(resolve, reject, v3.done, v3.value);
            });
          };
        }
        function settle(resolve, reject, d3, v3) {
          Promise.resolve(v3).then(function(v4) {
            resolve({ value: v4, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f3) {
        if (kind === "a" && !f3)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f3) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f3)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore = (
      /** @class */
      function() {
        function Semaphore2(_maxConcurrency) {
          this._maxConcurrency = _maxConcurrency;
          this._queue = [];
          if (_maxConcurrency <= 0) {
            throw new Error("semaphore must be initialized to a positive value");
          }
          this._value = _maxConcurrency;
        }
        Semaphore2.prototype.acquire = function() {
          var _this = this;
          var locked = this.isLocked();
          var ticket = new Promise(function(r4) {
            return _this._queue.push(r4);
          });
          if (!locked)
            this._dispatch();
          return ticket;
        };
        Semaphore2.prototype.runExclusive = function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, value, release;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.acquire()];
                case 1:
                  _a = _b.sent(), value = _a[0], release = _a[1];
                  _b.label = 2;
                case 2:
                  _b.trys.push([2, , 4, 5]);
                  return [4, callback(value)];
                case 3:
                  return [2, _b.sent()];
                case 4:
                  release();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Semaphore2.prototype.isLocked = function() {
          return this._value <= 0;
        };
        Semaphore2.prototype.release = function() {
          if (this._maxConcurrency > 1) {
            throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
          }
          if (this._currentReleaser) {
            var releaser = this._currentReleaser;
            this._currentReleaser = void 0;
            releaser();
          }
        };
        Semaphore2.prototype._dispatch = function() {
          var _this = this;
          var nextConsumer = this._queue.shift();
          if (!nextConsumer)
            return;
          var released = false;
          this._currentReleaser = function() {
            if (released)
              return;
            released = true;
            _this._value++;
            _this._dispatch();
          };
          nextConsumer([this._value--, this._currentReleaser]);
        };
        return Semaphore2;
      }()
    );
    exports.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore_1 = require_Semaphore();
    var Mutex = (
      /** @class */
      function() {
        function Mutex2() {
          this._semaphore = new Semaphore_1.default(1);
        }
        Mutex2.prototype.acquire = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, releaser;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this._semaphore.acquire()];
                case 1:
                  _a = _b.sent(), releaser = _a[1];
                  return [2, releaser];
              }
            });
          });
        };
        Mutex2.prototype.runExclusive = function(callback) {
          return this._semaphore.runExclusive(function() {
            return callback();
          });
        };
        Mutex2.prototype.isLocked = function() {
          return this._semaphore.isLocked();
        };
        Mutex2.prototype.release = function() {
          this._semaphore.release();
        };
        return Mutex2;
      }()
    );
    exports.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    var tslib_1 = require_tslib();
    function withTimeout(sync, timeout2, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = new Error("timeout");
      }
      return {
        acquire: function() {
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, ticket, release;
              return tslib_1.__generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    isTimeout = false;
                    setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout2);
                    return [4, sync.acquire()];
                  case 1:
                    ticket = _a.sent();
                    if (isTimeout) {
                      release = Array.isArray(ticket) ? ticket[1] : ticket;
                      release();
                    } else {
                      resolve(ticket);
                    }
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          });
        },
        runExclusive: function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release, ticket;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  release = function() {
                    return void 0;
                  };
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, , 7, 8]);
                  return [4, this.acquire()];
                case 2:
                  ticket = _a.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  release = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        },
        release: function() {
          sync.release();
        },
        isLocked: function() {
          return sync.isLocked();
        }
      };
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P3 = options.promiseModule;
      return new P3((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self2, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter2 = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter2(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports, module) {
    module.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex(bn) {
      return "0x" + bn.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value = hexToInt(hexString);
      return intToHex(value + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i3 = 0; i3 < byteCount; i3++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if ("earliest" === fromBlock)
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log) => this.matchLog(log));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber))
          return false;
        const normalizedLogAddress = log.address && log.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports, module) {
    module.exports = getBlocksForRange;
    async function getBlocksForRange({ provider, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_3, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(
        missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false]))
      );
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function sendAsync(provider, request) {
      return new Promise((resolve, reject) => {
        provider.sendAsync(request, (error, response) => {
          if (error) {
            reject(error);
          } else if (response.error) {
            reject(response.error);
          } else if (response.result) {
            resolve(response.result);
          } else {
            reject(new Error("Result was empty"));
          }
        });
      });
    }
    async function query(provider, method, params) {
      for (let i3 = 0; i3 < 3; i3++) {
        try {
          return await sendAsync(provider, {
            id: 1,
            jsonrpc: "2.0",
            method,
            params
          });
        } catch (error) {
          console.error(
            `provider.sendAsync failed: ${error.stack || error.message || error}`
          );
        }
      }
      throw new Error(`Block not found for params: ${JSON.stringify(params)}`);
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider, params }) {
        super();
        this.type = "block";
        this.provider = provider;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider }) {
        super();
        this.type = "tx";
        this.provider = provider;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports, module) {
    var Mutex = require_lib2().Mutex;
    var { createAsyncMiddleware, createScaffoldMiddleware } = require_dist2();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createScaffoldMiddleware({
        // install filters
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        // uninstall filters
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        // checking filter changes
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter2) => {
            try {
              await filter2.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter2 = new LogFilter({ provider, params });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newBlockFilter() {
        const filter2 = new BlockFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newPendingTransactionFilter() {
        const filter2 = new TxFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results = filter2.getChangesAndClear();
        return results;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        let results = [];
        if (filter2.type === "log") {
          results = filter2.getAllResults();
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        const result = Boolean(filter2);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter2) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter2.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter2;
        filter2.id = filterIndex;
        filter2.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter2 = await createFilterFn(...args);
        const result = intToHex(filter2.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn) {
      const values = [];
      for (let key in obj) {
        values.push(obj[key]);
      }
      return values;
    }
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var { createAsyncMiddleware, createScaffoldMiddleware } = require_dist2();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });
      let isDestroyed = false;
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events, middleware };
      async function subscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter2 = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter: filter2 });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results = rawBlocks.map(normalizeBlock).filter((block) => block !== null);
              results.forEach((value) => {
                _emitSubscriptionResult(subId2, value);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter: filter2 }) {
          filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter2.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const id = req.params[0];
        const subscription = subscriptions[id];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value) {
        events.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value
          }
        });
      }
      function destroy() {
        events.removeAllListeners();
        for (const id in subscriptions) {
          subscriptions[id].destroy();
          delete subscriptions[id];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      if (block === null || block === void 0) {
        return null;
      }
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionManager = void 0;
    var PollingBlockTracker = require_polling();
    var createSubscriptionManager = require_subscriptionManager();
    var noop2 = () => {
    };
    var SubscriptionManager = class {
      constructor(provider) {
        const blockTracker = new PollingBlockTracker({
          provider,
          pollingInterval: 15 * 1e3,
          setSkipCacheFlag: true
        });
        const { events, middleware } = createSubscriptionManager({
          blockTracker,
          provider
        });
        this.events = events;
        this.subscriptionMiddleware = middleware;
      }
      async handleRequest(request) {
        const result = {};
        await this.subscriptionMiddleware(request, result, noop2, noop2);
        return result;
      }
      destroy() {
        this.subscriptionMiddleware.destroy();
      }
    };
    exports.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js
var require_CoinbaseWalletProvider = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletProvider = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter());
    var bn_js_1 = __importDefault(require_bn());
    var eth_rpc_errors_1 = require_dist();
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var util_1 = require_util3();
    var eth_eip712_util_1 = __importDefault(require_eth_eip712_util());
    var FilterPolyfill_1 = require_FilterPolyfill();
    var JSONRPC_1 = require_JSONRPC();
    var SubscriptionManager_1 = require_SubscriptionManager();
    var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
    var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
    var CoinbaseWalletProvider = class extends safe_event_emitter_1.default {
      constructor(options) {
        var _a, _b;
        super();
        this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._relay = null;
        this._addresses = [];
        this.hasMadeFirstChainChangedEmission = false;
        this._send = this.send.bind(this);
        this._sendAsync = this.sendAsync.bind(this);
        this.setProviderInfo = this.setProviderInfo.bind(this);
        this.updateProviderInfo = this.updateProviderInfo.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.setAppInfo = this.setAppInfo.bind(this);
        this.enable = this.enable.bind(this);
        this.close = this.close.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this._setAddresses = this._setAddresses.bind(this);
        this.scanQRCode = this.scanQRCode.bind(this);
        this.genericRequest = this.genericRequest.bind(this);
        this._chainIdFromOpts = options.chainId;
        this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
        this._overrideIsMetaMask = options.overrideIsMetaMask;
        this._relayProvider = options.relayProvider;
        this._storage = options.storage;
        this._relayEventManager = options.relayEventManager;
        this.diagnostic = options.diagnosticLogger;
        this.reloadOnDisconnect = true;
        this.isCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
        this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        this.qrUrl = options.qrUrl;
        this.supportsAddressSwitching = options.supportsAddressSwitching;
        this.isLedger = options.isLedger;
        const chainId = this.getChainId();
        const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));
        this.emit("connect", { chainIdStr });
        const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
        if (cachedAddresses) {
          const addresses = cachedAddresses.split(" ");
          if (addresses[0] !== "") {
            this._addresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
            this.emit("accountsChanged", addresses);
          }
        }
        this._subscriptionManager.events.on("notification", (notification) => {
          this.emit("message", {
            type: notification.method,
            data: notification.params
          });
        });
        if (this._addresses.length > 0) {
          void this.initializeRelay();
        }
        window.addEventListener("message", (event) => {
          var _a2;
          if (event.origin !== location.origin || event.source !== window) {
            return;
          }
          if (event.data.type !== "walletLinkMessage")
            return;
          if (event.data.data.action === "defaultChainChanged" || event.data.data.action === "dappChainSwitched") {
            const _chainId = event.data.data.chainId;
            const jsonRpcUrl = (_a2 = event.data.data.jsonRpcUrl) !== null && _a2 !== void 0 ? _a2 : this.jsonRpcUrl;
            this.updateProviderInfo(jsonRpcUrl, Number(_chainId));
          }
          if (event.data.data.action === "addressChanged") {
            this._setAddresses([event.data.data.address]);
          }
        });
      }
      get selectedAddress() {
        return this._addresses[0] || void 0;
      }
      get networkVersion() {
        return this.getChainId().toString(10);
      }
      get chainId() {
        return (0, util_1.prepend0x)(this.getChainId().toString(16));
      }
      get isWalletLink() {
        return true;
      }
      /**
       * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
       * true for this method.
       */
      get isMetaMask() {
        return this._overrideIsMetaMask;
      }
      get host() {
        return this.jsonRpcUrl;
      }
      get connected() {
        return true;
      }
      isConnected() {
        return true;
      }
      get jsonRpcUrl() {
        var _a;
        return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : this._jsonRpcUrlFromOpts;
      }
      set jsonRpcUrl(value) {
        this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
      }
      disableReloadOnDisconnect() {
        this.reloadOnDisconnect = false;
      }
      /**
       * this function is called when coinbase provider is being injected to a dapp
       * standalone + walletlinked extension, ledger, in-app browser using cipher-web-view
       */
      setProviderInfo(jsonRpcUrl, chainId) {
        if (!(this.isLedger || this.isCoinbaseBrowser)) {
          this._chainIdFromOpts = chainId;
          this._jsonRpcUrlFromOpts = jsonRpcUrl;
        }
        this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
      }
      updateProviderInfo(jsonRpcUrl, chainId) {
        this.jsonRpcUrl = jsonRpcUrl;
        const originalChainId = this.getChainId();
        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
        const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;
        if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
          this.emit("chainChanged", this.getChainId());
          this.hasMadeFirstChainChangedEmission = true;
        }
      }
      async watchAsset(type, address, symbol, decimals, image, chainId) {
        const relay = await this.initializeRelay();
        const result = await relay.watchAsset(type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
        return !!result.result;
      }
      async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        var _a, _b;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return false;
        }
        const relay = await this.initializeRelay();
        const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
        if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
          await relay.requestEthereumAccounts().promise;
        }
        const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
        if (((_a = res.result) === null || _a === void 0 ? void 0 : _a.isApproved) === true) {
          this.updateProviderInfo(rpcUrls[0], chainId);
        }
        return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
      }
      async switchEthereumChain(chainId) {
        const relay = await this.initializeRelay();
        const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0).promise;
        if (res.errorCode) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: res.errorCode
          });
        }
        const switchResponse = res.result;
        if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
          this.updateProviderInfo(switchResponse.rpcUrl, chainId);
        }
      }
      setAppInfo(appName, appLogoUrl) {
        void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
      }
      async enable() {
        var _a;
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : void 0
        });
        if (this._addresses.length > 0) {
          return [...this._addresses];
        }
        return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
      }
      async close() {
        const relay = await this.initializeRelay();
        relay.resetAndReload();
      }
      send(requestOrMethod, callbackOrParams) {
        if (typeof requestOrMethod === "string") {
          const method = requestOrMethod;
          const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
          const request = {
            jsonrpc: "2.0",
            id: 0,
            method,
            params
          };
          return this._sendRequestAsync(request).then((res) => res.result);
        }
        if (typeof callbackOrParams === "function") {
          const request = requestOrMethod;
          const callback = callbackOrParams;
          return this._sendAsync(request, callback);
        }
        if (Array.isArray(requestOrMethod)) {
          const requests = requestOrMethod;
          return requests.map((r4) => this._sendRequest(r4));
        }
        const req = requestOrMethod;
        return this._sendRequest(req);
      }
      async sendAsync(request, callback) {
        if (typeof callback !== "function") {
          throw new Error("callback is required");
        }
        if (Array.isArray(request)) {
          const arrayCb = callback;
          this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
          return;
        }
        const cb = callback;
        return this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
      }
      async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: args
          });
        }
        const { method, params } = args;
        if (typeof method !== "string" || method.length === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: args
          });
        }
        const newParams = params === void 0 ? [] : params;
        const id = this._relayEventManager.makeRequestId();
        const result = await this._sendRequestAsync({
          method,
          params: newParams,
          jsonrpc: "2.0",
          id
        });
        return result.result;
      }
      async scanQRCode(match) {
        const relay = await this.initializeRelay();
        const res = await relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async genericRequest(data, action) {
        const relay = await this.initializeRelay();
        const res = await relay.genericRequest(data, action).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async selectProvider(providerOptions) {
        const relay = await this.initializeRelay();
        const res = await relay.selectProvider(providerOptions).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      supportsSubscriptions() {
        return false;
      }
      subscribe() {
        throw new Error("Subscriptions are not supported");
      }
      unsubscribe() {
        throw new Error("Subscriptions are not supported");
      }
      disconnect() {
        return true;
      }
      _sendRequest(request) {
        const response = {
          jsonrpc: "2.0",
          id: request.id
        };
        const { method } = request;
        response.result = this._handleSynchronousMethods(request);
        if (response.result === void 0) {
          throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
        }
        return response;
      }
      _setAddresses(addresses, isDisconnect) {
        if (!Array.isArray(addresses)) {
          throw new Error("addresses is not an array");
        }
        const newAddresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
          return;
        }
        if (this._addresses.length > 0 && this.supportsAddressSwitching === false && !isDisconnect) {
          return;
        }
        this._addresses = newAddresses;
        this.emit("accountsChanged", this._addresses);
        this._storage.setItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
      }
      _sendRequestAsync(request) {
        return new Promise((resolve, reject) => {
          try {
            const syncResult = this._handleSynchronousMethods(request);
            if (syncResult !== void 0) {
              return resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: syncResult
              });
            }
            const filterPromise = this._handleAsynchronousFilterMethods(request);
            if (filterPromise !== void 0) {
              filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
              return;
            }
            const subscriptionPromise = this._handleSubscriptionMethods(request);
            if (subscriptionPromise !== void 0) {
              subscriptionPromise.then((res) => resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: res.result
              })).catch((err) => reject(err));
              return;
            }
          } catch (err) {
            return reject(err);
          }
          this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
        });
      }
      _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r4) => this._sendRequestAsync(r4)));
      }
      _handleSynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_accounts:
            return this._eth_accounts();
          case JSONRPC_1.JSONRPCMethod.eth_coinbase:
            return this._eth_coinbase();
          case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
            return this._eth_uninstallFilter(params);
          case JSONRPC_1.JSONRPCMethod.net_version:
            return this._net_version();
          case JSONRPC_1.JSONRPCMethod.eth_chainId:
            return this._eth_chainId();
          default:
            return void 0;
        }
      }
      async _handleAsynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
            return this._eth_requestAccounts();
          case JSONRPC_1.JSONRPCMethod.eth_sign:
            return this._eth_sign(params);
          case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
            return this._eth_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.personal_sign:
            return this._personal_sign(params);
          case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
            return this._personal_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
            return this._eth_signTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
            return this._eth_sendRawTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
            return this._eth_sendTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
            return this._eth_signTypedData_v1(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
            return this._throwUnsupportedMethodError();
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
            return this._eth_signTypedData_v3(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
            return this._eth_signTypedData_v4(params);
          case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:
            return this._cbwallet_arbitrary(params);
          case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
            return this._wallet_addEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
            return this._wallet_switchEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
            return this._wallet_watchAsset(params);
        }
        const relay = await this.initializeRelay();
        return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
      }
      _handleAsynchronousFilterMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_newFilter:
            return this._eth_newFilter(params);
          case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
            return this._eth_newBlockFilter();
          case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
            return this._eth_newPendingTransactionFilter();
          case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
            return this._eth_getFilterChanges(params);
          case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
            return this._eth_getFilterLogs(params);
        }
        return void 0;
      }
      _handleSubscriptionMethods(request) {
        switch (request.method) {
          case JSONRPC_1.JSONRPCMethod.eth_subscribe:
          case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
            return this._subscriptionManager.handleRequest(request);
        }
        return void 0;
      }
      _isKnownAddress(addressString) {
        try {
          const addressStr = (0, util_1.ensureAddressString)(addressString);
          const lowercaseAddresses = this._addresses.map((address) => (0, util_1.ensureAddressString)(address));
          return lowercaseAddresses.includes(addressStr);
        } catch (_a) {
        }
        return false;
      }
      _ensureKnownAddress(addressString) {
        var _a;
        if (!this._isKnownAddress(addressString)) {
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
          throw new Error("Unknown Ethereum address");
        }
      }
      _prepareTransactionParams(tx) {
        const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;
        if (!fromAddress) {
          throw new Error("Ethereum address is unavailable");
        }
        this._ensureKnownAddress(fromAddress);
        const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;
        const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);
        const data = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer.alloc(0);
        const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;
        const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;
        const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;
        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;
        const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;
        const chainId = this.getChainId();
        return {
          fromAddress,
          toAddress,
          weiValue,
          data,
          nonce,
          gasPriceInWei,
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          chainId
        };
      }
      _isAuthorized() {
        return this._addresses.length > 0;
      }
      _requireAuthorization() {
        if (!this._isAuthorized()) {
          throw eth_rpc_errors_1.ethErrors.provider.unauthorized({});
        }
      }
      _throwUnsupportedMethodError() {
        throw eth_rpc_errors_1.ethErrors.provider.unsupportedMethod({});
      }
      async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
        this._ensureKnownAddress(address);
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied message signature");
          }
          throw err;
        }
      }
      async _ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        const relay = await this.initializeRelay();
        const res = await relay.ethereumAddressFromSignedMessage(message, signature, addPrefix).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      _eth_accounts() {
        return [...this._addresses];
      }
      _eth_coinbase() {
        return this.selectedAddress || null;
      }
      _net_version() {
        return this.getChainId().toString(10);
      }
      _eth_chainId() {
        return (0, util_1.hexStringFromIntNumber)(this.getChainId());
      }
      getChainId() {
        const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);
        if (!chainIdStr) {
          return (0, util_1.ensureIntNumber)(this._chainIdFromOpts);
        }
        const chainId = parseInt(chainIdStr, 10);
        return (0, util_1.ensureIntNumber)(chainId);
      }
      async _eth_requestAccounts() {
        var _a;
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : void 0
        });
        if (this._addresses.length > 0) {
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        }
        let res;
        try {
          const relay = await this.initializeRelay();
          res = await relay.requestEthereumAccounts().promise;
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
          }
          throw err;
        }
        if (!res.result) {
          throw new Error("accounts received is empty");
        }
        this._setAddresses(res.result);
        if (!(this.isLedger || this.isCoinbaseBrowser)) {
          await this.switchEthereumChain(this.getChainId());
        }
        return { jsonrpc: "2.0", id: 0, result: this._addresses };
      }
      _eth_sign(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const message = (0, util_1.ensureBuffer)(params[1]);
        return this._signEthereumMessage(message, address, false);
      }
      _eth_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature, false);
      }
      _personal_sign(params) {
        this._requireAuthorization();
        const message = (0, util_1.ensureBuffer)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        return this._signEthereumMessage(message, address, true);
      }
      _personal_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature, true);
      }
      async _eth_signTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_sendRawTransaction(params) {
        const signedTransaction = (0, util_1.ensureBuffer)(params[0]);
        const relay = await this.initializeRelay();
        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      async _eth_sendTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_signTypedData_v1(params) {
        this._requireAuthorization();
        const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v3(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v4(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      /** @deprecated */
      async _cbwallet_arbitrary(params) {
        const action = params[0];
        const data = params[1];
        if (typeof data !== "string") {
          throw new Error("parameter must be a string");
        }
        if (typeof action !== "object" || action === null) {
          throw new Error("parameter must be an object");
        }
        const result = await this.genericRequest(action, data);
        return { jsonrpc: "2.0", id: 0, result };
      }
      async _wallet_addEthereumChain(params) {
        var _a, _b, _c, _d;
        const request = params[0];
        if (((_a = request.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `please pass in at least 1 rpcUrl` }
          };
        }
        if (!request.chainName || request.chainName.trim() === "") {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "chainName is a required field"
          });
        }
        if (!request.nativeCurrency) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "nativeCurrency is a required field"
          });
        }
        const chainIdNumber = parseInt(request.chainId, 16);
        const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
        if (success) {
          return { jsonrpc: "2.0", id: 0, result: null };
        } else {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `unable to add ethereum chain` }
          };
        }
      }
      async _wallet_switchEthereumChain(params) {
        const request = params[0];
        await this.switchEthereumChain(parseInt(request.chainId, 16));
        return { jsonrpc: "2.0", id: 0, result: null };
      }
      async _wallet_watchAsset(params) {
        const request = Array.isArray(params) ? params[0] : params;
        if (!request.type) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "Type is required"
          });
        }
        if ((request === null || request === void 0 ? void 0 : request.type) !== "ERC20") {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Asset of type '${request.type}' is not supported`
          });
        }
        if (!(request === null || request === void 0 ? void 0 : request.options)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "Options are required"
          });
        }
        if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "Address is required"
          });
        }
        const chainId = this.getChainId();
        const { address, symbol, image, decimals } = request.options;
        const res = await this.watchAsset(request.type, address, symbol, decimals, image, chainId);
        return { jsonrpc: "2.0", id: 0, result: res };
      }
      _eth_uninstallFilter(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.uninstallFilter(filterId);
      }
      async _eth_newFilter(params) {
        const param = params[0];
        const filterId = await this._filterPolyfill.newFilter(param);
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newBlockFilter() {
        const filterId = await this._filterPolyfill.newBlockFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newPendingTransactionFilter() {
        const filterId = await this._filterPolyfill.newPendingTransactionFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      _eth_getFilterChanges(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterChanges(filterId);
      }
      _eth_getFilterLogs(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterLogs(filterId);
      }
      initializeRelay() {
        if (this._relay) {
          return Promise.resolve(this._relay);
        }
        return this._relayProvider().then((relay) => {
          relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));
          relay.setChainCallback((chainId, jsonRpcUrl) => {
            this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));
          });
          relay.setDappDefaultChainCallback(this._chainIdFromOpts);
          this._relay = relay;
          return relay;
        });
      }
    };
    exports.CoinbaseWalletProvider = CoinbaseWalletProvider;
  }
});

// node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => _,
  Fragment: () => d,
  cloneElement: () => D,
  createContext: () => E,
  createElement: () => v,
  createRef: () => p,
  h: () => v,
  hydrate: () => B,
  isValidElement: () => i,
  options: () => l,
  render: () => q,
  toChildArray: () => A
});
function a(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function h(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function v(l3, u3, i3) {
  var t3, r4, o3, f3 = {};
  for (o3 in u3)
    "key" == o3 ? t3 = u3[o3] : "ref" == o3 ? r4 = u3[o3] : f3[o3] = u3[o3];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps)
    for (o3 in l3.defaultProps)
      void 0 === f3[o3] && (f3[o3] = l3.defaultProps[o3]);
  return y(l3, f3, t3, r4, null);
}
function y(n2, i3, t3, r4, o3) {
  var f3 = { type: n2, props: i3, key: t3, ref: r4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o3 ? ++u : o3 };
  return null == o3 && null != l.vnode && l.vnode(f3), f3;
}
function p() {
  return { current: null };
}
function d(n2) {
  return n2.children;
}
function _(n2, l3) {
  this.props = n2, this.context = l3;
}
function k(n2, l3) {
  if (null == l3)
    return n2.__ ? k(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? k(n2) : null;
}
function b(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return b(n2);
  }
}
function g(n2) {
  (!n2.__d && (n2.__d = true) && t.push(n2) && !m.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(m);
}
function m() {
  var n2, l3, u3, i3, r4, o3, f3, e3;
  for (t.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }); n2 = t.shift(); )
    n2.__d && (l3 = t.length, i3 = void 0, r4 = void 0, f3 = (o3 = (u3 = n2).__v).__e, (e3 = u3.__P) && (i3 = [], (r4 = a({}, o3)).__v = o3.__v + 1, z(e3, o3, r4, u3.__n, void 0 !== e3.ownerSVGElement, null != o3.__h ? [f3] : null, i3, null == f3 ? k(o3) : f3, o3.__h), L(i3, o3), o3.__e != f3 && b(o3)), t.length > l3 && t.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }));
  m.__r = 0;
}
function w(n2, l3, u3, i3, t3, r4, o3, f3, s3, a3) {
  var h3, v3, p3, _3, b3, g3, m3, w3 = i3 && i3.__k || c, A3 = w3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if (null != (_3 = u3.__k[h3] = null == (_3 = l3[h3]) || "boolean" == typeof _3 ? null : "string" == typeof _3 || "number" == typeof _3 || "bigint" == typeof _3 ? y(null, _3, null, null, _3) : Array.isArray(_3) ? y(d, { children: _3 }, null, null, null) : _3.__b > 0 ? y(_3.type, _3.props, _3.key, _3.ref ? _3.ref : null, _3.__v) : _3)) {
      if (_3.__ = u3, _3.__b = u3.__b + 1, null === (p3 = w3[h3]) || p3 && _3.key == p3.key && _3.type === p3.type)
        w3[h3] = void 0;
      else
        for (v3 = 0; v3 < A3; v3++) {
          if ((p3 = w3[v3]) && _3.key == p3.key && _3.type === p3.type) {
            w3[v3] = void 0;
            break;
          }
          p3 = null;
        }
      z(n2, _3, p3 = p3 || e, t3, r4, o3, f3, s3, a3), b3 = _3.__e, (v3 = _3.ref) && p3.ref != v3 && (m3 || (m3 = []), p3.ref && m3.push(p3.ref, null, _3), m3.push(v3, _3.__c || b3, _3)), null != b3 ? (null == g3 && (g3 = b3), "function" == typeof _3.type && _3.__k === p3.__k ? _3.__d = s3 = x(_3, s3, n2) : s3 = P(n2, _3, p3, w3, b3, s3), "function" == typeof u3.type && (u3.__d = s3)) : s3 && p3.__e == s3 && s3.parentNode != n2 && (s3 = k(p3));
    }
  for (u3.__e = g3, h3 = A3; h3--; )
    null != w3[h3] && ("function" == typeof u3.type && null != w3[h3].__e && w3[h3].__e == u3.__d && (u3.__d = C(i3).nextSibling), O(w3[h3], w3[h3]));
  if (m3)
    for (h3 = 0; h3 < m3.length; h3++)
      N(m3[h3], m3[++h3], m3[++h3]);
}
function x(n2, l3, u3) {
  for (var i3, t3 = n2.__k, r4 = 0; t3 && r4 < t3.length; r4++)
    (i3 = t3[r4]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? x(i3, l3, u3) : P(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function A(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    A(n3, l3);
  }) : l3.push(n2)), l3;
}
function P(n2, l3, u3, i3, t3, r4) {
  var o3, f3, e3;
  if (void 0 !== l3.__d)
    o3 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t3 != r4 || null == t3.parentNode)
    n:
      if (null == r4 || r4.parentNode !== n2)
        n2.appendChild(t3), o3 = null;
      else {
        for (f3 = r4, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, r4), o3 = r4;
      }
  return void 0 !== o3 ? o3 : t3.nextSibling;
}
function C(n2) {
  var l3, u3, i3;
  if (null == n2.type || "string" == typeof n2.type)
    return n2.__e;
  if (n2.__k) {
    for (l3 = n2.__k.length - 1; l3 >= 0; l3--)
      if ((u3 = n2.__k[l3]) && (i3 = C(u3)))
        return i3;
  }
  return null;
}
function $(n2, l3, u3, i3, t3) {
  var r4;
  for (r4 in u3)
    "children" === r4 || "key" === r4 || r4 in l3 || I(n2, r4, null, u3[r4], i3);
  for (r4 in l3)
    t3 && "function" != typeof l3[r4] || "children" === r4 || "key" === r4 || "value" === r4 || "checked" === r4 || u3[r4] === l3[r4] || I(n2, r4, l3[r4], u3[r4], i3);
}
function H(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || s.test(l3) ? u3 : u3 + "px";
}
function I(n2, l3, u3, i3, t3) {
  var r4;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || H(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || H(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      r4 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r4] = u3, u3 ? i3 || n2.addEventListener(l3, r4 ? j : T, r4) : n2.removeEventListener(l3, r4 ? j : T, r4);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function T(n2) {
  return this.l[n2.type + false](l.event ? l.event(n2) : n2);
}
function j(n2) {
  return this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function z(n2, u3, i3, t3, r4, o3, f3, e3, c3) {
  var s3, h3, v3, y3, p3, k3, b3, g3, m3, x3, A3, P3, C2, $2, H2, I2 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, o3 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if ("function" == typeof I2) {
        if (g3 = u3.props, m3 = (s3 = I2.contextType) && t3[s3.__c], x3 = s3 ? m3 ? m3.props.value : s3.__ : t3, i3.__c ? b3 = (h3 = u3.__c = i3.__c).__ = h3.__E : ("prototype" in I2 && I2.prototype.render ? u3.__c = h3 = new I2(g3, x3) : (u3.__c = h3 = new _(g3, x3), h3.constructor = I2, h3.render = S), m3 && m3.sub(h3), h3.props = g3, h3.state || (h3.state = {}), h3.context = x3, h3.__n = t3, v3 = h3.__d = true, h3.__h = [], h3._sb = []), null == h3.__s && (h3.__s = h3.state), null != I2.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = a({}, h3.__s)), a(h3.__s, I2.getDerivedStateFromProps(g3, h3.__s))), y3 = h3.props, p3 = h3.state, h3.__v = u3, v3)
          null == I2.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
        else {
          if (null == I2.getDerivedStateFromProps && g3 !== y3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(g3, x3), !h3.__e && null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(g3, h3.__s, x3) || u3.__v === i3.__v) {
            for (u3.__v !== i3.__v && (h3.props = g3, h3.state = h3.__s, h3.__d = false), h3.__e = false, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), A3 = 0; A3 < h3._sb.length; A3++)
              h3.__h.push(h3._sb[A3]);
            h3._sb = [], h3.__h.length && f3.push(h3);
            break n;
          }
          null != h3.componentWillUpdate && h3.componentWillUpdate(g3, h3.__s, x3), null != h3.componentDidUpdate && h3.__h.push(function() {
            h3.componentDidUpdate(y3, p3, k3);
          });
        }
        if (h3.context = x3, h3.props = g3, h3.__P = n2, P3 = l.__r, C2 = 0, "prototype" in I2 && I2.prototype.render) {
          for (h3.state = h3.__s, h3.__d = false, P3 && P3(u3), s3 = h3.render(h3.props, h3.state, h3.context), $2 = 0; $2 < h3._sb.length; $2++)
            h3.__h.push(h3._sb[$2]);
          h3._sb = [];
        } else
          do {
            h3.__d = false, P3 && P3(u3), s3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
          } while (h3.__d && ++C2 < 25);
        h3.state = h3.__s, null != h3.getChildContext && (t3 = a(a({}, t3), h3.getChildContext())), v3 || null == h3.getSnapshotBeforeUpdate || (k3 = h3.getSnapshotBeforeUpdate(y3, p3)), H2 = null != s3 && s3.type === d && null == s3.key ? s3.props.children : s3, w(n2, Array.isArray(H2) ? H2 : [H2], u3, i3, t3, r4, o3, f3, e3, c3), h3.base = u3.__e, u3.__h = null, h3.__h.length && f3.push(h3), b3 && (h3.__E = h3.__ = null), h3.__e = false;
      } else
        null == o3 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = M(i3.__e, u3, i3, t3, r4, o3, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || null != o3) && (u3.__e = e3, u3.__h = !!c3, o3[o3.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function L(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function M(l3, u3, i3, t3, r4, o3, f3, c3) {
  var s3, a3, v3, y3 = i3.props, p3 = u3.props, d3 = u3.type, _3 = 0;
  if ("svg" === d3 && (r4 = true), null != o3) {
    for (; _3 < o3.length; _3++)
      if ((s3 = o3[_3]) && "setAttribute" in s3 == !!d3 && (d3 ? s3.localName === d3 : 3 === s3.nodeType)) {
        l3 = s3, o3[_3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d3)
      return document.createTextNode(p3);
    l3 = r4 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p3.is && p3), o3 = null, c3 = false;
  }
  if (null === d3)
    y3 === p3 || c3 && l3.data === p3 || (l3.data = p3);
  else {
    if (o3 = o3 && n.call(l3.childNodes), a3 = (y3 = i3.props || e).dangerouslySetInnerHTML, v3 = p3.dangerouslySetInnerHTML, !c3) {
      if (null != o3)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (v3 || a3) && (v3 && (a3 && v3.__html == a3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3 && v3.__html || ""));
    }
    if ($(l3, p3, y3, r4, c3), v3)
      u3.__k = [];
    else if (_3 = u3.props.children, w(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, r4 && "foreignObject" !== d3, o3, f3, o3 ? o3[0] : i3.__k && k(i3, 0), c3), null != o3)
      for (_3 = o3.length; _3--; )
        null != o3[_3] && h(o3[_3]);
    c3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d3 && !_3 || "option" === d3 && _3 !== y3.value) && I(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && I(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function N(n2, u3, i3) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function O(n2, u3, i3) {
  var t3, r4;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || N(t3, null, u3)), null != (t3 = n2.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k)
    for (r4 = 0; r4 < t3.length; r4++)
      t3[r4] && O(t3[r4], u3, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || h(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function S(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function q(u3, i3, t3) {
  var r4, o3, f3;
  l.__ && l.__(u3, i3), o3 = (r4 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], z(i3, u3 = (!r4 && t3 || i3).__k = v(d, null, [u3]), o3 || e, e, void 0 !== i3.ownerSVGElement, !r4 && t3 ? [t3] : o3 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r4 && t3 ? t3 : o3 ? o3.__e : i3.firstChild, r4), L(f3, u3);
}
function B(n2, l3) {
  q(n2, l3, B);
}
function D(l3, u3, i3) {
  var t3, r4, o3, f3 = a({}, l3.props);
  for (o3 in u3)
    "key" == o3 ? t3 = u3[o3] : "ref" == o3 ? r4 = u3[o3] : f3[o3] = u3[o3];
  return arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), y(l3.type, f3, t3 || l3.key, r4 || l3.ref, null);
}
function E(n2, l3) {
  var u3 = { __c: l3 = "__cC" + f++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(function(n5) {
        n5.__e = true, g(n5);
      });
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
var n, l, u, i, t, r, o, f, e, c, s;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    e = {};
    c = [];
    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n = c.slice, l = { __e: function(n2, l3, u3, i3) {
      for (var t3, r4, o3; l3 = l3.__; )
        if ((t3 = l3.__c) && !t3.__)
          try {
            if ((r4 = t3.constructor) && null != r4.getDerivedStateFromError && (t3.setState(r4.getDerivedStateFromError(n2)), o3 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o3 = t3.__d), o3)
              return t3.__E = t3;
          } catch (l4) {
            n2 = l4;
          }
      throw n2;
    } }, u = 0, i = function(n2) {
      return null != n2 && void 0 === n2.constructor;
    }, _.prototype.setState = function(n2, l3) {
      var u3;
      u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n2 && (n2 = n2(a({}, u3), this.props)), n2 && a(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), g(this));
    }, _.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), g(this));
    }, _.prototype.render = d, t = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, m.__r = 0, f = 0;
  }
});

// node_modules/rxjs/node_modules/tslib/tslib.es6.js
function __extends(d3, b3) {
  extendStatics(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var extendStatics;
var init_tslib_es6 = __esm({
  "node_modules/rxjs/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d3, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
        d4.__proto__ = b4;
      } || function(d4, b4) {
        for (var p3 in b4)
          if (b4.hasOwnProperty(p3))
            d4[p3] = b4[p3];
      };
      return extendStatics(d3, b3);
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isFunction.js
function isFunction(x3) {
  return typeof x3 === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/_esm5/internal/util/isFunction.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/config.js
var _enable_super_gross_mode_that_will_cause_bad_things, config;
var init_config = __esm({
  "node_modules/rxjs/_esm5/internal/config.js"() {
    _enable_super_gross_mode_that_will_cause_bad_things = false;
    config = {
      Promise: void 0,
      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          var error = new Error();
          console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log("RxJS: Back to a better error behavior. Thank you. <3");
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var init_hostReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/hostReportError.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/Observer.js
var empty;
var init_Observer = __esm({
  "node_modules/rxjs/_esm5/internal/Observer.js"() {
    init_config();
    init_hostReportError();
    empty = {
      closed: true,
      next: function(value) {
      },
      error: function(err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      },
      complete: function() {
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray;
var init_isArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArray.js"() {
    isArray = function() {
      return Array.isArray || function(x3) {
        return x3 && typeof x3.length === "number";
      };
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/isObject.js
function isObject(x3) {
  return x3 !== null && typeof x3 === "object";
}
var init_isObject = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObject.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionErrorImpl, UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js"() {
    UnsubscriptionErrorImpl = function() {
      function UnsubscriptionErrorImpl2(errors) {
        Error.call(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i3) {
          return i3 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
        return this;
      }
      UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl2;
    }();
    UnsubscriptionError = UnsubscriptionErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/Subscription.js
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var Subscription;
var init_Subscription = __esm({
  "node_modules/rxjs/_esm5/internal/Subscription.js"() {
    init_isArray();
    init_isObject();
    init_isFunction();
    init_UnsubscriptionError();
    Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._ctorUnsubscribe = true;
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var errors;
        if (this.closed) {
          return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription2) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (var index = 0; index < _parentOrParents.length; ++index) {
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
          }
        }
        if (isFunction(_unsubscribe)) {
          if (_ctorUnsubscribe) {
            this._unsubscribe = void 0;
          }
          try {
            _unsubscribe.call(this);
          } catch (e3) {
            errors = e3 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e3.errors) : [e3];
          }
        }
        if (isArray(_subscriptions)) {
          var index = -1;
          var len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject(sub)) {
              try {
                sub.unsubscribe();
              } catch (e3) {
                errors = errors || [];
                if (e3 instanceof UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e3.errors));
                } else {
                  errors.push(e3);
                }
              }
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) {
          return Subscription2.EMPTY;
        }
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription2)) {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription2) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.EMPTY = function(empty3) {
        empty3.closed = true;
        return empty3;
      }(new Subscription2());
      return Subscription2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber;
var init_rxSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js"() {
    rxSubscriber = function() {
      return typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
    }();
  }
});

// node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber, SafeSubscriber;
var init_Subscriber = __esm({
  "node_modules/rxjs/_esm5/internal/Subscriber.js"() {
    init_tslib_es6();
    init_isFunction();
    init_Observer();
    init_Subscription();
    init_rxSubscriber();
    init_config();
    init_hostReportError();
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
          case 0:
            _this.destination = empty;
            break;
          case 1:
            if (!destinationOrNext) {
              _this.destination = empty;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (destinationOrNext instanceof Subscriber2) {
                _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this.destination = destinationOrNext;
                destinationOrNext.add(_this);
              } else {
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext);
              }
              break;
            }
          default:
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
            break;
        }
        return _this;
      }
      Subscriber2.prototype[rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error, complete) {
        var subscriber = new Subscriber2(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      };
      return Subscriber2;
    }(Subscription);
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== empty) {
            context = Object.create(observerOrNext);
            if (isFunction(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
      }
      SafeSubscriber2.prototype.next = function(value) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          this.unsubscribe();
          if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError(err);
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
          throw new Error("bad call");
        }
        try {
          fn.call(this._context, value);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError(err);
            return true;
          }
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/canReportError.js
function canReportError(observer) {
  while (observer) {
    var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
var init_canReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/canReportError.js"() {
    init_Subscriber();
  }
});

// node_modules/rxjs/_esm5/internal/util/toSubscriber.js
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var init_toSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/util/toSubscriber.js"() {
    init_Subscriber();
    init_rxSubscriber();
    init_Observer();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/observable.js"() {
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/identity.js
function identity(x3) {
  return x3;
}
var init_identity = __esm({
  "node_modules/rxjs/_esm5/internal/util/identity.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/_esm5/internal/util/pipe.js"() {
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/_esm5/internal/Observable.js"() {
    init_canReportError();
    init_toSubscriber();
    init_observable();
    init_pipe();
    init_config();
    Observable = function() {
      function Observable2(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscription;
          subscription = _this.subscribe(function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x3) {
            return value = x3;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedErrorImpl, ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js"() {
    ObjectUnsubscribedErrorImpl = function() {
      function ObjectUnsubscribedErrorImpl2() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
      }
      ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl2;
    }();
    ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription;
var init_SubjectSubscription = __esm({
  "node_modules/rxjs/_esm5/internal/SubjectSubscription.js"() {
    init_tslib_es6();
    init_Subscription();
    SubjectSubscription = function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/Subject.js
var SubjectSubscriber, Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/_esm5/internal/Subject.js"() {
    init_tslib_es6();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    init_rxSubscriber();
    SubjectSubscriber = function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
      }
      return SubjectSubscriber2;
    }(Subscriber);
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype[rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i3 = 0; i3 < len; i3++) {
            copy[i3].next(value);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i3 = 0; i3 < len; i3++) {
          copy[i3].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i3 = 0; i3 < len; i3++) {
          copy[i3].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/operators/refCount.js
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator, RefCountSubscriber;
var init_refCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/refCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    RefCountOperator = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable, connectableObservableDescriptor, ConnectableSubscriber, RefCountOperator2, RefCountSubscriber2;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js"() {
    init_tslib_es6();
    init_Subject();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_refCount();
    ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
    connectableObservableDescriptor = function() {
      var connectableProto = ConnectableObservable.prototype;
      return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
      };
    }();
    ConnectableSubscriber = function(_super) {
      __extends(ConnectableSubscriber2, _super);
      function ConnectableSubscriber2(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      ConnectableSubscriber2.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber2.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
      };
      ConnectableSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;
          if (connection) {
            connection.unsubscribe();
          }
        }
      };
      return ConnectableSubscriber2;
    }(SubjectSubscriber);
    RefCountOperator2 = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber2(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber2 = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator, GroupBySubscriber, GroupDurationSubscriber, GroupedObservable, InnerRefCountSubscription;
var init_groupBy = __esm({
  "node_modules/rxjs/_esm5/internal/operators/groupBy.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    init_Observable();
    init_Subject();
    GroupByOperator = function() {
      function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }
      GroupByOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
      };
      return GroupByOperator2;
    }();
    GroupBySubscriber = function(_super) {
      __extends(GroupBySubscriber2, _super);
      function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
      }
      GroupBySubscriber2.prototype._next = function(value) {
        var key;
        try {
          key = this.keySelector(value);
        } catch (err) {
          this.error(err);
          return;
        }
        this._group(value, key);
      };
      GroupBySubscriber2.prototype._group = function(value, key) {
        var groups = this.groups;
        if (!groups) {
          groups = this.groups = /* @__PURE__ */ new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
          try {
            element = this.elementSelector(value);
          } catch (err) {
            this.error(err);
          }
        } else {
          element = value;
        }
        if (!group) {
          group = this.subjectSelector ? this.subjectSelector() : new Subject();
          groups.set(key, group);
          var groupedObservable = new GroupedObservable(key, group, this);
          this.destination.next(groupedObservable);
          if (this.durationSelector) {
            var duration = void 0;
            try {
              duration = this.durationSelector(new GroupedObservable(key, group));
            } catch (err) {
              this.error(err);
              return;
            }
            this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
          }
        }
        if (!group.closed) {
          group.next(element);
        }
      };
      GroupBySubscriber2.prototype._error = function(err) {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key) {
            group.error(err);
          });
          groups.clear();
        }
        this.destination.error(err);
      };
      GroupBySubscriber2.prototype._complete = function() {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key) {
            group.complete();
          });
          groups.clear();
        }
        this.destination.complete();
      };
      GroupBySubscriber2.prototype.removeGroup = function(key) {
        this.groups.delete(key);
      };
      GroupBySubscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.attemptedToUnsubscribe = true;
          if (this.count === 0) {
            _super.prototype.unsubscribe.call(this);
          }
        }
      };
      return GroupBySubscriber2;
    }(Subscriber);
    GroupDurationSubscriber = function(_super) {
      __extends(GroupDurationSubscriber2, _super);
      function GroupDurationSubscriber2(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
      }
      GroupDurationSubscriber2.prototype._next = function(value) {
        this.complete();
      };
      GroupDurationSubscriber2.prototype._unsubscribe = function() {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
          parent.removeGroup(key);
        }
      };
      return GroupDurationSubscriber2;
    }(Subscriber);
    GroupedObservable = function(_super) {
      __extends(GroupedObservable2, _super);
      function GroupedObservable2(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
      }
      GroupedObservable2.prototype._subscribe = function(subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
          subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
      };
      return GroupedObservable2;
    }(Observable);
    InnerRefCountSubscription = function(_super) {
      __extends(InnerRefCountSubscription2, _super);
      function InnerRefCountSubscription2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
      }
      InnerRefCountSubscription2.prototype.unsubscribe = function() {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
          _super.prototype.unsubscribe.call(this);
          parent.count -= 1;
          if (parent.count === 0 && parent.attemptedToUnsubscribe) {
            parent.unsubscribe();
          }
        }
      };
      return InnerRefCountSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/_esm5/internal/BehaviorSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_ObjectUnsubscribedError();
    BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/Action.js"() {
    init_tslib_es6();
    init_Subscription();
    Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"() {
    init_tslib_es6();
    init_Action();
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && this.delay === delay2 && this.pending === false) {
          return id;
        }
        clearInterval(id);
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay2);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, delay2) {
        var errored = false;
        var errorValue = void 0;
        try {
          this.work(state);
        } catch (e3) {
          errored = true;
          errorValue = !!e3 && e3 || new Error(e3);
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype._unsubscribe = function() {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
          actions.splice(index, 1);
        }
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/_esm5/internal/Scheduler.js"() {
    Scheduler = function() {
      function Scheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay2);
      };
      Scheduler2.now = function() {
        return Date.now();
      };
      return Scheduler2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"() {
    init_tslib_es6();
    init_Scheduler();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
            return AsyncScheduler2.delegate.now();
          } else {
            return now();
          }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = void 0;
        return _this;
      }
      AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
          return AsyncScheduler2.delegate.schedule(work, delay2, state);
        } else {
          return _super.prototype.schedule.call(this, work, delay2, state);
        }
      };
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
          actions.push(action);
          return;
        }
        var error;
        this.active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/queue.js
var queueScheduler, queue;
var init_queue = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/queue.js"() {
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = new QueueScheduler(QueueAction);
    queue = queueScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/observable/empty.js
function empty2(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/_esm5/internal/observable/empty.js"() {
    init_Observable();
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/rxjs/_esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var init_isScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/util/isScheduler.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray;
var init_subscribeToArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToArray.js"() {
    subscribeToArray = function(array) {
      return function(subscriber) {
        for (var i3 = 0, len = array.length; i3 < len && !subscriber.closed; i3++) {
          subscriber.next(array[i3]);
        }
        subscriber.complete();
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i3 = 0;
    sub.add(scheduler.schedule(function() {
      if (i3 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i3++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromArray.js
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
var init_fromArray = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromArray.js"() {
    init_Observable();
    init_subscribeToArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
var init_of = __esm({
  "node_modules/rxjs/_esm5/internal/observable/of.js"() {
    init_isScheduler();
    init_fromArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/throwError.js
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a) {
  var error = _a.error, subscriber = _a.subscriber;
  subscriber.error(error);
}
var init_throwError = __esm({
  "node_modules/rxjs/_esm5/internal/observable/throwError.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/Notification.js
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/rxjs/_esm5/internal/Notification.js"() {
    init_empty();
    init_of();
    init_throwError();
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);
          case "E":
            return observer.error && observer.error(this.error);
          case "C":
            return observer.complete && observer.complete();
        }
      };
      Notification2.prototype.do = function(next, error, complete) {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return next && next(this.value);
          case "E":
            return error && error(this.error);
          case "C":
            return complete && complete();
        }
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      };
      Notification2.prototype.toObservable = function() {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return of(this.value);
          case "E":
            return throwError(this.error);
          case "C":
            return empty2();
        }
        throw new Error("unexpected notification kind value");
      };
      Notification2.createNext = function(value) {
        if (typeof value !== "undefined") {
          return new Notification2("N", value);
        }
        return Notification2.undefinedValueNotification;
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      Notification2.undefinedValueNotification = new Notification2("N", void 0);
      return Notification2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage;
var init_observeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/observeOn.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    ObserveOnOperator = function() {
      function ObserveOnOperator2(scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      ObserveOnOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };
      return ObserveOnOperator2;
    }();
    ObserveOnSubscriber = function(_super) {
      __extends(ObserveOnSubscriber2, _super);
      function ObserveOnSubscriber2(destination, scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay2;
        return _this;
      }
      ObserveOnSubscriber2.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber2.prototype._next = function(value) {
        this.scheduleMessage(Notification.createNext(value));
      };
      ObserveOnSubscriber2.prototype._error = function(err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype._complete = function() {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
      };
      return ObserveOnSubscriber2;
    }(Subscriber);
    ObserveOnMessage = function() {
      function ObserveOnMessage2(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }
      return ObserveOnMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject, ReplayEvent;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/_esm5/internal/ReplaySubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_queue();
    init_Subscription();
    init_observeOn();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(bufferSize, windowTime2, scheduler) {
        if (bufferSize === void 0) {
          bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime2 === void 0) {
          windowTime2 = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
        if (windowTime2 === Number.POSITIVE_INFINITY) {
          _this._infiniteTimeWindow = true;
          _this.next = _this.nextInfiniteTimeWindow;
        } else {
          _this.next = _this.nextTimeWindow;
        }
        return _this;
      }
      ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
        if (!this.isStopped) {
          var _events = this._events;
          _events.push(value);
          if (_events.length > this._bufferSize) {
            _events.shift();
          }
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype.nextTimeWindow = function(value) {
        if (!this.isStopped) {
          this._events.push(new ReplayEvent(this._getNow(), value));
          this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.isStopped || this.hasError) {
          subscription = Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
          subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
          for (var i3 = 0; i3 < len && !subscriber.closed; i3++) {
            subscriber.next(_events[i3]);
          }
        } else {
          for (var i3 = 0; i3 < len && !subscriber.closed; i3++) {
            subscriber.next(_events[i3].value);
          }
        }
        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }
        return subscription;
      };
      ReplaySubject2.prototype._getNow = function() {
        return (this.scheduler || queue).now();
      };
      ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
          if (now - _events[spliceCount].time < _windowTime) {
            break;
          }
          spliceCount++;
        }
        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }
        return _events;
      };
      return ReplaySubject2;
    }(Subject);
    ReplayEvent = function() {
      function ReplayEvent2(time, value) {
        this.time = time;
        this.value = value;
      }
      return ReplayEvent2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/rxjs/_esm5/internal/AsyncSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
      }
      AsyncSubject2.prototype._subscribe = function(subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.hasCompleted) {
          this.value = value;
          this.hasNext = true;
        }
      };
      AsyncSubject2.prototype.error = function(error) {
        if (!this.hasCompleted) {
          _super.prototype.error.call(this, error);
        }
      };
      AsyncSubject2.prototype.complete = function() {
        this.hasCompleted = true;
        if (this.hasNext) {
          _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, RESOLVED, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/_esm5/internal/util/Immediate.js"() {
    nextHandle = 1;
    RESOLVED = function() {
      return Promise.resolve();
    }();
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js"() {
    init_tslib_es6();
    init_Immediate();
    init_AsyncAction();
    AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (scheduler.actions.length === 0) {
          Immediate.clearImmediate(id);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/asap.js
var asapScheduler, asap;
var init_asap = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/asap.js"() {
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
    asap = asapScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/async.js"() {
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
          return scheduler.flush(null);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler, animationFrame;
var init_animationFrame = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js"() {
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    animationFrame = animationFrameScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_AsyncScheduler();
    VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
          SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay2);
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return true;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction2.sortActions = function(a3, b3) {
        if (a3.delay === b3.delay) {
          if (a3.index === b3.index) {
            return 0;
          } else if (a3.index > b3.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a3.delay > b3.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/rxjs/_esm5/internal/util/noop.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var init_isObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObservable.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeErrorImpl, ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js"() {
    ArgumentOutOfRangeErrorImpl = function() {
      function ArgumentOutOfRangeErrorImpl2() {
        Error.call(this);
        this.message = "argument out of range";
        this.name = "ArgumentOutOfRangeError";
        return this;
      }
      ArgumentOutOfRangeErrorImpl2.prototype = Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl2;
    }();
    ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/EmptyError.js
var EmptyErrorImpl, EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/_esm5/internal/util/EmptyError.js"() {
    EmptyErrorImpl = function() {
      function EmptyErrorImpl2() {
        Error.call(this);
        this.message = "no elements in sequence";
        this.name = "EmptyError";
        return this;
      }
      EmptyErrorImpl2.prototype = Object.create(Error.prototype);
      return EmptyErrorImpl2;
    }();
    EmptyError = EmptyErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/TimeoutError.js
var TimeoutErrorImpl, TimeoutError;
var init_TimeoutError = __esm({
  "node_modules/rxjs/_esm5/internal/util/TimeoutError.js"() {
    TimeoutErrorImpl = function() {
      function TimeoutErrorImpl2() {
        Error.call(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        return this;
      }
      TimeoutErrorImpl2.prototype = Object.create(Error.prototype);
      return TimeoutErrorImpl2;
    }();
    TimeoutError = TimeoutErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/operators/map.js
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator, MapSubscriber;
var init_map = __esm({
  "node_modules/rxjs/_esm5/internal/operators/map.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapOperator = function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    MapSubscriber = function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      MapSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindCallback.js
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch2, 0, state);
      }
    });
  };
}
function dispatch2(state) {
  var _this = this;
  var self2 = this;
  var args = state.args, subscriber = state.subscriber, params = state.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
  var value = state.value, subject = state.subject;
  subject.next(value);
  subject.complete();
}
var init_bindCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isArray();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch3, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch3(state) {
  var _this = this;
  var params = state.params, subscriber = state.subscriber, context = state.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var init_bindNodeCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isScheduler();
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber;
var init_OuterSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/OuterSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    OuterSubscriber = function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber;
var init_InnerSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/InnerSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    InnerSubscriber = function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }
      InnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
var subscribeToPromise;
var init_subscribeToPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js"() {
    init_hostReportError();
    subscribeToPromise = function(promise) {
      return function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, hostReportError);
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/iterator.js"() {
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
var subscribeToIterable;
var init_subscribeToIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js"() {
    init_iterator();
    subscribeToIterable = function(iterable) {
      return function(subscriber) {
        var iterator2 = iterable[iterator]();
        do {
          var item = void 0;
          try {
            item = iterator2.next();
          } catch (err) {
            subscriber.error(err);
            return subscriber;
          }
          if (item.done) {
            subscriber.complete();
            break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
            break;
          }
        } while (true);
        if (typeof iterator2.return === "function") {
          subscriber.add(function() {
            if (iterator2.return) {
              iterator2.return();
            }
          });
        }
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
var subscribeToObservable;
var init_subscribeToObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js"() {
    init_observable();
    subscribeToObservable = function(obj) {
      return function(subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== "function") {
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        } else {
          return obs.subscribe(subscriber);
        }
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArrayLike.js"() {
    isArrayLike = function(x3) {
      return x3 && typeof x3.length === "number" && typeof x3 !== "function";
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isPromise.js
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var init_isPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/isPromise.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeTo.js
var subscribeTo;
var init_subscribeTo = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeTo.js"() {
    init_subscribeToArray();
    init_subscribeToPromise();
    init_subscribeToIterable();
    init_subscribeToObservable();
    init_isArrayLike();
    init_isPromise();
    init_isObject();
    init_iterator();
    init_observable();
    subscribeTo = function(result) {
      if (!!result && typeof result[observable] === "function") {
        return subscribeToObservable(result);
      } else if (isArrayLike(result)) {
        return subscribeToArray(result);
      } else if (isPromise(result)) {
        return subscribeToPromise(result);
      } else if (!!result && typeof result[iterator] === "function") {
        return subscribeToIterable(result);
      } else {
        var value = isObject(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var init_subscribeToResult = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"() {
    init_InnerSubscriber();
    init_subscribeTo();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/combineLatest.js
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var NONE, CombineLatestOperator, CombineLatestSubscriber;
var init_combineLatest = __esm({
  "node_modules/rxjs/_esm5/internal/observable/combineLatest.js"() {
    init_tslib_es6();
    init_isScheduler();
    init_isArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    init_fromArray();
    NONE = {};
    CombineLatestOperator = function() {
      function CombineLatestOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      CombineLatestOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
      };
      return CombineLatestOperator2;
    }();
    CombineLatestSubscriber = function(_super) {
      __extends(CombineLatestSubscriber2, _super);
      function CombineLatestSubscriber2(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
      }
      CombineLatestSubscriber2.prototype._next = function(observable2) {
        this.values.push(NONE);
        this.observables.push(observable2);
      };
      CombineLatestSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;
          for (var i3 = 0; i3 < len; i3++) {
            var observable2 = observables[i3];
            this.add(subscribeToResult(this, observable2, void 0, i3));
          }
        }
      };
      CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };
      CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
          if (this.resultSelector) {
            this._tryResultSelector(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };
      CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
        var result;
        try {
          result = this.resultSelector.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return CombineLatestSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable2 = input[observable]();
      sub.add(observable2.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js"() {
    init_Observable();
    init_Subscription();
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator2;
    sub.add(function() {
      if (iterator2 && typeof iterator2.return === "function") {
        iterator2.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator2 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done;
        try {
          var result = iterator2.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js"() {
    init_Observable();
    init_Subscription();
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isInteropObservable.js"() {
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/isIterable.js
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
var init_isIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isIterable.js"() {
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
var init_scheduled = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduled.js"() {
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/from.js
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var init_from = __esm({
  "node_modules/rxjs/_esm5/internal/observable/from.js"() {
    init_Observable();
    init_subscribeTo();
    init_scheduled();
  }
});

// node_modules/rxjs/_esm5/internal/innerSubscribe.js
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
var SimpleInnerSubscriber, ComplexInnerSubscriber, SimpleOuterSubscriber, ComplexOuterSubscriber;
var init_innerSubscribe = __esm({
  "node_modules/rxjs/_esm5/internal/innerSubscribe.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_subscribeTo();
    SimpleInnerSubscriber = function(_super) {
      __extends(SimpleInnerSubscriber2, _super);
      function SimpleInnerSubscriber2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
      }
      SimpleInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(value);
      };
      SimpleInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      SimpleInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete();
        this.unsubscribe();
      };
      return SimpleInnerSubscriber2;
    }(Subscriber);
    ComplexInnerSubscriber = function(_super) {
      __extends(ComplexInnerSubscriber2, _super);
      function ComplexInnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
      }
      ComplexInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
      };
      ComplexInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      ComplexInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return ComplexInnerSubscriber2;
    }(Subscriber);
    SimpleOuterSubscriber = function(_super) {
      __extends(SimpleOuterSubscriber2, _super);
      function SimpleOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      SimpleOuterSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      SimpleOuterSubscriber2.prototype.notifyComplete = function() {
        this.destination.complete();
      };
      return SimpleOuterSubscriber2;
    }(Subscriber);
    ComplexOuterSubscriber = function(_super) {
      __extends(ComplexOuterSubscriber2, _super);
      function ComplexOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComplexOuterSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
      };
      ComplexOuterSubscriber2.prototype.notifyError = function(error) {
        this.destination.error(error);
      };
      ComplexOuterSubscriber2.prototype.notifyComplete = function(_innerSub) {
        this.destination.complete();
      };
      return ComplexOuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a3, i3) {
        return from(project(a3, i3)).pipe(map(function(b3, ii) {
          return resultSelector(a3, b3, i3, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator, MergeMapSubscriber, flatMap;
var init_mergeMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    MergeMapOperator = function() {
      function MergeMapOperator2(project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
      }
      MergeMapOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator2;
    }();
    MergeMapSubscriber = function(_super) {
      __extends(MergeMapSubscriber2, _super);
      function MergeMapSubscriber2(destination, project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeMapSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      };
      MergeMapSubscriber2.prototype._tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.active++;
        this._innerSub(result);
      };
      MergeMapSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      MergeMapSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };
      return MergeMapSubscriber2;
    }(SimpleOuterSubscriber);
    flatMap = mergeMap;
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeAll.js"() {
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatAll.js"() {
    init_mergeAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/concat.js
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
var init_concat = __esm({
  "node_modules/rxjs/_esm5/internal/observable/concat.js"() {
    init_of();
    init_concatAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty2();
    return source.subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/defer.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/forkJoin.js
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key) {
        return first_1[key];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i4) {
      var source = from(sources[i4]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i4] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function(result, key, i5) {
                return result[key] = values[i5], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i3 = 0; i3 < len; i3++) {
      _loop_1(i3);
    }
  });
}
var init_forkJoin = __esm({
  "node_modules/rxjs/_esm5/internal/observable/forkJoin.js"() {
    init_Observable();
    init_isArray();
    init_map();
    init_isObject();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEvent.js
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e3) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e3);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i3 = 0, len = sourceObj.length; i3 < len; i3++) {
      setupSubscription(sourceObj[i3], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
var toString;
var init_fromEvent = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEvent.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
    toString = function() {
      return Object.prototype.toString;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e3 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e3[_i] = arguments[_i];
      }
      return subscriber.next(e3.length === 1 ? e3[0] : e3);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
var init_fromEventPattern = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/observable/generate.js
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch4(state) {
  var subscriber = state.subscriber, condition = state.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state);
}
var init_generate = __esm({
  "node_modules/rxjs/_esm5/internal/observable/generate.js"() {
    init_Observable();
    init_identity();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
var init_iif = __esm({
  "node_modules/rxjs/_esm5/internal/observable/iif.js"() {
    init_defer();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/util/isNumeric.js
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
var init_isNumeric = __esm({
  "node_modules/rxjs/_esm5/internal/util/isNumeric.js"() {
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch5, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch5(state) {
  var subscriber = state.subscriber, counter = state.counter, period = state.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
var init_interval = __esm({
  "node_modules/rxjs/_esm5/internal/observable/interval.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
  }
});

// node_modules/rxjs/_esm5/internal/observable/merge.js
function merge() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/_esm5/internal/observable/merge.js"() {
    init_Observable();
    init_isScheduler();
    init_mergeAll();
    init_fromArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/never.js
function never() {
  return NEVER;
}
var NEVER;
var init_never = __esm({
  "node_modules/rxjs/_esm5/internal/observable/never.js"() {
    init_Observable();
    init_noop();
    NEVER = new Observable(noop);
  }
});

// node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray(first2)) {
    return onErrorResumeNext.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
var init_onErrorResumeNext = __esm({
  "node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js"() {
    init_Observable();
    init_from();
    init_isArray();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/pairs.js
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      for (var i3 = 0; i3 < keys.length && !subscriber.closed; i3++) {
        var key = keys[i3];
        if (obj.hasOwnProperty(key)) {
          subscriber.next([key, obj[key]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch6, 0, { keys, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch6(state) {
  var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
  if (!subscriber.closed) {
    if (index < keys.length) {
      var key = keys[index];
      subscriber.next([key, obj[key]]);
      subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
var init_pairs = __esm({
  "node_modules/rxjs/_esm5/internal/observable/pairs.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/util/not.js
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
var init_not = __esm({
  "node_modules/rxjs/_esm5/internal/util/not.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator, FilterSubscriber;
var init_filter = __esm({
  "node_modules/rxjs/_esm5/internal/operators/filter.js"() {
    init_tslib_es6();
    init_Subscriber();
    FilterOperator = function() {
      function FilterOperator2(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }
      FilterOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator2;
    }();
    FilterSubscriber = function(_super) {
      __extends(FilterSubscriber2, _super);
      function FilterSubscriber2(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
      }
      FilterSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.destination.next(value);
        }
      };
      return FilterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
var init_partition = __esm({
  "node_modules/rxjs/_esm5/internal/observable/partition.js"() {
    init_not();
    init_subscribeTo();
    init_filter();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/race.js
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator, RaceSubscriber;
var init_race = __esm({
  "node_modules/rxjs/_esm5/internal/observable/race.js"() {
    init_tslib_es6();
    init_isArray();
    init_fromArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    RaceOperator = function() {
      function RaceOperator2() {
      }
      RaceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      };
      return RaceOperator2;
    }();
    RaceSubscriber = function(_super) {
      __extends(RaceSubscriber2, _super);
      function RaceSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
      }
      RaceSubscriber2.prototype._next = function(observable2) {
        this.observables.push(observable2);
      };
      RaceSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          for (var i3 = 0; i3 < len && !this.hasFirst; i3++) {
            var observable2 = observables[i3];
            var subscription = subscribeToResult(this, observable2, void 0, i3);
            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }
            this.add(subscription);
          }
          this.observables = null;
        }
      };
      RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
          this.hasFirst = true;
          for (var i3 = 0; i3 < this.subscriptions.length; i3++) {
            if (i3 !== outerIndex) {
              var subscription = this.subscriptions[i3];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }
          this.subscriptions = null;
        }
        this.destination.next(innerValue);
      };
      return RaceSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch7, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch7(state) {
  var start = state.start, index = state.index, count2 = state.count, subscriber = state.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
var init_range = __esm({
  "node_modules/rxjs/_esm5/internal/observable/range.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/timer.js
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch8, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch8(state) {
  var index = state.index, period = state.period, subscriber = state.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
var init_timer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/timer.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
var init_using = __esm({
  "node_modules/rxjs/_esm5/internal/observable/using.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/zip.js
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator, ZipSubscriber, StaticIterator, StaticArrayIterator, ZipBufferIterator;
var init_zip = __esm({
  "node_modules/rxjs/_esm5/internal/observable/zip.js"() {
    init_tslib_es6();
    init_fromArray();
    init_isArray();
    init_Subscriber();
    init_iterator();
    init_innerSubscribe();
    ZipOperator = function() {
      function ZipOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      ZipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
      };
      return ZipOperator2;
    }();
    ZipSubscriber = function(_super) {
      __extends(ZipSubscriber2, _super);
      function ZipSubscriber2(destination, resultSelector, values) {
        if (values === void 0) {
          values = /* @__PURE__ */ Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
        return _this;
      }
      ZipSubscriber2.prototype._next = function(value) {
        var iterators = this.iterators;
        if (isArray(value)) {
          iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator] === "function") {
          iterators.push(new StaticIterator(value[iterator]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
      };
      ZipSubscriber2.prototype._complete = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
          this.destination.complete();
          return;
        }
        this.active = len;
        for (var i3 = 0; i3 < len; i3++) {
          var iterator2 = iterators[i3];
          if (iterator2.stillUnsubscribed) {
            var destination = this.destination;
            destination.add(iterator2.subscribe());
          } else {
            this.active--;
          }
        }
      };
      ZipSubscriber2.prototype.notifyInactive = function() {
        this.active--;
        if (this.active === 0) {
          this.destination.complete();
        }
      };
      ZipSubscriber2.prototype.checkIterators = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i3 = 0; i3 < len; i3++) {
          var iterator2 = iterators[i3];
          if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
            return;
          }
        }
        var shouldComplete = false;
        var args = [];
        for (var i3 = 0; i3 < len; i3++) {
          var iterator2 = iterators[i3];
          var result = iterator2.next();
          if (iterator2.hasCompleted()) {
            shouldComplete = true;
          }
          if (result.done) {
            destination.complete();
            return;
          }
          args.push(result.value);
        }
        if (this.resultSelector) {
          this._tryresultSelector(args);
        } else {
          destination.next(args);
        }
        if (shouldComplete) {
          destination.complete();
        }
      };
      ZipSubscriber2.prototype._tryresultSelector = function(args) {
        var result;
        try {
          result = this.resultSelector.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return ZipSubscriber2;
    }(Subscriber);
    StaticIterator = function() {
      function StaticIterator2(iterator2) {
        this.iterator = iterator2;
        this.nextResult = iterator2.next();
      }
      StaticIterator2.prototype.hasValue = function() {
        return true;
      };
      StaticIterator2.prototype.next = function() {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      };
      StaticIterator2.prototype.hasCompleted = function() {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
      };
      return StaticIterator2;
    }();
    StaticArrayIterator = function() {
      function StaticArrayIterator2(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
      }
      StaticArrayIterator2.prototype[iterator] = function() {
        return this;
      };
      StaticArrayIterator2.prototype.next = function(value) {
        var i3 = this.index++;
        var array = this.array;
        return i3 < this.length ? { value: array[i3], done: false } : { value: null, done: true };
      };
      StaticArrayIterator2.prototype.hasValue = function() {
        return this.array.length > this.index;
      };
      StaticArrayIterator2.prototype.hasCompleted = function() {
        return this.array.length === this.index;
      };
      return StaticArrayIterator2;
    }();
    ZipBufferIterator = function(_super) {
      __extends(ZipBufferIterator2, _super);
      function ZipBufferIterator2(destination, parent, observable2) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable2;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
      }
      ZipBufferIterator2.prototype[iterator] = function() {
        return this;
      };
      ZipBufferIterator2.prototype.next = function() {
        var buffer2 = this.buffer;
        if (buffer2.length === 0 && this.isComplete) {
          return { value: null, done: true };
        } else {
          return { value: buffer2.shift(), done: false };
        }
      };
      ZipBufferIterator2.prototype.hasValue = function() {
        return this.buffer.length > 0;
      };
      ZipBufferIterator2.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete;
      };
      ZipBufferIterator2.prototype.notifyComplete = function() {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      };
      ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      };
      ZipBufferIterator2.prototype.subscribe = function() {
        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
      };
      return ZipBufferIterator2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/index.js
var esm5_exports = {};
__export(esm5_exports, {
  ArgumentOutOfRangeError: () => ArgumentOutOfRangeError,
  AsyncSubject: () => AsyncSubject,
  BehaviorSubject: () => BehaviorSubject,
  ConnectableObservable: () => ConnectableObservable,
  EMPTY: () => EMPTY,
  EmptyError: () => EmptyError,
  GroupedObservable: () => GroupedObservable,
  NEVER: () => NEVER,
  Notification: () => Notification,
  NotificationKind: () => NotificationKind,
  ObjectUnsubscribedError: () => ObjectUnsubscribedError,
  Observable: () => Observable,
  ReplaySubject: () => ReplaySubject,
  Scheduler: () => Scheduler,
  Subject: () => Subject,
  Subscriber: () => Subscriber,
  Subscription: () => Subscription,
  TimeoutError: () => TimeoutError,
  UnsubscriptionError: () => UnsubscriptionError,
  VirtualAction: () => VirtualAction,
  VirtualTimeScheduler: () => VirtualTimeScheduler,
  animationFrame: () => animationFrame,
  animationFrameScheduler: () => animationFrameScheduler,
  asap: () => asap,
  asapScheduler: () => asapScheduler,
  async: () => async,
  asyncScheduler: () => asyncScheduler,
  bindCallback: () => bindCallback,
  bindNodeCallback: () => bindNodeCallback,
  combineLatest: () => combineLatest,
  concat: () => concat,
  config: () => config,
  defer: () => defer,
  empty: () => empty2,
  forkJoin: () => forkJoin,
  from: () => from,
  fromEvent: () => fromEvent,
  fromEventPattern: () => fromEventPattern,
  generate: () => generate,
  identity: () => identity,
  iif: () => iif,
  interval: () => interval,
  isObservable: () => isObservable,
  merge: () => merge,
  never: () => never,
  noop: () => noop,
  observable: () => observable,
  of: () => of,
  onErrorResumeNext: () => onErrorResumeNext,
  pairs: () => pairs,
  partition: () => partition,
  pipe: () => pipe,
  queue: () => queue,
  queueScheduler: () => queueScheduler,
  race: () => race,
  range: () => range,
  scheduled: () => scheduled,
  throwError: () => throwError,
  timer: () => timer,
  using: () => using,
  zip: () => zip
});
var init_esm5 = __esm({
  "node_modules/rxjs/_esm5/index.js"() {
    init_Observable();
    init_ConnectableObservable();
    init_groupBy();
    init_observable();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_ObjectUnsubscribedError();
    init_UnsubscriptionError();
    init_TimeoutError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_config();
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r2(e3) {
  var t3, f3, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3)
    n2 += e3;
  else if ("object" == typeof e3)
    if (Array.isArray(e3))
      for (t3 = 0; t3 < e3.length; t3++)
        e3[t3] && (f3 = r2(e3[t3])) && (n2 && (n2 += " "), n2 += f3);
    else
      for (t3 in e3)
        e3[t3] && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
function clsx() {
  for (var e3, t3, f3 = 0, n2 = ""; f3 < arguments.length; )
    (e3 = arguments[f3++]) && (t3 = r2(e3)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => T2,
  useContext: () => q2,
  useDebugValue: () => x2,
  useEffect: () => h2,
  useErrorBoundary: () => P2,
  useId: () => V,
  useImperativeHandle: () => A2,
  useLayoutEffect: () => s2,
  useMemo: () => F,
  useReducer: () => y2,
  useRef: () => _2,
  useState: () => p2
});
function d2(t3, u3) {
  l.__h && l.__h(r3, t3, o2 || u3), o2 = 0;
  var i3 = r3.__H || (r3.__H = { __: [], __h: [] });
  return t3 >= i3.__.length && i3.__.push({ __V: c2 }), i3.__[t3];
}
function p2(n2) {
  return o2 = 1, y2(B2, n2);
}
function y2(n2, u3, i3) {
  var o3 = d2(t2++, 2);
  if (o3.t = n2, !o3.__c && (o3.__ = [i3 ? i3(u3) : B2(void 0, u3), function(n3) {
    var t3 = o3.__N ? o3.__N[0] : o3.__[0], r4 = o3.t(t3, n3);
    t3 !== r4 && (o3.__N = [r4, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r3, !r3.u)) {
    r3.u = true;
    var f3 = r3.shouldComponentUpdate;
    r3.shouldComponentUpdate = function(n3, t3, r4) {
      if (!o3.__c.__H)
        return true;
      var u4 = o3.__c.__H.__.filter(function(n4) {
        return n4.__c;
      });
      if (u4.every(function(n4) {
        return !n4.__N;
      }))
        return !f3 || f3.call(this, n3, t3, r4);
      var i4 = false;
      return u4.forEach(function(n4) {
        if (n4.__N) {
          var t4 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t4 !== n4.__[0] && (i4 = true);
        }
      }), !(!i4 && o3.__c.props === n3) && (!f3 || f3.call(this, n3, t3, r4));
    };
  }
  return o3.__N || o3.__;
}
function h2(u3, i3) {
  var o3 = d2(t2++, 3);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r3.__H.__h.push(o3));
}
function s2(u3, i3) {
  var o3 = d2(t2++, 4);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r3.__h.push(o3));
}
function _2(n2) {
  return o2 = 5, F(function() {
    return { current: n2 };
  }, []);
}
function A2(n2, t3, r4) {
  o2 = 6, s2(function() {
    return "function" == typeof n2 ? (n2(t3()), function() {
      return n2(null);
    }) : n2 ? (n2.current = t3(), function() {
      return n2.current = null;
    }) : void 0;
  }, null == r4 ? r4 : r4.concat(n2));
}
function F(n2, r4) {
  var u3 = d2(t2++, 7);
  return z2(u3.__H, r4) ? (u3.__V = n2(), u3.i = r4, u3.__h = n2, u3.__V) : u3.__;
}
function T2(n2, t3) {
  return o2 = 8, F(function() {
    return n2;
  }, t3);
}
function q2(n2) {
  var u3 = r3.context[n2.__c], i3 = d2(t2++, 9);
  return i3.c = n2, u3 ? (null == i3.__ && (i3.__ = true, u3.sub(r3)), u3.props.value) : n2.__;
}
function x2(t3, r4) {
  l.useDebugValue && l.useDebugValue(r4 ? r4(t3) : t3);
}
function P2(n2) {
  var u3 = d2(t2++, 10), i3 = p2();
  return u3.__ = n2, r3.componentDidCatch || (r3.componentDidCatch = function(n3, t3) {
    u3.__ && u3.__(n3, t3), i3[1](n3);
  }), [i3[0], function() {
    i3[1](void 0);
  }];
}
function V() {
  var n2 = d2(t2++, 11);
  if (!n2.__) {
    for (var u3 = r3.__v; null !== u3 && !u3.__m && null !== u3.__; )
      u3 = u3.__;
    var i3 = u3.__m || (u3.__m = [0, 0]);
    n2.__ = "P" + i3[0] + "-" + i3[1]++;
  }
  return n2.__;
}
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r4) {
        t3.__H.__h = [], l.__e(r4, t3.__v);
      }
}
function j2(n2) {
  var t3, r4 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r4, 100);
  g2 && (t3 = requestAnimationFrame(r4));
}
function k2(n2) {
  var t3 = r3, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r3 = t3;
}
function w2(n2) {
  var t3 = r3;
  n2.__c = n2.__(), r3 = t3;
}
function z2(n2, t3) {
  return !n2 || n2.length !== t3.length || t3.some(function(t4, r4) {
    return t4 !== n2[r4];
  });
}
function B2(n2, t3) {
  return "function" == typeof t3 ? t3(n2) : t3;
}
var t2, r3, u2, i2, o2, f2, c2, e2, a2, v2, l2, m2, g2;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o2 = 0;
    f2 = [];
    c2 = [];
    e2 = l.__b;
    a2 = l.__r;
    v2 = l.diffed;
    l2 = l.__c;
    m2 = l.unmount;
    l.__b = function(n2) {
      r3 = null, e2 && e2(n2);
    }, l.__r = function(n2) {
      a2 && a2(n2), t2 = 0;
      var i3 = (r3 = n2.__c).__H;
      i3 && (u2 === r3 ? (i3.__h = [], r3.__h = [], i3.__.forEach(function(n3) {
        n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
      })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r3;
    }, l.diffed = function(t3) {
      v2 && v2(t3);
      var o3 = t3.__c;
      o3 && o3.__H && (o3.__H.__h.length && (1 !== f2.push(o3) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n2) {
        n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
      })), u2 = r3 = null;
    }, l.__c = function(t3, r4) {
      r4.some(function(t4) {
        try {
          t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
            return !n2.__ || w2(n2);
          });
        } catch (u3) {
          r4.some(function(n2) {
            n2.__h && (n2.__h = []);
          }), r4 = [], l.__e(u3, t4.__v);
        }
      }), l2 && l2(t3, r4);
    }, l.unmount = function(t3) {
      m2 && m2(t3);
      var r4, u3 = t3.__c;
      u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
        try {
          k2(n2);
        } catch (n3) {
          r4 = n3;
        }
      }), u3.__H = void 0, r4 && l.__e(r4, u3.__v));
    };
    g2 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/version.js
var require_version = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LIB_VERSION = void 0;
    exports.LIB_VERSION = "3.6.4";
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/CloseIcon.js
var require_CloseIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/CloseIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloseIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function CloseIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
      );
    }
    exports.CloseIcon = CloseIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-round-svg.js
var require_coinbase_round_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-round-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMTQuMDM3IDE4LjkyNmMtMi43NSAwLTQuOTA3LTIuMjA1LTQuOTA3LTQuOTI2IDAtMi43MiAyLjIzLTQuOTI2IDQuOTA3LTQuOTI2YTQuODY2IDQuODY2IDAgMCAxIDQuODMzIDQuMTE4aDQuOTgyYy0uNDQ2LTUuMDczLTQuNjg0LTkuMDQ0LTkuODE1LTkuMDQ0QzguNjEgNC4xNDggNC4xNDkgOC41NiA0LjE0OSAxNHM0LjM4NyA5Ljg1MiA5Ljg5IDkuODUyYzUuMjA0IDAgOS4zNjgtMy45NyA5LjgxNC05LjA0M0gxOC44N2E0Ljg2NiA0Ljg2NiAwIDAgMS00LjgzMyA0LjExN1oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-wallet-round-svg.js
var require_coinbase_wallet_round_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-wallet-round-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMjMuODUyIDE0QTkuODM0IDkuODM0IDAgMCAxIDE0IDIzLjg1MiA5LjgzNCA5LjgzNCAwIDAgMSA0LjE0OCAxNCA5LjgzNCA5LjgzNCAwIDAgMSAxNCA0LjE0OCA5LjgzNCA5LjgzNCAwIDAgMSAyMy44NTIgMTRaIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjE4NSAxMi41MDRjMC0uNDU2IDAtLjcxLjA5OC0uODYyLjA5OC0uMTUyLjE5Ni0uMzA0LjM0My0uMzU1LjE5Ni0uMTAyLjM5Mi0uMTAyLjg4MS0uMTAyaDIuOTg2Yy40OSAwIC42ODYgMCAuODgyLjEwMi4xNDYuMTAxLjI5My4yMDMuMzQyLjM1NS4wOTguMjAzLjA5OC40MDYuMDk4Ljg2MnYyLjk5MmMwIC40NTcgMCAuNzEtLjA5OC44NjMtLjA5OC4xNTItLjE5NS4zMDQtLjM0Mi4zNTUtLjE5Ni4xMDEtLjM5Mi4xMDEtLjg4Mi4xMDFoLTIuOTg2Yy0uNDkgMC0uNjg1IDAtLjg4LS4xMDEtLjE0OC0uMTAyLS4yOTUtLjIwMy0uMzQ0LS4zNTUtLjA5OC0uMjAzLS4wOTgtLjQwNi0uMDk4LS44NjN2LTIuOTkyWiIgZmlsbD0iIzAwNTJGRiIvPjwvc3ZnPg==`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRCodeIcon.js
var require_QRCodeIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRCodeIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCodeIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function QRCodeIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M8.2271 1.77124L7.0271 1.77124V2.97124H8.2271V1.77124Z" }),
        (0, preact_1.h)("path", { d: "M5.44922 0.199219L5.44922 4.54922L9.79922 4.54922V0.199219L5.44922 0.199219ZM8.89922 3.64922L6.34922 3.64922L6.34922 1.09922L8.89922 1.09922V3.64922Z" }),
        (0, preact_1.h)("path", { d: "M2.97124 1.77124L1.77124 1.77124L1.77124 2.97124H2.97124V1.77124Z" }),
        (0, preact_1.h)("path", { d: "M0.199219 4.54922L4.54922 4.54922L4.54922 0.199219L0.199219 0.199219L0.199219 4.54922ZM1.09922 1.09922L3.64922 1.09922L3.64922 3.64922L1.09922 3.64922L1.09922 1.09922Z" }),
        (0, preact_1.h)("path", { d: "M2.97124 7.0271H1.77124L1.77124 8.2271H2.97124V7.0271Z" }),
        (0, preact_1.h)("path", { d: "M0.199219 9.79922H4.54922L4.54922 5.44922L0.199219 5.44922L0.199219 9.79922ZM1.09922 6.34922L3.64922 6.34922L3.64922 8.89922H1.09922L1.09922 6.34922Z" }),
        (0, preact_1.h)("path", { d: "M8.89922 7.39912H7.99922V5.40112H5.44922L5.44922 9.79912H6.34922L6.34922 6.30112H7.09922V8.29912H9.79922V5.40112H8.89922V7.39912Z" }),
        (0, preact_1.h)("path", { d: "M7.99912 8.89917H7.09912V9.79917H7.99912V8.89917Z" }),
        (0, preact_1.h)("path", { d: "M9.79917 8.89917H8.89917V9.79917H9.79917V8.89917Z" })
      );
    }
    exports.QRCodeIcon = QRCodeIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoCoinbase.js
var require_QRLogoCoinbase = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoCoinbase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var svg = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 100C77.6142 100 100 77.6142 100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100Z" fill="white"/>
        <path d="M50.512 94C74.2907 94 93.5673 74.5244 93.5673 50.5C93.5673 26.4756 74.2907 7 50.512 7C26.7332 7 7.45667 26.4756 7.45667 50.5C7.45667 74.5244 26.7332 94 50.512 94Z" fill="#0052FF"/>
        <path d="M50.6248 65.4335C42.3697 65.4335 35.8996 58.7469 35.8996 50.5C35.8996 42.2531 42.5928 35.5664 50.6248 35.5664C57.9873 35.5664 64.0111 40.9157 65.1267 48.0481H80.0749C78.7363 32.6688 66.0191 20.6328 50.6248 20.6328C34.3379 20.6328 20.9514 34.0062 20.9514 50.5C20.9514 66.9936 34.1148 80.3671 50.6248 80.3671C66.2422 80.3671 78.7363 68.331 80.0749 52.9516H65.1267C64.0111 60.0841 57.9873 65.4335 50.6248 65.4335Z" fill="white"/>
    </svg>
`;
    exports.default = svg;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoWallet.js
var require_QRLogoWallet = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="50" fill="white"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
    </svg>
`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/StatusDotIcon.js
var require_StatusDotIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/StatusDotIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusDotIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function StatusDotIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.29995 4.99995C2.29995 5.57985 1.82985 6.04995 1.24995 6.04995C0.670052 6.04995 0.199951 5.57985 0.199951 4.99995C0.199951 4.42005 0.670052 3.94995 1.24995 3.94995C1.82985 3.94995 2.29995 4.42005 2.29995 4.99995ZM4.99995 6.04995C5.57985 6.04995 6.04995 5.57985 6.04995 4.99995C6.04995 4.42005 5.57985 3.94995 4.99995 3.94995C4.42005 3.94995 3.94995 4.42005 3.94995 4.99995C3.94995 5.57985 4.42005 6.04995 4.99995 6.04995ZM8.74995 6.04995C9.32985 6.04995 9.79995 5.57985 9.79995 4.99995C9.79995 4.42005 9.32985 3.94995 8.74995 3.94995C8.17005 3.94995 7.69995 4.42005 7.69995 4.99995C7.69995 5.57985 8.17005 6.04995 8.74995 6.04995Z" })
      );
    }
    exports.StatusDotIcon = StatusDotIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js
var require_qrcode_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js"(exports, module) {
    function QR8bitByte(data) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.parsedData = [];
      for (var i4 = 0, l3 = this.data.length; i4 < l3; i4++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i4);
        if (code > 65536) {
          byteArray[0] = 240 | (code & 1835008) >>> 18;
          byteArray[1] = 128 | (code & 258048) >>> 12;
          byteArray[2] = 128 | (code & 4032) >>> 6;
          byteArray[3] = 128 | code & 63;
        } else if (code > 2048) {
          byteArray[0] = 224 | (code & 61440) >>> 12;
          byteArray[1] = 128 | (code & 4032) >>> 6;
          byteArray[2] = 128 | code & 63;
        } else if (code > 128) {
          byteArray[0] = 192 | (code & 1984) >>> 6;
          byteArray[1] = 128 | code & 63;
        } else {
          byteArray[0] = code;
        }
        this.parsedData.push(byteArray);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData);
      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }
    QR8bitByte.prototype = {
      getLength: function(buffer2) {
        return this.parsedData.length;
      },
      write: function(buffer2) {
        for (var i4 = 0, l3 = this.parsedData.length; i4 < l3; i4++) {
          buffer2.put(this.parsedData[i4], 8);
        }
      }
    };
    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    QRCodeModel.prototype = { addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    }, isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    }, getModuleCount: function() {
      return this.moduleCount;
    }, make: function() {
      this.makeImpl(false, this.getBestMaskPattern());
    }, makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    }, setupPositionProbePattern: function(row, col) {
      for (var r4 = -1; r4 <= 7; r4++) {
        if (row + r4 <= -1 || this.moduleCount <= row + r4)
          continue;
        for (var c3 = -1; c3 <= 7; c3++) {
          if (col + c3 <= -1 || this.moduleCount <= col + c3)
            continue;
          if (0 <= r4 && r4 <= 6 && (c3 == 0 || c3 == 6) || 0 <= c3 && c3 <= 6 && (r4 == 0 || r4 == 6) || 2 <= r4 && r4 <= 4 && 2 <= c3 && c3 <= 4) {
            this.modules[row + r4][col + c3] = true;
          } else {
            this.modules[row + r4][col + c3] = false;
          }
        }
      }
    }, getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i4 = 0; i4 < 8; i4++) {
        this.makeImpl(true, i4);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i4 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i4;
        }
      }
      return pattern;
    }, createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y3 = row * cs;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x3 = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x3, y3);
            qr_mc.lineTo(x3 + cs, y3);
            qr_mc.lineTo(x3 + cs, y3 + cs);
            qr_mc.lineTo(x3, y3 + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    }, setupTimingPattern: function() {
      for (var r4 = 8; r4 < this.moduleCount - 8; r4++) {
        if (this.modules[r4][6] != null) {
          continue;
        }
        this.modules[r4][6] = r4 % 2 == 0;
      }
      for (var c3 = 8; c3 < this.moduleCount - 8; c3++) {
        if (this.modules[6][c3] != null) {
          continue;
        }
        this.modules[6][c3] = c3 % 2 == 0;
      }
    }, setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i4 = 0; i4 < pos.length; i4++) {
        for (var j3 = 0; j3 < pos.length; j3++) {
          var row = pos[i4];
          var col = pos[j3];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r4 = -2; r4 <= 2; r4++) {
            for (var c3 = -2; c3 <= 2; c3++) {
              if (r4 == -2 || r4 == 2 || c3 == -2 || c3 == 2 || r4 == 0 && c3 == 0) {
                this.modules[row + r4][col + c3] = true;
              } else {
                this.modules[row + r4][col + c3] = false;
              }
            }
          }
        }
      }
    }, setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i4 = 0; i4 < 18; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        this.modules[Math.floor(i4 / 3)][i4 % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (var i4 = 0; i4 < 18; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        this.modules[i4 % 3 + this.moduleCount - 8 - 3][Math.floor(i4 / 3)] = mod;
      }
    }, setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      for (var i4 = 0; i4 < 15; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        if (i4 < 6) {
          this.modules[i4][8] = mod;
        } else if (i4 < 8) {
          this.modules[i4 + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i4][8] = mod;
        }
      }
      for (var i4 = 0; i4 < 15; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        if (i4 < 8) {
          this.modules[8][this.moduleCount - i4 - 1] = mod;
        } else if (i4 < 9) {
          this.modules[8][15 - i4 - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i4 - 1] = mod;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    }, mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c3 = 0; c3 < 2; c3++) {
            if (this.modules[row][col - c3] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c3);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c3] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };
    QRCodeModel.PAD0 = 236;
    QRCodeModel.PAD1 = 17;
    QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer2 = new QRBitBuffer();
      for (var i4 = 0; i4 < dataList.length; i4++) {
        var data = dataList[i4];
        buffer2.put(data.mode, 4);
        buffer2.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
        data.write(buffer2);
      }
      var totalDataCount = 0;
      for (var i4 = 0; i4 < rsBlocks.length; i4++) {
        totalDataCount += rsBlocks[i4].dataCount;
      }
      if (buffer2.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 != 0) {
        buffer2.putBit(false);
      }
      while (true) {
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD0, 8);
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD1, 8);
      }
      return QRCodeModel.createBytes(buffer2, rsBlocks);
    };
    QRCodeModel.createBytes = function(buffer2, rsBlocks) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r4 = 0; r4 < rsBlocks.length; r4++) {
        var dcCount = rsBlocks[r4].dataCount;
        var ecCount = rsBlocks[r4].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r4] = new Array(dcCount);
        for (var i4 = 0; i4 < dcdata[r4].length; i4++) {
          dcdata[r4][i4] = 255 & buffer2.buffer[i4 + offset];
        }
        offset += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r4], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r4] = new Array(rsPoly.getLength() - 1);
        for (var i4 = 0; i4 < ecdata[r4].length; i4++) {
          var modIndex = i4 + modPoly.getLength() - ecdata[r4].length;
          ecdata[r4][i4] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i4 = 0; i4 < rsBlocks.length; i4++) {
        totalCodeCount += rsBlocks[i4].totalCount;
      }
      var data = new Array(totalCodeCount);
      var index = 0;
      for (var i4 = 0; i4 < maxDcCount; i4++) {
        for (var r4 = 0; r4 < rsBlocks.length; r4++) {
          if (i4 < dcdata[r4].length) {
            data[index++] = dcdata[r4][i4];
          }
        }
      }
      for (var i4 = 0; i4 < maxEcCount; i4++) {
        for (var r4 = 0; r4 < rsBlocks.length; r4++) {
          if (i4 < ecdata[r4].length) {
            data[index++] = ecdata[r4][i4];
          }
        }
      }
      return data;
    };
    var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
    var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
    var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
    var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
      var d3 = data << 10;
      while (QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d3 ^= QRUtil.G15 << QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d3) ^ QRUtil.G15_MASK;
    }, getBCHTypeNumber: function(data) {
      var d3 = data << 12;
      while (QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d3 ^= QRUtil.G18 << QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d3;
    }, getBCHDigit: function(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    }, getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    }, getMask: function(maskPattern, i4, j3) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i4 + j3) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i4 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j3 % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i4 + j3) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i4 / 2) + Math.floor(j3 / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i4 * j3 % 2 + i4 * j3 % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i4 * j3 % 2 + i4 * j3 % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i4 * j3 % 3 + (i4 + j3) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }, getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a3 = new QRPolynomial([1], 0);
      for (var i4 = 0; i4 < errorCorrectLength; i4++) {
        a3 = a3.multiply(new QRPolynomial([1, QRMath.gexp(i4)], 0));
      }
      return a3;
    }, getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type);
      }
    }, getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r4 = -1; r4 <= 1; r4++) {
            if (row + r4 < 0 || moduleCount <= row + r4) {
              continue;
            }
            for (var c3 = -1; c3 <= 1; c3++) {
              if (col + c3 < 0 || moduleCount <= col + c3) {
                continue;
              }
              if (r4 == 0 && c3 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r4, col + c3)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count2 = 0;
          if (qrCode.isDark(row, col))
            count2++;
          if (qrCode.isDark(row + 1, col))
            count2++;
          if (qrCode.isDark(row, col + 1))
            count2++;
          if (qrCode.isDark(row + 1, col + 1))
            count2++;
          if (count2 == 0 || count2 == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };
    var QRMath = { glog: function(n2) {
      if (n2 < 1) {
        throw new Error("glog(" + n2 + ")");
      }
      return QRMath.LOG_TABLE[n2];
    }, gexp: function(n2) {
      while (n2 < 0) {
        n2 += 255;
      }
      while (n2 >= 256) {
        n2 -= 255;
      }
      return QRMath.EXP_TABLE[n2];
    }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
    for (i3 = 0; i3 < 8; i3++) {
      QRMath.EXP_TABLE[i3] = 1 << i3;
    }
    var i3;
    for (i3 = 8; i3 < 256; i3++) {
      QRMath.EXP_TABLE[i3] = QRMath.EXP_TABLE[i3 - 4] ^ QRMath.EXP_TABLE[i3 - 5] ^ QRMath.EXP_TABLE[i3 - 6] ^ QRMath.EXP_TABLE[i3 - 8];
    }
    var i3;
    for (i3 = 0; i3 < 255; i3++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i3]] = i3;
    }
    var i3;
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset++;
      }
      this.num = new Array(num.length - offset + shift);
      for (var i4 = 0; i4 < num.length - offset; i4++) {
        this.num[i4] = num[i4 + offset];
      }
    }
    QRPolynomial.prototype = { get: function(index) {
      return this.num[index];
    }, getLength: function() {
      return this.num.length;
    }, multiply: function(e3) {
      var num = new Array(this.getLength() + e3.getLength() - 1);
      for (var i4 = 0; i4 < this.getLength(); i4++) {
        for (var j3 = 0; j3 < e3.getLength(); j3++) {
          num[i4 + j3] ^= QRMath.gexp(QRMath.glog(this.get(i4)) + QRMath.glog(e3.get(j3)));
        }
      }
      return new QRPolynomial(num, 0);
    }, mod: function(e3) {
      if (this.getLength() - e3.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e3.get(0));
      var num = new Array(this.getLength());
      for (var i4 = 0; i4 < this.getLength(); i4++) {
        num[i4] = this.get(i4);
      }
      for (var i4 = 0; i4 < e3.getLength(); i4++) {
        num[i4] ^= QRMath.gexp(QRMath.glog(e3.get(i4)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e3);
    } };
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = [];
      for (var i4 = 0; i4 < length; i4++) {
        var count2 = rsBlock[i4 * 3 + 0];
        var totalCount = rsBlock[i4 * 3 + 1];
        var dataCount = rsBlock[i4 * 3 + 2];
        for (var j3 = 0; j3 < count2; j3++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    function QRBitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    QRBitBuffer.prototype = { get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    }, put: function(num, length) {
      for (var i4 = 0; i4 < length; i4++) {
        this.putBit((num >>> length - i4 - 1 & 1) == 1);
      }
    }, getLengthInBits: function() {
      return this.length;
    }, putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    } };
    var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(options) {
      var instance = this;
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      };
      if (typeof options === "string") {
        options = {
          content: options
        };
      }
      if (options) {
        for (var i4 in options) {
          this.options[i4] = options[i4];
        }
      }
      if (typeof this.options.content !== "string") {
        throw new Error("Expected 'content' as string!");
      }
      if (this.options.content.length === 0) {
        throw new Error("Expected 'content' to be non-empty!");
      }
      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }
      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }
      function _getErrorCorrectLevel(ecl2) {
        switch (ecl2) {
          case "L":
            return QRErrorCorrectLevel.L;
          case "M":
            return QRErrorCorrectLevel.M;
          case "Q":
            return QRErrorCorrectLevel.Q;
          case "H":
            return QRErrorCorrectLevel.H;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
      }
      function _getTypeNumber(content2, ecl2) {
        var length = _getUTF8Length(content2);
        var type2 = 1;
        var limit = 0;
        for (var i5 = 0, len = QRCodeLimitLength.length; i5 <= len; i5++) {
          var table = QRCodeLimitLength[i5];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length);
          }
          switch (ecl2) {
            case "L":
              limit = table[0];
              break;
            case "M":
              limit = table[1];
              break;
            case "Q":
              limit = table[2];
              break;
            case "H":
              limit = table[3];
              break;
            default:
              throw new Error("Unknwon error correction level: " + ecl2);
          }
          if (length <= limit) {
            break;
          }
          type2++;
        }
        if (type2 > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }
        return type2;
      }
      function _getUTF8Length(content2) {
        var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return result.length + (result.length != content2 ? 3 : 0);
      }
      var content = this.options.content;
      var type = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }
    QRCode.prototype.svg = function(opt) {
      var options = this.options || {};
      var modules = this.qrcode.modules;
      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
      var indent = pretty ? "  " : "";
      var EOL = pretty ? "\r\n" : "";
      var width = options.width;
      var height = options.height;
      var length = modules.length;
      var xsize = width / (length + 2 * options.padding);
      var ysize = height / (length + 2 * options.padding);
      var join = typeof options.join != "undefined" ? !!options.join : false;
      var swap = typeof options.swap != "undefined" ? !!options.swap : false;
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
      var modrect = "";
      var pathdata = "";
      for (var y3 = 0; y3 < length; y3++) {
        for (var x3 = 0; x3 < length; x3++) {
          var module2 = modules[x3][y3];
          if (module2) {
            var px = x3 * xsize + options.padding * xsize;
            var py = y3 * ysize + options.padding * ysize;
            if (swap) {
              var t3 = px;
              px = py;
              py = t3;
            }
            if (join) {
              var w3 = xsize + px;
              var h3 = ysize + py;
              px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
              py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
              w3 = Number.isInteger(w3) ? Number(w3) : w3.toFixed(2);
              h3 = Number.isInteger(h3) ? Number(h3) : h3.toFixed(2);
              pathdata += "M" + px + "," + py + " V" + h3 + " H" + w3 + " V" + py + " H" + px + " Z ";
            } else if (predefined) {
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
            } else {
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
            }
          }
        }
      }
      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if (this.options.image !== void 0 && this.options.image.svg) {
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = width / 2 - imgWidth / 2;
        const imgY = height / 2 - imgHeight / 2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL;
        imgSvg += "</svg>";
      }
      var svg = "";
      switch (opt.container) {
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</g>";
          break;
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
          break;
      }
      return svg;
    };
    module.exports = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var qrcode_svg_1 = __importDefault(require_qrcode_svg());
    var QRCode = (props) => {
      const [svg, setSvg] = (0, hooks_1.useState)("");
      (0, hooks_1.useEffect)(() => {
        var _a, _b;
        const qrcode = new qrcode_svg_1.default({
          content: props.content,
          background: props.bgColor || "#ffffff",
          color: props.fgColor || "#000000",
          container: "svg",
          ecl: "M",
          width: (_a = props.width) !== null && _a !== void 0 ? _a : 256,
          height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
          padding: 0,
          image: props.image
        });
        const base64 = Buffer.from(qrcode.svg(), "utf8").toString("base64");
        setSvg(`data:image/svg+xml;base64,${base64}`);
      });
      return svg ? (0, preact_1.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    exports.QRCode = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner-css.js
var require_Spinner_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner.js
var require_Spinner = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Spinner = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var Spinner_css_1 = __importDefault(require_Spinner_css());
    var Spinner = (props) => {
      var _a;
      const size = (_a = props.size) !== null && _a !== void 0 ? _a : 64;
      const color = props.color || "#000";
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-spinner" },
        (0, preact_1.h)("style", null, Spinner_css_1.default),
        (0, preact_1.h)(
          "svg",
          { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size, height: size } },
          (0, preact_1.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })
        )
      );
    };
    exports.Spinner = Spinner;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent-css.js
var require_ConnectContent_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-item.light.selected{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark.selected{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item.selected{border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent.js
var require_ConnectContent = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseAppSteps = exports.CoinbaseWalletSteps = exports.ConnectItem = exports.ConnectContent = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var util_1 = require_util3();
    var version_1 = require_version();
    var CloseIcon_1 = require_CloseIcon();
    var coinbase_round_svg_1 = __importDefault(require_coinbase_round_svg());
    var coinbase_wallet_round_svg_1 = __importDefault(require_coinbase_wallet_round_svg());
    var QRCodeIcon_1 = require_QRCodeIcon();
    var QRLogoCoinbase_1 = __importDefault(require_QRLogoCoinbase());
    var QRLogoWallet_1 = __importDefault(require_QRLogoWallet());
    var StatusDotIcon_1 = require_StatusDotIcon();
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var ConnectContent_css_1 = __importDefault(require_ConnectContent_css());
    var wallets = {
      "coinbase-wallet-app": {
        title: "Coinbase Wallet app",
        description: "Connect with your self-custody wallet",
        icon: coinbase_wallet_round_svg_1.default,
        steps: CoinbaseWalletSteps
      },
      "coinbase-app": {
        title: "Coinbase app",
        description: "Connect with your Coinbase account",
        icon: coinbase_round_svg_1.default,
        steps: CoinbaseAppSteps
      }
    };
    var makeQrCodeImage = (app) => {
      switch (app) {
        case "coinbase-app":
          return QRLogoCoinbase_1.default;
        case "coinbase-wallet-app":
        default:
          return QRLogoWallet_1.default;
      }
    };
    var makeIconColor = (theme) => {
      return theme === "light" ? "#FFFFFF" : "#0A0B0D";
    };
    function ConnectContent(props) {
      const { theme } = props;
      const [selected, setSelected] = (0, hooks_1.useState)("coinbase-wallet-app");
      const handleSelect = (0, hooks_1.useCallback)((id) => {
        setSelected(id);
      }, []);
      const qrUrl = (0, util_1.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection, props.version, props.chainId);
      const wallet = wallets[selected];
      if (!selected) {
        return null;
      }
      const WalletSteps = wallet.steps;
      const coinbaseApp = selected === "coinbase-app";
      return (0, preact_1.h)(
        "div",
        { "data-testid": "connect-content", class: (0, clsx_1.default)("-cbwsdk-connect-content", theme) },
        (0, preact_1.h)("style", null, ConnectContent_css_1.default),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-content-header" },
          (0, preact_1.h)("h2", { class: (0, clsx_1.default)("-cbwsdk-connect-content-heading", theme) }, "Scan to connect with one of our mobile apps"),
          props.onCancel && (0, preact_1.h)(
            "button",
            { type: "button", class: "-cbwsdk-cancel-button", onClick: props.onCancel },
            (0, preact_1.h)(CloseIcon_1.CloseIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
          )
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-content-layout" },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-connect-content-column-left" },
            (0, preact_1.h)("div", null, Object.entries(wallets).map(([key, value]) => {
              return (0, preact_1.h)(ConnectItem, { key, title: value.title, description: value.description, icon: value.icon, selected: selected === key, onClick: () => handleSelect(key), theme });
            })),
            coinbaseApp && (0, preact_1.h)(
              "div",
              { class: (0, clsx_1.default)("-cbwsdk-connect-content-update-app", theme) },
              "Dont see a ",
              (0, preact_1.h)("strong", null, "Scan"),
              " option? Update your Coinbase app to the latest version and try again."
            )
          ),
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-connect-content-column-right" },
            (0, preact_1.h)(
              "div",
              { class: "-cbwsdk-connect-content-qr-wrapper" },
              (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 200, height: 200, fgColor: "#000", bgColor: "transparent", image: {
                svg: makeQrCodeImage(selected),
                width: 25,
                height: 25
              } }),
              (0, preact_1.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: version_1.LIB_VERSION }),
              (0, preact_1.h)("input", { type: "hidden", value: qrUrl })
            ),
            (0, preact_1.h)(WalletSteps, { theme }),
            !props.isConnected && (0, preact_1.h)(
              "div",
              { "data-testid": "connecting-spinner", class: (0, clsx_1.default)("-cbwsdk-connect-content-qr-connecting", theme) },
              (0, preact_1.h)(Spinner_1.Spinner, { size: 36, color: theme === "dark" ? "#FFF" : "#000" }),
              (0, preact_1.h)("p", null, "Connecting...")
            )
          )
        )
      );
    }
    exports.ConnectContent = ConnectContent;
    function ConnectItem({ title, description, icon, selected, theme, onClick }) {
      return (0, preact_1.h)(
        "div",
        { onClick, class: (0, clsx_1.default)("-cbwsdk-connect-item", theme, { selected }) },
        (0, preact_1.h)(
          "div",
          null,
          (0, preact_1.h)("img", { src: icon, alt: title })
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-item-copy-wrapper" },
          (0, preact_1.h)("h3", { class: "-cbwsdk-connect-item-title" }, title),
          (0, preact_1.h)("p", { class: "-cbwsdk-connect-item-description" }, description)
        )
      );
    }
    exports.ConnectItem = ConnectItem;
    function CoinbaseWalletSteps({ theme }) {
      return (0, preact_1.h)(
        "ol",
        { class: "-cbwsdk-wallet-steps" },
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
        ),
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-wallet-steps-item-wrapper" },
            (0, preact_1.h)(
              "span",
              null,
              "Tap ",
              (0, preact_1.h)("strong", null, "Scan"),
              " "
            ),
            (0, preact_1.h)(
              "span",
              { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
              (0, preact_1.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) })
            )
          )
        )
      );
    }
    exports.CoinbaseWalletSteps = CoinbaseWalletSteps;
    function CoinbaseAppSteps({ theme }) {
      return (0, preact_1.h)(
        "ol",
        { class: "-cbwsdk-wallet-steps" },
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase app")
        ),
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-wallet-steps-item-wrapper" },
            (0, preact_1.h)(
              "span",
              null,
              "Tap ",
              (0, preact_1.h)("strong", null, "More")
            ),
            (0, preact_1.h)(
              "span",
              { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
              (0, preact_1.h)(StatusDotIcon_1.StatusDotIcon, { fill: makeIconColor(theme) })
            ),
            (0, preact_1.h)(
              "span",
              { class: "-cbwsdk-wallet-steps-pad-left" },
              "then ",
              (0, preact_1.h)("strong", null, "Scan")
            ),
            (0, preact_1.h)(
              "span",
              { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
              (0, preact_1.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) })
            )
          )
        )
      );
    }
    exports.CoinbaseAppSteps = CoinbaseAppSteps;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/ArrowLeftIcon.js
var require_ArrowLeftIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/ArrowLeftIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrowLeftIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function ArrowLeftIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
      );
    }
    exports.ArrowLeftIcon = ArrowLeftIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/LaptopIcon.js
var require_LaptopIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/LaptopIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LaptopIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function LaptopIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
        (0, preact_1.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
      );
    }
    exports.LaptopIcon = LaptopIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/SafeIcon.js
var require_SafeIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/SafeIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function SafeIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
      );
    }
    exports.SafeIcon = SafeIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent-css.js
var require_TryExtensionContent_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent.js
var require_TryExtensionContent = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TryExtensionContent = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var ArrowLeftIcon_1 = require_ArrowLeftIcon();
    var LaptopIcon_1 = require_LaptopIcon();
    var SafeIcon_1 = require_SafeIcon();
    var TryExtensionContent_css_1 = __importDefault(require_TryExtensionContent_css());
    function TryExtensionContent({ theme }) {
      const [clicked, setClicked] = (0, hooks_1.useState)(false);
      const handleInstallClick = (0, hooks_1.useCallback)(() => {
        window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
      }, []);
      const handleClick = (0, hooks_1.useCallback)(() => {
        if (clicked) {
          window.location.reload();
        } else {
          handleInstallClick();
          setClicked(true);
        }
      }, [handleInstallClick, clicked]);
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-try-extension", theme) },
        (0, preact_1.h)("style", null, TryExtensionContent_css_1.default),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-try-extension-column-half" },
          (0, preact_1.h)("h3", { class: (0, clsx_1.default)("-cbwsdk-try-extension-heading", theme) }, "Or try the Coinbase Wallet browser extension"),
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-try-extension-cta-wrapper" },
            (0, preact_1.h)("button", { class: (0, clsx_1.default)("-cbwsdk-try-extension-cta", theme), onClick: handleClick }, clicked ? "Refresh" : "Install"),
            (0, preact_1.h)("div", null, !clicked && (0, preact_1.h)(ArrowLeftIcon_1.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: theme === "light" ? "#0052FF" : "#588AF5" }))
          )
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-try-extension-column-half" },
          (0, preact_1.h)(
            "ul",
            { class: "-cbwsdk-try-extension-list" },
            (0, preact_1.h)(
              "li",
              { class: "-cbwsdk-try-extension-list-item" },
              (0, preact_1.h)(
                "div",
                { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
                (0, preact_1.h)(
                  "span",
                  { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-icon", theme) },
                  (0, preact_1.h)(LaptopIcon_1.LaptopIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
                )
              ),
              (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-copy", theme) }, "Connect with dapps with just one click on your desktop browser")
            ),
            (0, preact_1.h)(
              "li",
              { class: "-cbwsdk-try-extension-list-item" },
              (0, preact_1.h)(
                "div",
                { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
                (0, preact_1.h)(
                  "span",
                  { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-icon", theme) },
                  (0, preact_1.h)(SafeIcon_1.SafeIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
                )
              ),
              (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-copy", theme) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
            )
          )
        )
      );
    }
    exports.TryExtensionContent = TryExtensionContent;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog-css.js
var require_ConnectDialog_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog.js
var require_ConnectDialog = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectDialog = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var ConnectContent_1 = require_ConnectContent();
    var TryExtensionContent_1 = require_TryExtensionContent();
    var ConnectDialog_css_1 = __importDefault(require_ConnectDialog_css());
    var ConnectDialog = (props) => {
      const { isOpen, darkMode } = props;
      const [containerHidden, setContainerHidden] = (0, hooks_1.useState)(!isOpen);
      const [dialogHidden, setDialogHidden] = (0, hooks_1.useState)(!isOpen);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      const theme = darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-container", containerHidden && "-cbwsdk-connect-dialog-container-hidden") },
        (0, preact_1.h)("style", null, ConnectDialog_css_1.default),
        (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-backdrop", theme, dialogHidden && "-cbwsdk-connect-dialog-backdrop-hidden") }),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-dialog" },
          (0, preact_1.h)(
            "div",
            { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-box", dialogHidden && "-cbwsdk-connect-dialog-box-hidden") },
            !props.connectDisabled ? (0, preact_1.h)(ConnectContent_1.ConnectContent, { theme, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, linkAPIUrl: props.linkAPIUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection, chainId: props.chainId, onCancel: props.onCancel }) : null,
            (0, preact_1.h)(TryExtensionContent_1.TryExtensionContent, { theme })
          )
        )
      );
    };
    exports.ConnectDialog = ConnectDialog;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow/LinkFlow.js
var require_LinkFlow = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow/LinkFlow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkFlow = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var ConnectDialog_1 = require_ConnectDialog();
    var LinkFlow = class {
      constructor(options) {
        this.extensionUI$ = new rxjs_1.BehaviorSubject({});
        this.subscriptions = new rxjs_1.Subscription();
        this.isConnected = false;
        this.chainId = 1;
        this.isOpen = false;
        this.onCancel = null;
        this.root = null;
        this.connectDisabled = false;
        this.darkMode = options.darkMode;
        this.version = options.version;
        this.sessionId = options.sessionId;
        this.sessionSecret = options.sessionSecret;
        this.linkAPIUrl = options.linkAPIUrl;
        this.isParentConnection = options.isParentConnection;
        this.connected$ = options.connected$;
        this.chainId$ = options.chainId$;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-link-flow-root";
        el.appendChild(this.root);
        this.render();
        this.subscriptions.add(this.connected$.subscribe((v3) => {
          if (this.isConnected !== v3) {
            this.isConnected = v3;
            this.render();
          }
        }));
        this.subscriptions.add(this.chainId$.subscribe((chainId) => {
          if (this.chainId !== chainId) {
            this.chainId = chainId;
            this.render();
          }
        }));
      }
      detach() {
        var _a;
        if (!this.root) {
          return;
        }
        this.subscriptions.unsubscribe();
        (0, preact_1.render)(null, this.root);
        (_a = this.root.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.root);
      }
      setConnectDisabled(connectDisabled) {
        this.connectDisabled = connectDisabled;
      }
      open(options) {
        this.isOpen = true;
        this.onCancel = options.onCancel;
        this.render();
      }
      close() {
        this.isOpen = false;
        this.onCancel = null;
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        const subscription = this.extensionUI$.subscribe(() => {
          if (!this.root) {
            return;
          }
          (0, preact_1.render)((0, preact_1.h)(ConnectDialog_1.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
        });
        this.subscriptions.add(subscription);
      }
    };
    exports.LinkFlow = LinkFlow;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar-css.js
var require_Snackbar_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar.js
var require_Snackbar = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SnackbarInstance = exports.SnackbarContainer = exports.Snackbar = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var Snackbar_css_1 = __importDefault(require_Snackbar_css());
    var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    function makeSnackbarIcon(appSrc) {
      switch (appSrc) {
        case "coinbase-app":
          return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE0LjY3NCAxOC44NThjLTIuMDQ1IDAtMy42NDgtMS43MjItMy42NDgtMy44NDVzMS42NTktMy44NDUgMy42NDgtMy44NDVjMS44MjQgMCAzLjMxNyAxLjM3NyAzLjU5MyAzLjIxNGgzLjcwM2MtLjMzMS0zLjk2LTMuNDgyLTcuMDU5LTcuMjk2LTcuMDU5LTQuMDM0IDAtNy4zNSAzLjQ0My03LjM1IDcuNjkgMCA0LjI0NiAzLjI2IDcuNjkgNy4zNSA3LjY5IDMuODcgMCA2Ljk2NS0zLjEgNy4yOTYtNy4wNTloLTMuNzAzYy0uMjc2IDEuODM2LTEuNzY5IDMuMjE0LTMuNTkzIDMuMjE0WiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0wIDEwLjY3OGMwLTMuNzExIDAtNS41OTYuNzQyLTcuMDIzQTYuNTMyIDYuNTMyIDAgMCAxIDMuNjU1Ljc0MkM1LjA4MiAwIDYuOTY3IDAgMTAuNjc4IDBoNy45MzhjMy43MTEgMCA1LjU5NiAwIDcuMDIzLjc0MmE2LjUzMSA2LjUzMSAwIDAgMSAyLjkxMyAyLjkxM2MuNzQyIDEuNDI3Ljc0MiAzLjMxMi43NDIgNy4wMjN2Ny45MzhjMCAzLjcxMSAwIDUuNTk2LS43NDIgNy4wMjNhNi41MzEgNi41MzEgMCAwIDEtMi45MTMgMi45MTNjLTEuNDI3Ljc0Mi0zLjMxMi43NDItNy4wMjMuNzQyaC03LjkzOGMtMy43MTEgMC01LjU5NiAwLTcuMDIzLS43NDJhNi41MzEgNi41MzEgMCAwIDEtMi45MTMtMi45MTNDMCAyNC4yMTIgMCAyMi4zODQgMCAxOC42MTZ2LTcuOTM4WiIgZmlsbD0iIzAwNTJGRiIvPjxwYXRoIGQ9Ik0xNC42ODQgMTkuNzczYy0yLjcyNyAwLTQuODY0LTIuMjk1LTQuODY0LTUuMTI2IDAtMi44MzEgMi4yMS01LjEyNyA0Ljg2NC01LjEyNyAyLjQzMiAwIDQuNDIyIDEuODM3IDQuNzkgNC4yODVoNC45MzhjLS40NDItNS4yOC00LjY0My05LjQxMS05LjcyOC05LjQxMS01LjM4IDAtOS44MDIgNC41OS05LjgwMiAxMC4yNTMgMCA1LjY2MiA0LjM0OCAxMC4yNTMgOS44MDIgMTAuMjUzIDUuMTU5IDAgOS4yODYtNC4xMzIgOS43MjgtOS40MTFoLTQuOTM4Yy0uMzY4IDIuNDQ4LTIuMzU4IDQuMjg0LTQuNzkgNC4yODRaIiBmaWxsPSIjZmZmIi8+PC9zdmc+`;
        case "coinbase-wallet-app":
        default:
          return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
      }
    }
    var Snackbar = class {
      constructor(options) {
        this.items = /* @__PURE__ */ new Map();
        this.nextItemKey = 0;
        this.root = null;
        this.darkMode = options.darkMode;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-snackbar-root";
        el.appendChild(this.root);
        this.render();
      }
      presentItem(itemProps) {
        const key = this.nextItemKey++;
        this.items.set(key, itemProps);
        this.render();
        return () => {
          this.items.delete(key);
          this.render();
        };
      }
      clear() {
        this.items.clear();
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        (0, preact_1.render)((0, preact_1.h)(
          "div",
          null,
          (0, preact_1.h)(exports.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => (0, preact_1.h)(exports.SnackbarInstance, Object.assign({}, itemProps, { key }))))
        ), this.root);
      }
    };
    exports.Snackbar = Snackbar;
    var SnackbarContainer = (props) => (0, preact_1.h)(
      "div",
      { class: (0, clsx_1.default)("-cbwsdk-snackbar-container") },
      (0, preact_1.h)("style", null, Snackbar_css_1.default),
      (0, preact_1.h)("div", { class: "-cbwsdk-snackbar" }, props.children)
    );
    exports.SnackbarContainer = SnackbarContainer;
    var SnackbarInstance = ({ autoExpand, message, menuItems, appSrc }) => {
      const [hidden, setHidden] = (0, hooks_1.useState)(true);
      const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setHidden(false);
          }, 1),
          window.setTimeout(() => {
            setExpanded(true);
          }, 1e4)
        ];
        return () => {
          timers.forEach(window.clearTimeout);
        };
      });
      const toggleExpanded = () => {
        setExpanded(!expanded);
      };
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
          (0, preact_1.h)("img", { src: makeSnackbarIcon(appSrc), class: "-cbwsdk-snackbar-instance-header-cblogo" }),
          (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
          (0, preact_1.h)(
            "div",
            { class: "-gear-container" },
            !expanded && (0, preact_1.h)(
              "svg",
              { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
            ),
            (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
          )
        ),
        menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i3) => (0, preact_1.h)(
          "div",
          { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i3 },
          (0, preact_1.h)(
            "svg",
            { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
          ),
          (0, preact_1.h)("span", { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
        )))
      );
    };
    exports.SnackbarInstance = SnackbarInstance;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js
var require_cssReset_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js
var require_cssReset = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectCssReset = void 0;
    var cssReset_css_1 = __importDefault(require_cssReset_css());
    function injectCssReset() {
      const styleEl = document.createElement("style");
      styleEl.type = "text/css";
      styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
      document.documentElement.appendChild(styleEl);
    }
    exports.injectCssReset = injectCssReset;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js
var require_WalletSDKUI = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKUI = void 0;
    var LinkFlow_1 = require_LinkFlow();
    var Snackbar_1 = require_Snackbar();
    var cssReset_1 = require_cssReset();
    var WalletSDKUI = class {
      constructor(options) {
        this.standalone = null;
        this.attached = false;
        this.appSrc = null;
        this.snackbar = new Snackbar_1.Snackbar({
          darkMode: options.darkMode
        });
        this.linkFlow = new LinkFlow_1.LinkFlow({
          darkMode: options.darkMode,
          version: options.version,
          sessionId: options.session.id,
          sessionSecret: options.session.secret,
          linkAPIUrl: options.linkAPIUrl,
          connected$: options.connected$,
          chainId$: options.chainId$,
          isParentConnection: false
        });
      }
      attach() {
        if (this.attached) {
          throw new Error("Coinbase Wallet SDK UI is already attached");
        }
        const el = document.documentElement;
        const container = document.createElement("div");
        container.className = "-cbwsdk-css-reset";
        el.appendChild(container);
        this.linkFlow.attach(container);
        this.snackbar.attach(container);
        this.attached = true;
        (0, cssReset_1.injectCssReset)();
      }
      setConnectDisabled(connectDisabled) {
        this.linkFlow.setConnectDisabled(connectDisabled);
      }
      /* istanbul ignore next */
      addEthereumChain(_options) {
      }
      /* istanbul ignore next */
      watchAsset(_options) {
      }
      /* istanbul ignore next */
      switchEthereumChain(_options) {
      }
      requestEthereumAccounts(options) {
        this.linkFlow.open({ onCancel: options.onCancel });
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close();
      }
      /* istanbul ignore next */
      signEthereumMessage(_3) {
      }
      /* istanbul ignore next */
      signEthereumTransaction(_3) {
      }
      /* istanbul ignore next */
      submitEthereumTransaction(_3) {
      }
      /* istanbul ignore next */
      ethereumAddressFromSignedMessage(_3) {
      }
      showConnecting(options) {
        let snackbarProps;
        if (options.isUnlinkedErrorState) {
          snackbarProps = {
            autoExpand: true,
            message: "Connection lost",
            appSrc: this.appSrc,
            menuItems: [
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        } else {
          snackbarProps = {
            message: "Confirm on phone",
            appSrc: this.appSrc,
            menuItems: [
              {
                isRed: true,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: options.onCancel
              },
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        }
        return this.snackbar.presentItem(snackbarProps);
      }
      /* istanbul ignore next */
      setAppSrc(appSrc) {
        this.appSrc = appSrc;
      }
      /* istanbul ignore next */
      reloadUI() {
        document.location.reload();
      }
      /* istanbul ignore next */
      inlineAccountsResponse() {
        return false;
      }
      /* istanbul ignore next */
      inlineAddEthereumChain(_chainId) {
        return false;
      }
      /* istanbul ignore next */
      inlineWatchAsset() {
        return false;
      }
      /* istanbul ignore next */
      inlineSwitchEthereumChain() {
        return false;
      }
      /* istanbul ignore next */
      setStandalone(status) {
        this.standalone = status;
      }
      /* istanbul ignore next */
      isStandalone() {
        var _a;
        return (_a = this.standalone) !== null && _a !== void 0 ? _a : false;
      }
    };
    exports.WalletSDKUI = WalletSDKUI;
  }
});

// node_modules/bind-decorator/index.js
var require_bind_decorator = __commonJS({
  "node_modules/bind-decorator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants;
    (function(constants2) {
      constants2.typeOfFunction = "function";
      constants2.boolTrue = true;
    })(constants || (constants = {}));
    function bind(target, propertyKey, descriptor) {
      if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
        throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
      }
      return {
        configurable: constants.boolTrue,
        get: function() {
          var bound = descriptor.value.bind(this);
          Object.defineProperty(this, propertyKey, {
            value: bound,
            configurable: constants.boolTrue,
            writable: constants.boolTrue
          });
          return bound;
        }
      };
    }
    exports.bind = bind;
    exports.default = bind;
  }
});

// node_modules/rxjs/_esm5/internal/operators/audit.js
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator, AuditSubscriber;
var init_audit = __esm({
  "node_modules/rxjs/_esm5/internal/operators/audit.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    AuditOperator = function() {
      function AuditOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      AuditOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
      };
      return AuditOperator2;
    }();
    AuditSubscriber = function(_super) {
      __extends(AuditSubscriber2, _super);
      function AuditSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      AuditSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
          var duration = void 0;
          try {
            var durationSelector = this.durationSelector;
            duration = durationSelector(value);
          } catch (err) {
            return this.destination.error(err);
          }
          var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
          if (!innerSubscription || innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      };
      AuditSubscriber2.prototype.clearThrottle = function() {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
          this.remove(throttled);
          this.throttled = void 0;
          throttled.unsubscribe();
        }
        if (hasValue) {
          this.value = void 0;
          this.hasValue = false;
          this.destination.next(value);
        }
      };
      AuditSubscriber2.prototype.notifyNext = function() {
        this.clearThrottle();
      };
      AuditSubscriber2.prototype.notifyComplete = function() {
        this.clearThrottle();
      };
      return AuditSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}
var init_auditTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/auditTime.js"() {
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/_esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator, BufferSubscriber;
var init_buffer = __esm({
  "node_modules/rxjs/_esm5/internal/operators/buffer.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    BufferOperator = function() {
      function BufferOperator2(closingNotifier) {
        this.closingNotifier = closingNotifier;
      }
      BufferOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
      };
      return BufferOperator2;
    }();
    BufferSubscriber = function(_super) {
      __extends(BufferSubscriber2, _super);
      function BufferSubscriber2(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
        return _this;
      }
      BufferSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferSubscriber2.prototype.notifyNext = function() {
        var buffer2 = this.buffer;
        this.buffer = [];
        this.destination.next(buffer2);
      };
      return BufferSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator, BufferCountSubscriber, BufferSkipCountSubscriber;
var init_bufferCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    BufferCountOperator = function() {
      function BufferCountOperator2(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }
      BufferCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
      };
      return BufferCountOperator2;
    }();
    BufferCountSubscriber = function(_super) {
      __extends(BufferCountSubscriber2, _super);
      function BufferCountSubscriber2(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
      }
      BufferCountSubscriber2.prototype._next = function(value) {
        var buffer2 = this.buffer;
        buffer2.push(value);
        if (buffer2.length == this.bufferSize) {
          this.destination.next(buffer2);
          this.buffer = [];
        }
      };
      BufferCountSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2.length > 0) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      return BufferCountSubscriber2;
    }(Subscriber);
    BufferSkipCountSubscriber = function(_super) {
      __extends(BufferSkipCountSubscriber2, _super);
      function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
      }
      BufferSkipCountSubscriber2.prototype._next = function(value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count2 = _a.count;
        this.count++;
        if (count2 % startBufferEvery === 0) {
          buffers.push([]);
        }
        for (var i3 = buffers.length; i3--; ) {
          var buffer2 = buffers[i3];
          buffer2.push(value);
          if (buffer2.length === bufferSize) {
            buffers.splice(i3, 1);
            this.destination.next(buffer2);
          }
        }
      };
      BufferSkipCountSubscriber2.prototype._complete = function() {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
          var buffer2 = buffers.shift();
          if (buffer2.length > 0) {
            destination.next(buffer2);
          }
        }
        _super.prototype._complete.call(this);
      };
      return BufferSkipCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber;
  var prevContext = state.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state.context = subscriber.openContext();
    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
var BufferTimeOperator, Context, BufferTimeSubscriber;
var init_bufferTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferTime.js"() {
    init_tslib_es6();
    init_async();
    init_Subscriber();
    init_isScheduler();
    BufferTimeOperator = function() {
      function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }
      BufferTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
      };
      return BufferTimeOperator2;
    }();
    Context = function() {
      function Context2() {
        this.buffer = [];
      }
      return Context2;
    }();
    BufferTimeSubscriber = function(_super) {
      __extends(BufferTimeSubscriber2, _super);
      function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
          var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          var closeState = { subscriber: _this, context };
          var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
      }
      BufferTimeSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i3 = 0; i3 < len; i3++) {
          var context_1 = contexts[i3];
          var buffer2 = context_1.buffer;
          buffer2.push(value);
          if (buffer2.length == this.maxBufferSize) {
            filledBufferContext = context_1;
          }
        }
        if (filledBufferContext) {
          this.onBufferFull(filledBufferContext);
        }
      };
      BufferTimeSubscriber2.prototype._error = function(err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
      };
      BufferTimeSubscriber2.prototype._complete = function() {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
      };
      BufferTimeSubscriber2.prototype._unsubscribe = function() {
        this.contexts = null;
      };
      BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
          context = this.openContext();
          var bufferTimeSpan = this.bufferTimeSpan;
          var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
          this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
      };
      BufferTimeSubscriber2.prototype.openContext = function() {
        var context = new Context();
        this.contexts.push(context);
        return context;
      };
      BufferTimeSubscriber2.prototype.closeContext = function(context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
          contexts.splice(contexts.indexOf(context), 1);
        }
      };
      return BufferTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator, BufferToggleSubscriber;
var init_bufferToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferToggle.js"() {
    init_tslib_es6();
    init_Subscription();
    init_subscribeToResult();
    init_OuterSubscriber();
    BufferToggleOperator = function() {
      function BufferToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      BufferToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return BufferToggleOperator2;
    }();
    BufferToggleSubscriber = function(_super) {
      __extends(BufferToggleSubscriber2, _super);
      function BufferToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
      }
      BufferToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i3 = 0; i3 < len; i3++) {
          contexts[i3].buffer.push(value);
        }
      };
      BufferToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_1 = contexts.shift();
          context_1.subscription.unsubscribe();
          context_1.buffer = null;
          context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
      };
      BufferToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          this.destination.next(context_2.buffer);
          context_2.subscription.unsubscribe();
          context_2.buffer = null;
          context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
      };
      BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
      };
      BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.closeBuffer(innerSub.context);
      };
      BufferToggleSubscriber2.prototype.openBuffer = function(value) {
        try {
          var closingSelector = this.closingSelector;
          var closingNotifier = closingSelector.call(this, value);
          if (closingNotifier) {
            this.trySubscribe(closingNotifier);
          }
        } catch (err) {
          this._error(err);
        }
      };
      BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
        var contexts = this.contexts;
        if (contexts && context) {
          var buffer2 = context.buffer, subscription = context.subscription;
          this.destination.next(buffer2);
          contexts.splice(contexts.indexOf(context), 1);
          this.remove(subscription);
          subscription.unsubscribe();
        }
      };
      BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
        var contexts = this.contexts;
        var buffer2 = [];
        var subscription = new Subscription();
        var context = { buffer: buffer2, subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
          this.closeBuffer(context);
        } else {
          innerSubscription.context = context;
          this.add(innerSubscription);
          subscription.add(innerSubscription);
        }
      };
      return BufferToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator, BufferWhenSubscriber;
var init_bufferWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferWhen.js"() {
    init_tslib_es6();
    init_Subscription();
    init_innerSubscribe();
    BufferWhenOperator = function() {
      function BufferWhenOperator2(closingSelector) {
        this.closingSelector = closingSelector;
      }
      BufferWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
      };
      return BufferWhenOperator2;
    }();
    BufferWhenSubscriber = function(_super) {
      __extends(BufferWhenSubscriber2, _super);
      function BufferWhenSubscriber2(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
      }
      BufferWhenSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferWhenSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      BufferWhenSubscriber2.prototype._unsubscribe = function() {
        this.buffer = void 0;
        this.subscribing = false;
      };
      BufferWhenSubscriber2.prototype.notifyNext = function() {
        this.openBuffer();
      };
      BufferWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.subscribing) {
          this.complete();
        } else {
          this.openBuffer();
        }
      };
      BufferWhenSubscriber2.prototype.openBuffer = function() {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
          this.remove(closingSubscription);
          closingSubscription.unsubscribe();
        }
        var buffer2 = this.buffer;
        if (this.buffer) {
          this.destination.next(buffer2);
        }
        this.buffer = [];
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (err) {
          return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
        this.subscribing = false;
      };
      return BufferWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/catchError.js
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator, CatchSubscriber;
var init_catchError = __esm({
  "node_modules/rxjs/_esm5/internal/operators/catchError.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    CatchOperator = function() {
      function CatchOperator2(selector) {
        this.selector = selector;
      }
      CatchOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator2;
    }();
    CatchSubscriber = function(_super) {
      __extends(CatchSubscriber2, _super);
      function CatchSubscriber2(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
      }
      CatchSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var result = void 0;
          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            _super.prototype.error.call(this, err2);
            return;
          }
          this._unsubscribeAndRecycle();
          var innerSubscriber = new SimpleInnerSubscriber(this);
          this.add(innerSubscriber);
          var innerSubscription = innerSubscribe(result, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            this.add(innerSubscription);
          }
        }
      };
      return CatchSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineAll.js
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
var init_combineAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineAll.js"() {
    init_combineLatest();
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
var init_combineLatest2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineLatest.js"() {
    init_isArray();
    init_combineLatest();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concat.js
function concat2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat.apply(void 0, [source].concat(observables)));
  };
}
var init_concat2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concat.js"() {
    init_concat();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMap.js"() {
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
var init_concatMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMapTo.js"() {
    init_concatMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/count.js
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator, CountSubscriber;
var init_count = __esm({
  "node_modules/rxjs/_esm5/internal/operators/count.js"() {
    init_tslib_es6();
    init_Subscriber();
    CountOperator = function() {
      function CountOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      CountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      };
      return CountOperator2;
    }();
    CountSubscriber = function(_super) {
      __extends(CountSubscriber2, _super);
      function CountSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
      }
      CountSubscriber2.prototype._next = function(value) {
        if (this.predicate) {
          this._tryPredicate(value);
        } else {
          this.count++;
        }
      };
      CountSubscriber2.prototype._tryPredicate = function(value) {
        var result;
        try {
          result = this.predicate(value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.count++;
        }
      };
      CountSubscriber2.prototype._complete = function() {
        this.destination.next(this.count);
        this.destination.complete();
      };
      return CountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator, DebounceSubscriber;
var init_debounce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounce.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DebounceOperator = function() {
      function DebounceOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      DebounceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
      };
      return DebounceOperator2;
    }();
    DebounceSubscriber = function(_super) {
      __extends(DebounceSubscriber2, _super);
      function DebounceSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      DebounceSubscriber2.prototype._next = function(value) {
        try {
          var result = this.durationSelector.call(this, value);
          if (result) {
            this._tryNext(value, result);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DebounceSubscriber2.prototype._complete = function() {
        this.emitValue();
        this.destination.complete();
      };
      DebounceSubscriber2.prototype._tryNext = function(value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
          subscription.unsubscribe();
          this.remove(subscription);
        }
        subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
          this.add(this.durationSubscription = subscription);
        }
      };
      DebounceSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          var value = this.value;
          var subscription = this.durationSubscription;
          if (subscription) {
            this.durationSubscription = void 0;
            subscription.unsubscribe();
            this.remove(subscription);
          }
          this.value = void 0;
          this.hasValue = false;
          _super.prototype._next.call(this, value);
        }
      };
      return DebounceSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
function dispatchNext3(subscriber) {
  subscriber.debouncedNext();
}
var DebounceTimeOperator, DebounceTimeSubscriber;
var init_debounceTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounceTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    DebounceTimeOperator = function() {
      function DebounceTimeOperator2(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }
      DebounceTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator2;
    }();
    DebounceTimeSubscriber = function(_super) {
      __extends(DebounceTimeSubscriber2, _super);
      function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
      }
      DebounceTimeSubscriber2.prototype._next = function(value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext3, this.dueTime, this));
      };
      DebounceTimeSubscriber2.prototype._complete = function() {
        this.debouncedNext();
        this.destination.complete();
      };
      DebounceTimeSubscriber2.prototype.debouncedNext = function() {
        this.clearDebounce();
        if (this.hasValue) {
          var lastValue = this.lastValue;
          this.lastValue = null;
          this.hasValue = false;
          this.destination.next(lastValue);
        }
      };
      DebounceTimeSubscriber2.prototype.clearDebounce = function() {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
          this.remove(debouncedSubscription);
          debouncedSubscription.unsubscribe();
          this.debouncedSubscription = null;
        }
      };
      return DebounceTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator, DefaultIfEmptySubscriber;
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    DefaultIfEmptyOperator = function() {
      function DefaultIfEmptyOperator2(defaultValue) {
        this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator2;
    }();
    DefaultIfEmptySubscriber = function(_super) {
      __extends(DefaultIfEmptySubscriber2, _super);
      function DefaultIfEmptySubscriber2(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
      }
      DefaultIfEmptySubscriber2.prototype._next = function(value) {
        this.isEmpty = false;
        this.destination.next(value);
      };
      DefaultIfEmptySubscriber2.prototype._complete = function() {
        if (this.isEmpty) {
          this.destination.next(this.defaultValue);
        }
        this.destination.complete();
      };
      return DefaultIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/isDate.js
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
var init_isDate = __esm({
  "node_modules/rxjs/_esm5/internal/util/isDate.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/operators/delay.js
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator, DelaySubscriber, DelayMessage;
var init_delay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delay.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_Subscriber();
    init_Notification();
    DelayOperator = function() {
      function DelayOperator2(delay2, scheduler) {
        this.delay = delay2;
        this.scheduler = scheduler;
      }
      DelayOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator2;
    }();
    DelaySubscriber = function(_super) {
      __extends(DelaySubscriber2, _super);
      function DelaySubscriber2(destination, delay2, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay2;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
      }
      DelaySubscriber2.dispatch = function(state) {
        var source = state.source;
        var queue2 = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
          queue2.shift().notification.observe(destination);
        }
        if (queue2.length > 0) {
          var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
          this.schedule(state, delay_1);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      };
      DelaySubscriber2.prototype._schedule = function(scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler
        }));
      };
      DelaySubscriber2.prototype.scheduleNotification = function(notification) {
        if (this.errored === true) {
          return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
          this._schedule(scheduler);
        }
      };
      DelaySubscriber2.prototype._next = function(value) {
        this.scheduleNotification(Notification.createNext(value));
      };
      DelaySubscriber2.prototype._error = function(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
      };
      DelaySubscriber2.prototype._complete = function() {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
      };
      return DelaySubscriber2;
    }(Subscriber);
    DelayMessage = function() {
      function DelayMessage2(time, notification) {
        this.time = time;
        this.notification = notification;
      }
      return DelayMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator, DelayWhenSubscriber, SubscriptionDelayObservable, SubscriptionDelaySubscriber;
var init_delayWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delayWhen.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_OuterSubscriber();
    init_subscribeToResult();
    DelayWhenOperator = function() {
      function DelayWhenOperator2(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
      }
      DelayWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      };
      return DelayWhenOperator2;
    }();
    DelayWhenSubscriber = function(_super) {
      __extends(DelayWhenSubscriber2, _super);
      function DelayWhenSubscriber2(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
      }
      DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
        this._error(error);
      };
      DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
          this.destination.next(value);
        }
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        try {
          var delayNotifier = this.delayDurationSelector(value, index);
          if (delayNotifier) {
            this.tryDelay(delayNotifier, value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DelayWhenSubscriber2.prototype._complete = function() {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
      };
      DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
          this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
      };
      DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
          var destination = this.destination;
          destination.add(notifierSubscription);
          this.delayNotifierSubscriptions.push(notifierSubscription);
        }
      };
      DelayWhenSubscriber2.prototype.tryComplete = function() {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
          this.destination.complete();
        }
      };
      return DelayWhenSubscriber2;
    }(OuterSubscriber);
    SubscriptionDelayObservable = function(_super) {
      __extends(SubscriptionDelayObservable2, _super);
      function SubscriptionDelayObservable2(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
      }
      SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      };
      return SubscriptionDelayObservable2;
    }(Observable);
    SubscriptionDelaySubscriber = function(_super) {
      __extends(SubscriptionDelaySubscriber2, _super);
      function SubscriptionDelaySubscriber2(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
      }
      SubscriptionDelaySubscriber2.prototype._next = function(unused) {
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype._error = function(err) {
        this.unsubscribe();
        this.parent.error(err);
      };
      SubscriptionDelaySubscriber2.prototype._complete = function() {
        this.unsubscribe();
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
        if (!this.sourceSubscribed) {
          this.sourceSubscribed = true;
          this.unsubscribe();
          this.source.subscribe(this.parent);
        }
      };
      return SubscriptionDelaySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/dematerialize.js
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator, DeMaterializeSubscriber;
var init_dematerialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/dematerialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    DeMaterializeOperator = function() {
      function DeMaterializeOperator2() {
      }
      DeMaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
      };
      return DeMaterializeOperator2;
    }();
    DeMaterializeSubscriber = function(_super) {
      __extends(DeMaterializeSubscriber2, _super);
      function DeMaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      DeMaterializeSubscriber2.prototype._next = function(value) {
        value.observe(this.destination);
      };
      return DeMaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator, DistinctSubscriber;
var init_distinct = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinct.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DistinctOperator = function() {
      function DistinctOperator2(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
      }
      DistinctOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
      };
      return DistinctOperator2;
    }();
    DistinctSubscriber = function(_super) {
      __extends(DistinctSubscriber2, _super);
      function DistinctSubscriber2(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = /* @__PURE__ */ new Set();
        if (flushes) {
          _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
        }
        return _this;
      }
      DistinctSubscriber2.prototype.notifyNext = function() {
        this.values.clear();
      };
      DistinctSubscriber2.prototype.notifyError = function(error) {
        this._error(error);
      };
      DistinctSubscriber2.prototype._next = function(value) {
        if (this.keySelector) {
          this._useKeySelector(value);
        } else {
          this._finalizeNext(value, value);
        }
      };
      DistinctSubscriber2.prototype._useKeySelector = function(value) {
        var key;
        var destination = this.destination;
        try {
          key = this.keySelector(value);
        } catch (err) {
          destination.error(err);
          return;
        }
        this._finalizeNext(key, value);
      };
      DistinctSubscriber2.prototype._finalizeNext = function(key, value) {
        var values = this.values;
        if (!values.has(key)) {
          values.add(key);
          this.destination.next(value);
        }
      };
      return DistinctSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(compare, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator, DistinctUntilChangedSubscriber;
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js"() {
    init_tslib_es6();
    init_Subscriber();
    DistinctUntilChangedOperator = function() {
      function DistinctUntilChangedOperator2(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator2;
    }();
    DistinctUntilChangedSubscriber = function(_super) {
      __extends(DistinctUntilChangedSubscriber2, _super);
      function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === "function") {
          _this.compare = compare;
        }
        return _this;
      }
      DistinctUntilChangedSubscriber2.prototype.compare = function(x3, y3) {
        return x3 === y3;
      };
      DistinctUntilChangedSubscriber2.prototype._next = function(value) {
        var key;
        try {
          var keySelector = this.keySelector;
          key = keySelector ? keySelector(value) : value;
        } catch (err) {
          return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
          try {
            var compare = this.compare;
            result = compare(this.key, key);
          } catch (err) {
            return this.destination.error(err);
          }
        } else {
          this.hasKey = true;
        }
        if (!result) {
          this.key = key;
          this.destination.next(value);
        }
      };
      return DistinctUntilChangedSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x3, y3) {
    return compare ? compare(x3[key], y3[key]) : x3[key] === y3[key];
  });
}
var init_distinctUntilKeyChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_distinctUntilChanged();
  }
});

// node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
function defaultErrorFactory() {
  return new EmptyError();
}
var ThrowIfEmptyOperator, ThrowIfEmptySubscriber;
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js"() {
    init_tslib_es6();
    init_EmptyError();
    init_Subscriber();
    ThrowIfEmptyOperator = function() {
      function ThrowIfEmptyOperator2(errorFactory) {
        this.errorFactory = errorFactory;
      }
      ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
      };
      return ThrowIfEmptyOperator2;
    }();
    ThrowIfEmptySubscriber = function(_super) {
      __extends(ThrowIfEmptySubscriber2, _super);
      function ThrowIfEmptySubscriber2(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
      }
      ThrowIfEmptySubscriber2.prototype._next = function(value) {
        this.hasValue = true;
        this.destination.next(value);
      };
      ThrowIfEmptySubscriber2.prototype._complete = function() {
        if (!this.hasValue) {
          var err = void 0;
          try {
            err = this.errorFactory();
          } catch (e3) {
            err = e3;
          }
          this.destination.error(err);
        } else {
          return this.destination.complete();
        }
      };
      return ThrowIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/take.js
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator, TakeSubscriber;
var init_take = __esm({
  "node_modules/rxjs/_esm5/internal/operators/take.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeOperator = function() {
      function TakeOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator2;
    }();
    TakeSubscriber = function(_super) {
      __extends(TakeSubscriber2, _super);
      function TakeSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      TakeSubscriber2.prototype._next = function(value) {
        var total = this.total;
        var count2 = ++this.count;
        if (count2 <= total) {
          this.destination.next(value);
          if (count2 === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      };
      return TakeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v3, i3) {
      return i3 === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
var init_elementAt = __esm({
  "node_modules/rxjs/_esm5/internal/operators/elementAt.js"() {
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/rxjs/_esm5/internal/operators/endWith.js
function endWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, array));
  };
}
var init_endWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/endWith.js"() {
    init_concat();
    init_of();
  }
});

// node_modules/rxjs/_esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator, EverySubscriber;
var init_every = __esm({
  "node_modules/rxjs/_esm5/internal/operators/every.js"() {
    init_tslib_es6();
    init_Subscriber();
    EveryOperator = function() {
      function EveryOperator2(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }
      EveryOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
      };
      return EveryOperator2;
    }();
    EverySubscriber = function(_super) {
      __extends(EverySubscriber2, _super);
      function EverySubscriber2(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
      };
      EverySubscriber2.prototype._next = function(value) {
        var result = false;
        try {
          result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (!result) {
          this.notifyComplete(false);
        }
      };
      EverySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return EverySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaust.js
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator, SwitchFirstSubscriber;
var init_exhaust = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaust.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SwitchFirstOperator = function() {
      function SwitchFirstOperator2() {
      }
      SwitchFirstOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
      };
      return SwitchFirstOperator2;
    }();
    SwitchFirstSubscriber = function(_super) {
      __extends(SwitchFirstSubscriber2, _super);
      function SwitchFirstSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
      }
      SwitchFirstSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.hasSubscription = true;
          this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
        }
      };
      SwitchFirstSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
      };
      SwitchFirstSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return SwitchFirstSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a3, i3) {
        return from(project(a3, i3)).pipe(map(function(b3, ii) {
          return resultSelector(a3, b3, i3, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator, ExhaustMapSubscriber;
var init_exhaustMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaustMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    ExhaustMapOperator = function() {
      function ExhaustMapOperator2(project) {
        this.project = project;
      }
      ExhaustMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
      };
      return ExhaustMapOperator2;
    }();
    ExhaustMapSubscriber = function(_super) {
      __extends(ExhaustMapSubscriber2, _super);
      function ExhaustMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
      }
      ExhaustMapSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.tryNext(value);
        }
      };
      ExhaustMapSubscriber2.prototype.tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
      };
      ExhaustMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      ExhaustMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      ExhaustMapSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      ExhaustMapSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return ExhaustMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator, ExpandSubscriber;
var init_expand = __esm({
  "node_modules/rxjs/_esm5/internal/operators/expand.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    ExpandOperator = function() {
      function ExpandOperator2(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }
      ExpandOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
      };
      return ExpandOperator2;
    }();
    ExpandSubscriber = function(_super) {
      __extends(ExpandSubscriber2, _super);
      function ExpandSubscriber2(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
          _this.buffer = [];
        }
        return _this;
      }
      ExpandSubscriber2.dispatch = function(arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
      };
      ExpandSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (destination.closed) {
          this._complete();
          return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
          destination.next(value);
          try {
            var project = this.project;
            var result = project(value, index);
            if (!this.scheduler) {
              this.subscribeToProjection(result, value, index);
            } else {
              var state = { subscriber: this, result, value, index };
              var destination_1 = this.destination;
              destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
            }
          } catch (e3) {
            destination.error(e3);
          }
        } else {
          this.buffer.push(value);
        }
      };
      ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
      };
      ExpandSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
        this._next(innerValue);
      };
      ExpandSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2 && buffer2.length > 0) {
          this._next(buffer2.shift());
        }
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
      };
      return ExpandSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/finalize.js
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator, FinallySubscriber;
var init_finalize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/finalize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    FinallyOperator = function() {
      function FinallyOperator2(callback) {
        this.callback = callback;
      }
      FinallyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
      };
      return FinallyOperator2;
    }();
    FinallySubscriber = function(_super) {
      __extends(FinallySubscriber2, _super);
      function FinallySubscriber2(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
      }
      return FinallySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/find.js
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator, FindValueSubscriber;
var init_find = __esm({
  "node_modules/rxjs/_esm5/internal/operators/find.js"() {
    init_tslib_es6();
    init_Subscriber();
    FindValueOperator = function() {
      function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }
      FindValueOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
      };
      return FindValueOperator2;
    }();
    FindValueSubscriber = function(_super) {
      __extends(FindValueSubscriber2, _super);
      function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
      }
      FindValueSubscriber2.prototype.notifyComplete = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
      };
      FindValueSubscriber2.prototype._next = function(value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
          var result = predicate.call(thisArg || this, value, index, this.source);
          if (result) {
            this.notifyComplete(this.yieldIndex ? index : value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      FindValueSubscriber2.prototype._complete = function() {
        this.notifyComplete(this.yieldIndex ? -1 : void 0);
      };
      return FindValueSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
var init_findIndex = __esm({
  "node_modules/rxjs/_esm5/internal/operators/findIndex.js"() {
    init_find();
  }
});

// node_modules/rxjs/_esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v3, i3) {
      return predicate(v3, i3, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/rxjs/_esm5/internal/operators/first.js"() {
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator, IgnoreElementsSubscriber;
var init_ignoreElements = __esm({
  "node_modules/rxjs/_esm5/internal/operators/ignoreElements.js"() {
    init_tslib_es6();
    init_Subscriber();
    IgnoreElementsOperator = function() {
      function IgnoreElementsOperator2() {
      }
      IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
      };
      return IgnoreElementsOperator2;
    }();
    IgnoreElementsSubscriber = function(_super) {
      __extends(IgnoreElementsSubscriber2, _super);
      function IgnoreElementsSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IgnoreElementsSubscriber2.prototype._next = function(unused) {
      };
      return IgnoreElementsSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/isEmpty.js
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator, IsEmptySubscriber;
var init_isEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/isEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    IsEmptyOperator = function() {
      function IsEmptyOperator2() {
      }
      IsEmptyOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
      };
      return IsEmptyOperator2;
    }();
    IsEmptySubscriber = function(_super) {
      __extends(IsEmptySubscriber2, _super);
      function IsEmptySubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
        var destination = this.destination;
        destination.next(isEmpty2);
        destination.complete();
      };
      IsEmptySubscriber2.prototype._next = function(value) {
        this.notifyComplete(false);
      };
      IsEmptySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return IsEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator, TakeLastSubscriber;
var init_takeLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeLastOperator = function() {
      function TakeLastOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeLastOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
      };
      return TakeLastOperator2;
    }();
    TakeLastSubscriber = function(_super) {
      __extends(TakeLastSubscriber2, _super);
      function TakeLastSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
      }
      TakeLastSubscriber2.prototype._next = function(value) {
        var ring = this.ring;
        var total = this.total;
        var count2 = this.count++;
        if (ring.length < total) {
          ring.push(value);
        } else {
          var index = count2 % total;
          ring[index] = value;
        }
      };
      TakeLastSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        var count2 = this.count;
        if (count2 > 0) {
          var total = this.count >= this.total ? this.total : this.count;
          var ring = this.ring;
          for (var i3 = 0; i3 < total; i3++) {
            var idx = count2++ % total;
            destination.next(ring[idx]);
          }
        }
        destination.complete();
      };
      return TakeLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/last.js
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v3, i3) {
      return predicate(v3, i3, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/rxjs/_esm5/internal/operators/last.js"() {
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mapTo.js
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator, MapToSubscriber;
var init_mapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mapTo.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapToOperator = function() {
      function MapToOperator2(value) {
        this.value = value;
      }
      MapToOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
      };
      return MapToOperator2;
    }();
    MapToSubscriber = function(_super) {
      __extends(MapToSubscriber2, _super);
      function MapToSubscriber2(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
      }
      MapToSubscriber2.prototype._next = function(x3) {
        this.destination.next(this.value);
      };
      return MapToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/materialize.js
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator, MaterializeSubscriber;
var init_materialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/materialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    MaterializeOperator = function() {
      function MaterializeOperator2() {
      }
      MaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
      };
      return MaterializeOperator2;
    }();
    MaterializeSubscriber = function(_super) {
      __extends(MaterializeSubscriber2, _super);
      function MaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      MaterializeSubscriber2.prototype._next = function(value) {
        this.destination.next(Notification.createNext(value));
      };
      MaterializeSubscriber2.prototype._error = function(err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
      };
      MaterializeSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
      };
      return MaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator, ScanSubscriber;
var init_scan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/scan.js"() {
    init_tslib_es6();
    init_Subscriber();
    ScanOperator = function() {
      function ScanOperator2(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
          hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }
      ScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
      };
      return ScanOperator2;
    }();
    ScanSubscriber = function(_super) {
      __extends(ScanSubscriber2, _super);
      function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
      }
      Object.defineProperty(ScanSubscriber2.prototype, "seed", {
        get: function() {
          return this._seed;
        },
        set: function(value) {
          this.hasSeed = true;
          this._seed = value;
        },
        enumerable: true,
        configurable: true
      });
      ScanSubscriber2.prototype._next = function(value) {
        if (!this.hasSeed) {
          this.seed = value;
          this.destination.next(value);
        } else {
          return this._tryNext(value);
        }
      };
      ScanSubscriber2.prototype._tryNext = function(value) {
        var index = this.index++;
        var result;
        try {
          result = this.accumulator(this.seed, value, index);
        } catch (err) {
          this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
      };
      return ScanSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source);
  };
}
var init_reduce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/reduce.js"() {
    init_scan();
    init_takeLast();
    init_defaultIfEmpty();
    init_pipe();
  }
});

// node_modules/rxjs/_esm5/internal/operators/max.js
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x3, y3) {
    return comparer(x3, y3) > 0 ? x3 : y3;
  } : function(x3, y3) {
    return x3 > y3 ? x3 : y3;
  };
  return reduce(max2);
}
var init_max = __esm({
  "node_modules/rxjs/_esm5/internal/operators/max.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/merge.js
function merge2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge.apply(void 0, [source].concat(observables)));
  };
}
var init_merge2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/merge.js"() {
    init_merge();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js"() {
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator, MergeScanSubscriber;
var init_mergeScan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeScan.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    MergeScanOperator = function() {
      function MergeScanOperator2(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }
      MergeScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
      };
      return MergeScanOperator2;
    }();
    MergeScanSubscriber = function(_super) {
      __extends(MergeScanSubscriber2, _super);
      function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeScanSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          var index = this.index++;
          var destination = this.destination;
          var ish = void 0;
          try {
            var accumulator = this.accumulator;
            ish = accumulator(this.acc, value, index);
          } catch (e3) {
            return destination.error(e3);
          }
          this.active++;
          this._innerSub(ish);
        } else {
          this.buffer.push(value);
        }
      };
      MergeScanSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeScanSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
      };
      MergeScanSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
      };
      return MergeScanSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/min.js
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x3, y3) {
    return comparer(x3, y3) < 0 ? x3 : y3;
  } : function(x3, y3) {
    return x3 < y3 ? x3 : y3;
  };
  return reduce(min2);
}
var init_min = __esm({
  "node_modules/rxjs/_esm5/internal/operators/min.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator;
var init_multicast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/multicast.js"() {
    init_ConnectableObservable();
    MulticastOperator = function() {
      function MulticastOperator2(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }
      MulticastOperator2.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      };
      return MulticastOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
function onErrorResumeNext2() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator, OnErrorResumeNextSubscriber;
var init_onErrorResumeNext2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js"() {
    init_tslib_es6();
    init_from();
    init_isArray();
    init_innerSubscribe();
    OnErrorResumeNextOperator = function() {
      function OnErrorResumeNextOperator2(nextSources) {
        this.nextSources = nextSources;
      }
      OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
      };
      return OnErrorResumeNextOperator2;
    }();
    OnErrorResumeNextSubscriber = function(_super) {
      __extends(OnErrorResumeNextSubscriber2, _super);
      function OnErrorResumeNextSubscriber2(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
      }
      OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype._error = function(err) {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype._complete = function() {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
        var next = this.nextSources.shift();
        if (!!next) {
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = innerSubscribe(next, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        } else {
          this.destination.complete();
        }
      };
      return OnErrorResumeNextSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/pairwise.js
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator, PairwiseSubscriber;
var init_pairwise = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pairwise.js"() {
    init_tslib_es6();
    init_Subscriber();
    PairwiseOperator = function() {
      function PairwiseOperator2() {
      }
      PairwiseOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
      };
      return PairwiseOperator2;
    }();
    PairwiseSubscriber = function(_super) {
      __extends(PairwiseSubscriber2, _super);
      function PairwiseSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
      }
      PairwiseSubscriber2.prototype._next = function(value) {
        var pair;
        if (this.hasPrev) {
          pair = [this.prev, value];
        } else {
          this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
          this.destination.next(pair);
        }
      };
      return PairwiseSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/partition.js
function partition2(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not(predicate, thisArg))(source)
    ];
  };
}
var init_partition2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/partition.js"() {
    init_not();
    init_filter();
  }
});

// node_modules/rxjs/_esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x3) {
    var currentProp = x3;
    for (var i3 = 0; i3 < length; i3++) {
      var p3 = currentProp != null ? currentProp[props[i3]] : void 0;
      if (p3 !== void 0) {
        currentProp = p3;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
var init_pluck = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pluck.js"() {
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var init_publish = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publish.js"() {
    init_Subject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishBehavior.js
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
var init_publishBehavior = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishBehavior.js"() {
    init_BehaviorSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
var init_publishLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishLast.js"() {
    init_AsyncSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishReplay.js"() {
    init_ReplaySubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/race.js
function race2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race.apply(void 0, [source].concat(observables)));
  };
}
var init_race2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/race.js"() {
    init_isArray();
    init_race();
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeat.js
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator, RepeatSubscriber;
var init_repeat = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeat.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_empty();
    RepeatOperator = function() {
      function RepeatOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RepeatOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
      };
      return RepeatOperator2;
    }();
    RepeatSubscriber = function(_super) {
      __extends(RepeatSubscriber2, _super);
      function RepeatSubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RepeatSubscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          var _a = this, source = _a.source, count2 = _a.count;
          if (count2 === 0) {
            return _super.prototype.complete.call(this);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RepeatSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator, RepeatWhenSubscriber;
var init_repeatWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeatWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RepeatWhenOperator = function() {
      function RepeatWhenOperator2(notifier) {
        this.notifier = notifier;
      }
      RepeatWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
      };
      return RepeatWhenOperator2;
    }();
    RepeatWhenSubscriber = function(_super) {
      __extends(RepeatWhenSubscriber2, _super);
      function RepeatWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
      }
      RepeatWhenSubscriber2.prototype.notifyNext = function() {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
      };
      RepeatWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.sourceIsBeingSubscribedTo === false) {
          return _super.prototype.complete.call(this);
        }
      };
      RepeatWhenSubscriber2.prototype.complete = function() {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
          if (!this.retries) {
            this.subscribeToRetries();
          }
          if (!this.retriesSubscription || this.retriesSubscription.closed) {
            return _super.prototype.complete.call(this);
          }
          this._unsubscribeAndRecycle();
          this.notifications.next(void 0);
        }
      };
      RepeatWhenSubscriber2.prototype._unsubscribe = function() {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
          notifications.unsubscribe();
          this.notifications = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
      };
      RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
        this.notifications = new Subject();
        var retries;
        try {
          var notifier = this.notifier;
          retries = notifier(this.notifications);
        } catch (e3) {
          return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      };
      return RepeatWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retry.js
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator, RetrySubscriber;
var init_retry = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retry.js"() {
    init_tslib_es6();
    init_Subscriber();
    RetryOperator = function() {
      function RetryOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RetryOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      };
      return RetryOperator2;
    }();
    RetrySubscriber = function(_super) {
      __extends(RetrySubscriber2, _super);
      function RetrySubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RetrySubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _a = this, source = _a.source, count2 = _a.count;
          if (count2 === 0) {
            return _super.prototype.error.call(this, err);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RetrySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator, RetryWhenSubscriber;
var init_retryWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retryWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RetryWhenOperator = function() {
      function RetryWhenOperator2(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      };
      return RetryWhenOperator2;
    }();
    RetryWhenSubscriber = function(_super) {
      __extends(RetryWhenSubscriber2, _super);
      function RetryWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
      }
      RetryWhenSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var errors = this.errors;
          var retries = this.retries;
          var retriesSubscription = this.retriesSubscription;
          if (!retries) {
            errors = new Subject();
            try {
              var notifier = this.notifier;
              retries = notifier(errors);
            } catch (e3) {
              return _super.prototype.error.call(this, e3);
            }
            retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
          } else {
            this.errors = void 0;
            this.retriesSubscription = void 0;
          }
          this._unsubscribeAndRecycle();
          this.errors = errors;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors.next(err);
        }
      };
      RetryWhenSubscriber2.prototype._unsubscribe = function() {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
          errors.unsubscribe();
          this.errors = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RetryWhenSubscriber2.prototype.notifyNext = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
      };
      return RetryWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sample.js
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator, SampleSubscriber;
var init_sample = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sample.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SampleOperator = function() {
      function SampleOperator2(notifier) {
        this.notifier = notifier;
      }
      SampleOperator2.prototype.call = function(subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
      };
      return SampleOperator2;
    }();
    SampleSubscriber = function(_super) {
      __extends(SampleSubscriber2, _super);
      function SampleSubscriber2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
      }
      SampleSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
      };
      SampleSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.value);
        }
      };
      return SampleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
function dispatchNotification(state) {
  var subscriber = state.subscriber, period = state.period;
  subscriber.notifyNext();
  this.schedule(state, period);
}
var SampleTimeOperator, SampleTimeSubscriber;
var init_sampleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sampleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    SampleTimeOperator = function() {
      function SampleTimeOperator2(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
      }
      SampleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
      };
      return SampleTimeOperator2;
    }();
    SampleTimeSubscriber = function(_super) {
      __extends(SampleTimeSubscriber2, _super);
      function SampleTimeSubscriber2(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
        return _this;
      }
      SampleTimeSubscriber2.prototype._next = function(value) {
        this.lastValue = value;
        this.hasValue = true;
      };
      SampleTimeSubscriber2.prototype.notifyNext = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.lastValue);
        }
      };
      return SampleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator, SequenceEqualSubscriber, SequenceEqualCompareToSubscriber;
var init_sequenceEqual = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js"() {
    init_tslib_es6();
    init_Subscriber();
    SequenceEqualOperator = function() {
      function SequenceEqualOperator2(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
      }
      SequenceEqualOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
      };
      return SequenceEqualOperator2;
    }();
    SequenceEqualSubscriber = function(_super) {
      __extends(SequenceEqualSubscriber2, _super);
      function SequenceEqualSubscriber2(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
      }
      SequenceEqualSubscriber2.prototype._next = function(value) {
        if (this._oneComplete && this._b.length === 0) {
          this.emit(false);
        } else {
          this._a.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype._complete = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
        this.unsubscribe();
      };
      SequenceEqualSubscriber2.prototype.checkValues = function() {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
          var a3 = _a.shift();
          var b3 = _b.shift();
          var areEqual = false;
          try {
            areEqual = comparator ? comparator(a3, b3) : a3 === b3;
          } catch (e3) {
            this.destination.error(e3);
          }
          if (!areEqual) {
            this.emit(false);
          }
        }
      };
      SequenceEqualSubscriber2.prototype.emit = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
      };
      SequenceEqualSubscriber2.prototype.nextB = function(value) {
        if (this._oneComplete && this._a.length === 0) {
          this.emit(false);
        } else {
          this._b.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype.completeB = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
      };
      return SequenceEqualSubscriber2;
    }(Subscriber);
    SequenceEqualCompareToSubscriber = function(_super) {
      __extends(SequenceEqualCompareToSubscriber2, _super);
      function SequenceEqualCompareToSubscriber2(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
      }
      SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
        this.parent.nextB(value);
      };
      SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
        this.parent.error(err);
        this.unsubscribe();
      };
      SequenceEqualCompareToSubscriber2.prototype._complete = function() {
        this.parent.completeB();
        this.unsubscribe();
      };
      return SequenceEqualCompareToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/share.js
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
var init_share = __esm({
  "node_modules/rxjs/_esm5/internal/operators/share.js"() {
    init_multicast();
    init_refCount();
    init_Subject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a) {
  var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
var init_shareReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/shareReplay.js"() {
    init_ReplaySubject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/single.js
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator, SingleSubscriber;
var init_single = __esm({
  "node_modules/rxjs/_esm5/internal/operators/single.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_EmptyError();
    SingleOperator = function() {
      function SingleOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      SingleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
      };
      return SingleOperator2;
    }();
    SingleSubscriber = function(_super) {
      __extends(SingleSubscriber2, _super);
      function SingleSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
      }
      SingleSubscriber2.prototype.applySingleValue = function(value) {
        if (this.seenValue) {
          this.destination.error("Sequence contains more than one element");
        } else {
          this.seenValue = true;
          this.singleValue = value;
        }
      };
      SingleSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        if (this.predicate) {
          this.tryNext(value, index);
        } else {
          this.applySingleValue(value);
        }
      };
      SingleSubscriber2.prototype.tryNext = function(value, index) {
        try {
          if (this.predicate(value, index, this.source)) {
            this.applySingleValue(value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      SingleSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        if (this.index > 0) {
          destination.next(this.seenValue ? this.singleValue : void 0);
          destination.complete();
        } else {
          destination.error(new EmptyError());
        }
      };
      return SingleSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skip.js
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator, SkipSubscriber;
var init_skip = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skip.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipOperator = function() {
      function SkipOperator2(total) {
        this.total = total;
      }
      SkipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
      };
      return SkipOperator2;
    }();
    SkipSubscriber = function(_super) {
      __extends(SkipSubscriber2, _super);
      function SkipSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      SkipSubscriber2.prototype._next = function(x3) {
        if (++this.count > this.total) {
          this.destination.next(x3);
        }
      };
      return SkipSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipLast.js
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator, SkipLastSubscriber;
var init_skipLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    SkipLastOperator = function() {
      function SkipLastOperator2(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      SkipLastOperator2.prototype.call = function(subscriber, source) {
        if (this._skipCount === 0) {
          return source.subscribe(new Subscriber(subscriber));
        } else {
          return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
      };
      return SkipLastOperator2;
    }();
    SkipLastSubscriber = function(_super) {
      __extends(SkipLastSubscriber2, _super);
      function SkipLastSubscriber2(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
      }
      SkipLastSubscriber2.prototype._next = function(value) {
        var skipCount = this._skipCount;
        var count2 = this._count++;
        if (count2 < skipCount) {
          this._ring[count2] = value;
        } else {
          var currentIndex = count2 % skipCount;
          var ring = this._ring;
          var oldValue = ring[currentIndex];
          ring[currentIndex] = value;
          this.destination.next(oldValue);
        }
      };
      return SkipLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator, SkipUntilSubscriber;
var init_skipUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SkipUntilOperator = function() {
      function SkipUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      SkipUntilOperator2.prototype.call = function(destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      };
      return SkipUntilOperator2;
    }();
    SkipUntilSubscriber = function(_super) {
      __extends(SkipUntilSubscriber2, _super);
      function SkipUntilSubscriber2(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          _this.add(innerSubscription);
          _this.innerSubscription = innerSubscription;
        }
        return _this;
      }
      SkipUntilSubscriber2.prototype._next = function(value) {
        if (this.hasValue) {
          _super.prototype._next.call(this, value);
        }
      };
      SkipUntilSubscriber2.prototype.notifyNext = function() {
        this.hasValue = true;
        if (this.innerSubscription) {
          this.innerSubscription.unsubscribe();
        }
      };
      SkipUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return SkipUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator, SkipWhileSubscriber;
var init_skipWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipWhileOperator = function() {
      function SkipWhileOperator2(predicate) {
        this.predicate = predicate;
      }
      SkipWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator2;
    }();
    SkipWhileSubscriber = function(_super) {
      __extends(SkipWhileSubscriber2, _super);
      function SkipWhileSubscriber2(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
      }
      SkipWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (this.skipping) {
          this.tryCallPredicate(value);
        }
        if (!this.skipping) {
          destination.next(value);
        }
      };
      SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
        try {
          var result = this.predicate(value, this.index++);
          this.skipping = Boolean(result);
        } catch (err) {
          this.destination.error(err);
        }
      };
      return SkipWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/startWith.js
function startWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  var scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return function(source) {
      return concat(array, source, scheduler);
    };
  } else {
    return function(source) {
      return concat(array, source);
    };
  }
}
var init_startWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/startWith.js"() {
    init_concat();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
var SubscribeOnObservable;
var init_SubscribeOnObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js"() {
    init_tslib_es6();
    init_Observable();
    init_asap();
    init_isNumeric();
    SubscribeOnObservable = function(_super) {
      __extends(SubscribeOnObservable2, _super);
      function SubscribeOnObservable2(source, delayTime, scheduler) {
        if (delayTime === void 0) {
          delayTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
          _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
          _this.scheduler = asap;
        }
        return _this;
      }
      SubscribeOnObservable2.create = function(source, delay2, scheduler) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        return new SubscribeOnObservable2(source, delay2, scheduler);
      };
      SubscribeOnObservable2.dispatch = function(arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
      };
      SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
        var delay2 = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
          source,
          subscriber
        });
      };
      return SubscribeOnObservable2;
    }(Observable);
  }
});

// node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator;
var init_subscribeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/subscribeOn.js"() {
    init_SubscribeOnObservable();
    SubscribeOnOperator = function() {
      function SubscribeOnOperator2(scheduler, delay2) {
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      SubscribeOnOperator2.prototype.call = function(subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
      };
      return SubscribeOnOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a3, i3) {
        return from(project(a3, i3)).pipe(map(function(b3, ii) {
          return resultSelector(a3, b3, i3, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator, SwitchMapSubscriber;
var init_switchMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    SwitchMapOperator = function() {
      function SwitchMapOperator2(project) {
        this.project = project;
      }
      SwitchMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator2;
    }();
    SwitchMapSubscriber = function(_super) {
      __extends(SwitchMapSubscriber2, _super);
      function SwitchMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
      }
      SwitchMapSubscriber2.prototype._next = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (error) {
          this.destination.error(error);
          return;
        }
        this._innerSub(result);
      };
      SwitchMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
          destination.add(this.innerSubscription);
        }
      };
      SwitchMapSubscriber2.prototype._complete = function() {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
          _super.prototype._complete.call(this);
        }
        this.unsubscribe();
      };
      SwitchMapSubscriber2.prototype._unsubscribe = function() {
        this.innerSubscription = void 0;
      };
      SwitchMapSubscriber2.prototype.notifyComplete = function() {
        this.innerSubscription = void 0;
        if (this.isStopped) {
          _super.prototype._complete.call(this);
        }
      };
      SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      return SwitchMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}
var init_switchAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchAll.js"() {
    init_switchMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMapTo.js"() {
    init_switchMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator, TakeUntilSubscriber;
var init_takeUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    TakeUntilOperator = function() {
      function TakeUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      TakeUntilOperator2.prototype.call = function(subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
          takeUntilSubscriber.add(notifierSubscription);
          return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
      };
      return TakeUntilOperator2;
    }();
    TakeUntilSubscriber = function(_super) {
      __extends(TakeUntilSubscriber2, _super);
      function TakeUntilSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
      }
      TakeUntilSubscriber2.prototype.notifyNext = function() {
        this.seenValue = true;
        this.complete();
      };
      TakeUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return TakeUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator, TakeWhileSubscriber;
var init_takeWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    TakeWhileOperator = function() {
      function TakeWhileOperator2(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
      }
      TakeWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
      };
      return TakeWhileOperator2;
    }();
    TakeWhileSubscriber = function(_super) {
      __extends(TakeWhileSubscriber2, _super);
      function TakeWhileSubscriber2(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
      }
      TakeWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        var result;
        try {
          result = this.predicate(value, this.index++);
        } catch (err) {
          destination.error(err);
          return;
        }
        this.nextOrComplete(value, result);
      };
      TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
          destination.next(value);
        } else {
          if (this.inclusive) {
            destination.next(value);
          }
          destination.complete();
        }
      };
      return TakeWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/tap.js
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator, TapSubscriber;
var init_tap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/tap.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_noop();
    init_isFunction();
    DoOperator = function() {
      function DoOperator2(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }
      DoOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator2;
    }();
    TapSubscriber = function(_super) {
      __extends(TapSubscriber2, _super);
      function TapSubscriber2(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
          _this._context = _this;
          _this._tapNext = observerOrNext;
        } else if (observerOrNext) {
          _this._context = observerOrNext;
          _this._tapNext = observerOrNext.next || noop;
          _this._tapError = observerOrNext.error || noop;
          _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
      }
      TapSubscriber2.prototype._next = function(value) {
        try {
          this._tapNext.call(this._context, value);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(value);
      };
      TapSubscriber2.prototype._error = function(err) {
        try {
          this._tapError.call(this._context, err);
        } catch (err2) {
          this.destination.error(err2);
          return;
        }
        this.destination.error(err);
      };
      TapSubscriber2.prototype._complete = function() {
        try {
          this._tapComplete.call(this._context);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        return this.destination.complete();
      };
      return TapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var defaultThrottleConfig, ThrottleOperator, ThrottleSubscriber;
var init_throttle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttle.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    ThrottleOperator = function() {
      function ThrottleOperator2(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
      };
      return ThrottleOperator2;
    }();
    ThrottleSubscriber = function(_super) {
      __extends(ThrottleSubscriber2, _super);
      function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
      }
      ThrottleSubscriber2.prototype._next = function(value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
          if (this._leading) {
            this.send();
          } else {
            this.throttle(value);
          }
        }
      };
      ThrottleSubscriber2.prototype.send = function() {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
          this.destination.next(_sendValue);
          this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = void 0;
      };
      ThrottleSubscriber2.prototype.throttle = function(value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
          this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
        }
      };
      ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
        try {
          return this.durationSelector(value);
        } catch (err) {
          this.destination.error(err);
          return null;
        }
      };
      ThrottleSubscriber2.prototype.throttlingDone = function() {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
          _throttled.unsubscribe();
        }
        this._throttled = void 0;
        if (_trailing) {
          this.send();
        }
      };
      ThrottleSubscriber2.prototype.notifyNext = function() {
        this.throttlingDone();
      };
      ThrottleSubscriber2.prototype.notifyComplete = function() {
        this.throttlingDone();
      };
      return ThrottleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
function dispatchNext4(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
var ThrottleTimeOperator, ThrottleTimeSubscriber;
var init_throttleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    init_throttle();
    ThrottleTimeOperator = function() {
      function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      };
      return ThrottleTimeOperator2;
    }();
    ThrottleTimeSubscriber = function(_super) {
      __extends(ThrottleTimeSubscriber2, _super);
      function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
      }
      ThrottleTimeSubscriber2.prototype._next = function(value) {
        if (this.throttled) {
          if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        } else {
          this.add(this.throttled = this.scheduler.schedule(dispatchNext4, this.duration, { subscriber: this }));
          if (this.leading) {
            this.destination.next(value);
          } else if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        }
      };
      ThrottleTimeSubscriber2.prototype._complete = function() {
        if (this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this.destination.complete();
        } else {
          this.destination.complete();
        }
      };
      ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
        var throttled = this.throttled;
        if (throttled) {
          if (this.trailing && this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
          }
          throttled.unsubscribe();
          this.remove(throttled);
          this.throttled = null;
        }
      };
      return ThrottleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a, value) {
        var current = _a.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a) {
        var current = _a.current, last2 = _a.last, value = _a.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeInterval.js"() {
    init_async();
    init_scan();
    init_defer();
    init_map();
    TimeInterval = function() {
      function TimeInterval2(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator, TimeoutWithSubscriber;
var init_timeoutWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeoutWith.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_innerSubscribe();
    TimeoutWithOperator = function() {
      function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }
      TimeoutWithOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      };
      return TimeoutWithOperator2;
    }();
    TimeoutWithSubscriber = function(_super) {
      __extends(TimeoutWithSubscriber2, _super);
      function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
      }
      TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
      };
      TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
        var action = this.action;
        if (action) {
          this.action = action.schedule(this, this.waitFor);
        } else {
          this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
        }
      };
      TimeoutWithSubscriber2.prototype._next = function(value) {
        if (!this.absoluteTimeout) {
          this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
      };
      TimeoutWithSubscriber2.prototype._unsubscribe = function() {
        this.action = void 0;
        this.scheduler = null;
        this.withObservable = null;
      };
      return TimeoutWithSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeout.js
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
var init_timeout = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeout.js"() {
    init_async();
    init_TimeoutError();
    init_timeoutWith();
    init_throwError();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timestamp.js
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp;
var init_timestamp = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timestamp.js"() {
    init_async();
    init_map();
    Timestamp = function() {
      function Timestamp2(value, timestamp2) {
        this.value = value;
        this.timestamp = timestamp2;
      }
      return Timestamp2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/toArray.js
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
var init_toArray = __esm({
  "node_modules/rxjs/_esm5/internal/operators/toArray.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/window.js
function window2(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator(windowBoundaries));
  };
}
var WindowOperator, WindowSubscriber;
var init_window = __esm({
  "node_modules/rxjs/_esm5/internal/operators/window.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    WindowOperator = function() {
      function WindowOperator3(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
          windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
      };
      return WindowOperator3;
    }();
    WindowSubscriber = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function() {
        this.openWindow();
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function() {
        this._complete();
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
      };
      WindowSubscriber3.prototype._unsubscribe = function() {
        this.window = null;
      };
      WindowSubscriber3.prototype.openWindow = function() {
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
      };
      return WindowSubscriber3;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator, WindowCountSubscriber;
var init_windowCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subject();
    WindowCountOperator = function() {
      function WindowCountOperator2(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }
      WindowCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
      };
      return WindowCountOperator2;
    }();
    WindowCountSubscriber = function(_super) {
      __extends(WindowCountSubscriber2, _super);
      function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
      }
      WindowCountSubscriber2.prototype._next = function(value) {
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i3 = 0; i3 < len && !this.closed; i3++) {
          windows[i3].next(value);
        }
        var c3 = this.count - windowSize + 1;
        if (c3 >= 0 && c3 % startWindowEvery === 0 && !this.closed) {
          windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
          var window_1 = new Subject();
          windows.push(window_1);
          destination.next(window_1);
        }
      };
      WindowCountSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().error(err);
          }
        }
        this.destination.error(err);
      };
      WindowCountSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().complete();
          }
        }
        this.destination.complete();
      };
      WindowCountSubscriber2.prototype._unsubscribe = function() {
        this.count = 0;
        this.windows = null;
      };
      return WindowCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window3 = state.window;
  if (window3) {
    subscriber.closeWindow(window3);
  }
  state.window = subscriber.openWindow();
  this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
  var window3 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window3, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
  var subscriber = state.subscriber, window3 = state.window, context = state.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window3);
}
var WindowTimeOperator, CountedSubject, WindowTimeSubscriber;
var init_windowTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowTime.js"() {
    init_tslib_es6();
    init_Subject();
    init_async();
    init_Subscriber();
    init_isNumeric();
    init_isScheduler();
    WindowTimeOperator = function() {
      function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }
      WindowTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
      };
      return WindowTimeOperator2;
    }();
    CountedSubject = function(_super) {
      __extends(CountedSubject2, _super);
      function CountedSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
      }
      CountedSubject2.prototype.next = function(value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
      };
      Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
        get: function() {
          return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
      });
      return CountedSubject2;
    }(Subject);
    WindowTimeSubscriber = function(_super) {
      __extends(WindowTimeSubscriber2, _super);
      function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window3 = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          var closeState = { subscriber: _this, window: window3, context: null };
          var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
          _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          var timeSpanOnlyState = { subscriber: _this, window: window3, windowTimeSpan };
          _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
      }
      WindowTimeSubscriber2.prototype._next = function(value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i3 = 0; i3 < len; i3++) {
          var window_1 = windows[i3];
          if (!window_1.closed) {
            window_1.next(value);
            if (window_1.numberOfNextedValues >= this.maxWindowSize) {
              this.closeWindow(window_1);
            }
          }
        }
      };
      WindowTimeSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        this.destination.error(err);
      };
      WindowTimeSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        while (windows.length > 0) {
          var window_2 = windows.shift();
          if (!window_2.closed) {
            window_2.complete();
          }
        }
        this.destination.complete();
      };
      WindowTimeSubscriber2.prototype.openWindow = function() {
        var window3 = new CountedSubject();
        this.windows.push(window3);
        var destination = this.destination;
        destination.next(window3);
        return window3;
      };
      WindowTimeSubscriber2.prototype.closeWindow = function(window3) {
        window3.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window3), 1);
      };
      return WindowTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator, WindowToggleSubscriber;
var init_windowToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowToggle.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowToggleOperator = function() {
      function WindowToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      WindowToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return WindowToggleOperator2;
    }();
    WindowToggleSubscriber = function(_super) {
      __extends(WindowToggleSubscriber2, _super);
      function WindowToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
      }
      WindowToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        if (contexts) {
          var len = contexts.length;
          for (var i3 = 0; i3 < len; i3++) {
            contexts[i3].window.next(value);
          }
        }
      };
      WindowToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_1 = contexts[index];
            context_1.window.error(err);
            context_1.subscription.unsubscribe();
          }
        }
        _super.prototype._error.call(this, err);
      };
      WindowToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_2 = contexts[index];
            context_2.window.complete();
            context_2.subscription.unsubscribe();
          }
        }
        _super.prototype._complete.call(this);
      };
      WindowToggleSubscriber2.prototype._unsubscribe = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_3 = contexts[index];
            context_3.window.unsubscribe();
            context_3.subscription.unsubscribe();
          }
        }
      };
      WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
          var closingNotifier = void 0;
          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector(innerValue);
          } catch (e3) {
            return this.error(e3);
          }
          var window_1 = new Subject();
          var subscription = new Subscription();
          var context_4 = { window: window_1, subscription };
          this.contexts.push(context_4);
          var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context_4;
            subscription.add(innerSubscription);
          }
          this.destination.next(window_1);
        } else {
          this.closeWindow(this.contexts.indexOf(outerValue));
        }
      };
      WindowToggleSubscriber2.prototype.notifyError = function(err) {
        this.error(err);
      };
      WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
        if (inner !== this.openSubscription) {
          this.closeWindow(this.contexts.indexOf(inner.context));
        }
      };
      WindowToggleSubscriber2.prototype.closeWindow = function(index) {
        if (index === -1) {
          return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window3 = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window3.complete();
        subscription.unsubscribe();
      };
      return WindowToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator2(closingSelector));
  };
}
var WindowOperator2, WindowSubscriber2;
var init_windowWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowOperator2 = function() {
      function WindowOperator3(closingSelector) {
        this.closingSelector = closingSelector;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowSubscriber2(subscriber, this.closingSelector));
      };
      return WindowOperator3;
    }();
    WindowSubscriber2 = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function(innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype.unsubscribeClosingNotification = function() {
        if (this.closingNotification) {
          this.closingNotification.unsubscribe();
        }
      };
      WindowSubscriber3.prototype.openWindow = function(innerSub) {
        if (innerSub === void 0) {
          innerSub = null;
        }
        if (innerSub) {
          this.remove(innerSub);
          innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var window3 = this.window = new Subject();
        this.destination.next(window3);
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (e3) {
          this.destination.error(e3);
          this.window.error(e3);
          return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
      };
      return WindowSubscriber3;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator, WithLatestFromSubscriber;
var init_withLatestFrom = __esm({
  "node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js"() {
    init_tslib_es6();
    init_OuterSubscriber();
    init_subscribeToResult();
    WithLatestFromOperator = function() {
      function WithLatestFromOperator2(observables, project) {
        this.observables = observables;
        this.project = project;
      }
      WithLatestFromOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
      };
      return WithLatestFromOperator2;
    }();
    WithLatestFromSubscriber = function(_super) {
      __extends(WithLatestFromSubscriber2, _super);
      function WithLatestFromSubscriber2(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i3 = 0; i3 < len; i3++) {
          _this.toRespond.push(i3);
        }
        for (var i3 = 0; i3 < len; i3++) {
          var observable2 = observables[i3];
          _this.add(subscribeToResult(_this, observable2, void 0, i3));
        }
        return _this;
      }
      WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
          var found = toRespond.indexOf(outerIndex);
          if (found !== -1) {
            toRespond.splice(found, 1);
          }
        }
      };
      WithLatestFromSubscriber2.prototype.notifyComplete = function() {
      };
      WithLatestFromSubscriber2.prototype._next = function(value) {
        if (this.toRespond.length === 0) {
          var args = [value].concat(this.values);
          if (this.project) {
            this._tryProject(args);
          } else {
            this.destination.next(args);
          }
        }
      };
      WithLatestFromSubscriber2.prototype._tryProject = function(args) {
        var result;
        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return WithLatestFromSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/zip.js
function zip2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip.apply(void 0, [source].concat(observables)));
  };
}
var init_zip2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zip.js"() {
    init_zip();
  }
});

// node_modules/rxjs/_esm5/internal/operators/zipAll.js
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var init_zipAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zipAll.js"() {
    init_zip();
  }
});

// node_modules/rxjs/_esm5/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  audit: () => audit,
  auditTime: () => auditTime,
  buffer: () => buffer,
  bufferCount: () => bufferCount,
  bufferTime: () => bufferTime,
  bufferToggle: () => bufferToggle,
  bufferWhen: () => bufferWhen,
  catchError: () => catchError,
  combineAll: () => combineAll,
  combineLatest: () => combineLatest2,
  concat: () => concat2,
  concatAll: () => concatAll,
  concatMap: () => concatMap,
  concatMapTo: () => concatMapTo,
  count: () => count,
  debounce: () => debounce,
  debounceTime: () => debounceTime,
  defaultIfEmpty: () => defaultIfEmpty,
  delay: () => delay,
  delayWhen: () => delayWhen,
  dematerialize: () => dematerialize,
  distinct: () => distinct,
  distinctUntilChanged: () => distinctUntilChanged,
  distinctUntilKeyChanged: () => distinctUntilKeyChanged,
  elementAt: () => elementAt,
  endWith: () => endWith,
  every: () => every,
  exhaust: () => exhaust,
  exhaustMap: () => exhaustMap,
  expand: () => expand,
  filter: () => filter,
  finalize: () => finalize,
  find: () => find,
  findIndex: () => findIndex,
  first: () => first,
  flatMap: () => flatMap,
  groupBy: () => groupBy,
  ignoreElements: () => ignoreElements,
  isEmpty: () => isEmpty,
  last: () => last,
  map: () => map,
  mapTo: () => mapTo,
  materialize: () => materialize,
  max: () => max,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeMap: () => mergeMap,
  mergeMapTo: () => mergeMapTo,
  mergeScan: () => mergeScan,
  min: () => min,
  multicast: () => multicast,
  observeOn: () => observeOn,
  onErrorResumeNext: () => onErrorResumeNext2,
  pairwise: () => pairwise,
  partition: () => partition2,
  pluck: () => pluck,
  publish: () => publish,
  publishBehavior: () => publishBehavior,
  publishLast: () => publishLast,
  publishReplay: () => publishReplay,
  race: () => race2,
  reduce: () => reduce,
  refCount: () => refCount,
  repeat: () => repeat,
  repeatWhen: () => repeatWhen,
  retry: () => retry,
  retryWhen: () => retryWhen,
  sample: () => sample,
  sampleTime: () => sampleTime,
  scan: () => scan,
  sequenceEqual: () => sequenceEqual,
  share: () => share,
  shareReplay: () => shareReplay,
  single: () => single,
  skip: () => skip,
  skipLast: () => skipLast,
  skipUntil: () => skipUntil,
  skipWhile: () => skipWhile,
  startWith: () => startWith,
  subscribeOn: () => subscribeOn,
  switchAll: () => switchAll,
  switchMap: () => switchMap,
  switchMapTo: () => switchMapTo,
  take: () => take,
  takeLast: () => takeLast,
  takeUntil: () => takeUntil,
  takeWhile: () => takeWhile,
  tap: () => tap,
  throttle: () => throttle,
  throttleTime: () => throttleTime,
  throwIfEmpty: () => throwIfEmpty,
  timeInterval: () => timeInterval,
  timeout: () => timeout,
  timeoutWith: () => timeoutWith,
  timestamp: () => timestamp,
  toArray: () => toArray,
  window: () => window2,
  windowCount: () => windowCount,
  windowTime: () => windowTime,
  windowToggle: () => windowToggle,
  windowWhen: () => windowWhen,
  withLatestFrom: () => withLatestFrom,
  zip: () => zip2,
  zipAll: () => zipAll
});
var init_operators = __esm({
  "node_modules/rxjs/_esm5/operators/index.js"() {
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatest2();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNext2();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js
var require_ClientMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientMessagePublishEvent = exports.ClientMessageSetSessionConfig = exports.ClientMessageGetSessionConfig = exports.ClientMessageIsLinked = exports.ClientMessageHostSession = void 0;
    function ClientMessageHostSession(params) {
      return Object.assign({ type: "HostSession" }, params);
    }
    exports.ClientMessageHostSession = ClientMessageHostSession;
    function ClientMessageIsLinked(params) {
      return Object.assign({ type: "IsLinked" }, params);
    }
    exports.ClientMessageIsLinked = ClientMessageIsLinked;
    function ClientMessageGetSessionConfig(params) {
      return Object.assign({ type: "GetSessionConfig" }, params);
    }
    exports.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
    function ClientMessageSetSessionConfig(params) {
      return Object.assign({ type: "SetSessionConfig" }, params);
    }
    exports.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
    function ClientMessagePublishEvent(params) {
      return Object.assign({ type: "PublishEvent" }, params);
    }
    exports.ClientMessagePublishEvent = ClientMessagePublishEvent;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js
var require_RxWebSocket = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RxWebSocket = exports.ConnectionState = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
      ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
    var RxWebSocket = class {
      /**
       * Constructor
       * @param url WebSocket server URL
       * @param [WebSocketClass] Custom WebSocket implementation
       */
      constructor(url, WebSocketClass = WebSocket) {
        this.WebSocketClass = WebSocketClass;
        this.webSocket = null;
        this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);
        this.incomingDataSubject = new rxjs_1.Subject();
        this.url = url.replace(/^http/, "ws");
      }
      /**
       * Make a websocket connection
       * @returns an Observable that completes when connected
       */
      connect() {
        if (this.webSocket) {
          return (0, rxjs_1.throwError)(new Error("webSocket object is not null"));
        }
        return new rxjs_1.Observable((obs) => {
          let webSocket;
          try {
            this.webSocket = webSocket = new this.WebSocketClass(this.url);
          } catch (err) {
            obs.error(err);
            return;
          }
          this.connectionStateSubject.next(ConnectionState.CONNECTING);
          webSocket.onclose = (evt) => {
            this.clearWebSocket();
            obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
            this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
          };
          webSocket.onopen = (_3) => {
            obs.next();
            obs.complete();
            this.connectionStateSubject.next(ConnectionState.CONNECTED);
          };
          webSocket.onmessage = (evt) => {
            this.incomingDataSubject.next(evt.data);
          };
        }).pipe((0, operators_1.take)(1));
      }
      /**
       * Disconnect from server
       */
      disconnect() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.clearWebSocket();
        this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        try {
          webSocket.close();
        } catch (_a) {
        }
      }
      /**
       * Emit current connection state and subsequent changes
       * @returns an Observable for the connection state
       */
      get connectionState$() {
        return this.connectionStateSubject.asObservable();
      }
      /**
       * Emit incoming data from server
       * @returns an Observable for the data received
       */
      get incomingData$() {
        return this.incomingDataSubject.asObservable();
      }
      /**
       * Emit incoming JSON data from server. non-JSON data are ignored
       * @returns an Observable for parsed JSON data
       */
      get incomingJSONData$() {
        return this.incomingData$.pipe((0, operators_1.flatMap)((m3) => {
          let j3;
          try {
            j3 = JSON.parse(m3);
          } catch (err) {
            return (0, rxjs_1.empty)();
          }
          return (0, rxjs_1.of)(j3);
        }));
      }
      /**
       * Send data to server
       * @param data text to send
       */
      sendData(data) {
        const { webSocket } = this;
        if (!webSocket) {
          throw new Error("websocket is not connected");
        }
        webSocket.send(data);
      }
      clearWebSocket() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.webSocket = null;
        webSocket.onclose = null;
        webSocket.onerror = null;
        webSocket.onmessage = null;
        webSocket.onopen = null;
      }
    };
    exports.RxWebSocket = RxWebSocket;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js
var require_ServerMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isServerMessageFail = void 0;
    function isServerMessageFail(msg) {
      return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
    }
    exports.isServerMessageFail = isServerMessageFail;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js
var require_WalletSDKConnection = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKConnection = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var Session_1 = require_Session();
    var types_1 = require_types();
    var ClientMessage_1 = require_ClientMessage();
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var RxWebSocket_1 = require_RxWebSocket();
    var ServerMessage_1 = require_ServerMessage();
    var HEARTBEAT_INTERVAL = 1e4;
    var REQUEST_TIMEOUT = 6e4;
    var WalletSDKConnection = class {
      /**
       * Constructor
       * @param sessionId Session ID
       * @param sessionKey Session Key
       * @param linkAPIUrl Coinbase Wallet link server URL
       * @param [WebSocketClass] Custom WebSocket implementation
       */
      constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {
        this.sessionId = sessionId;
        this.sessionKey = sessionKey;
        this.diagnostic = diagnostic;
        this.subscriptions = new rxjs_1.Subscription();
        this.destroyed = false;
        this.lastHeartbeatResponse = 0;
        this.nextReqId = (0, types_1.IntNumber)(1);
        this.connectedSubject = new rxjs_1.BehaviorSubject(false);
        this.linkedSubject = new rxjs_1.BehaviorSubject(false);
        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);
        const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + "/rpc", WebSocketClass);
        this.ws = ws;
        this.subscriptions.add(ws.connectionState$.pipe(
          (0, operators_1.tap)((state) => {
            var _a;
            return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {
              state,
              sessionIdHash: Session_1.Session.hash(sessionId)
            });
          }),
          // ignore initial DISCONNECTED state
          (0, operators_1.skip)(1),
          // if DISCONNECTED and not destroyed
          (0, operators_1.filter)((cs) => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),
          // wait 5 seconds
          (0, operators_1.delay)(5e3),
          // check whether it's destroyed again
          (0, operators_1.filter)((_3) => !this.destroyed),
          // reconnect
          (0, operators_1.flatMap)((_3) => ws.connect()),
          (0, operators_1.retry)()
        ).subscribe());
        this.subscriptions.add(ws.connectionState$.pipe(
          // ignore initial DISCONNECTED and CONNECTING states
          (0, operators_1.skip)(2),
          (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(
            () => cs === RxWebSocket_1.ConnectionState.CONNECTED,
            // if CONNECTED, authenticate, and then check link status
            this.authenticate().pipe((0, operators_1.tap)((_3) => this.sendIsLinked()), (0, operators_1.tap)((_3) => this.sendGetSessionConfig()), (0, operators_1.map)((_3) => true)),
            // if not CONNECTED, emit false immediately
            (0, rxjs_1.of)(false)
          )),
          (0, operators_1.distinctUntilChanged)(),
          (0, operators_1.catchError)((_3) => (0, rxjs_1.of)(false))
        ).subscribe((connected) => this.connectedSubject.next(connected)));
        this.subscriptions.add(ws.connectionState$.pipe(
          // ignore initial DISCONNECTED state
          (0, operators_1.skip)(1),
          (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(
            () => cs === RxWebSocket_1.ConnectionState.CONNECTED,
            // if CONNECTED, start the heartbeat timer
            (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)
          ))
        ).subscribe((i3) => (
          // first timer event updates lastHeartbeat timestamp
          // subsequent calls send heartbeat message
          i3 === 0 ? this.updateLastHeartbeat() : this.heartbeat()
        )));
        this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)((m3) => m3 === "h")).subscribe((_3) => this.updateLastHeartbeat()));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m3) => ["IsLinkedOK", "Linked"].includes(m3.type))).subscribe((m3) => {
          var _a;
          const msg = m3;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            linked: msg.linked,
            type: m3.type,
            onlineGuests: msg.onlineGuests
          });
          this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
        }));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m3) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m3.type))).subscribe((m3) => {
          var _a;
          const msg = m3;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
          });
          this.sessionConfigSubject.next({
            webhookId: msg.webhookId,
            webhookUrl: msg.webhookUrl,
            metadata: msg.metadata
          });
        }));
      }
      /**
       * Make a connection to the server
       */
      connect() {
        var _a;
        if (this.destroyed) {
          throw new Error("instance is destroyed");
        }
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.ws.connect().subscribe();
      }
      /**
       * Terminate connection, and mark as destroyed. To reconnect, create a new
       * instance of WalletSDKConnection
       */
      destroy() {
        var _a;
        this.subscriptions.unsubscribe();
        this.ws.disconnect();
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.destroyed = true;
      }
      get isDestroyed() {
        return this.destroyed;
      }
      /**
       * Emit true if connected and authenticated, else false
       * @returns an Observable
       */
      get connected$() {
        return this.connectedSubject.asObservable();
      }
      /**
       * Emit once connected
       * @returns an Observable
       */
      get onceConnected$() {
        return this.connected$.pipe((0, operators_1.filter)((v3) => v3), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      /**
       * Emit true if linked (a guest has joined before)
       * @returns an Observable
       */
      get linked$() {
        return this.linkedSubject.asObservable();
      }
      /**
       * Emit once when linked
       * @returns an Observable
       */
      get onceLinked$() {
        return this.linked$.pipe((0, operators_1.filter)((v3) => v3), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      /**
       * Emit current session config if available, and subsequent updates
       * @returns an Observable for the session config
       */
      get sessionConfig$() {
        return this.sessionConfigSubject.asObservable();
      }
      /**
       * Emit incoming Event messages
       * @returns an Observable for the messages
       */
      get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)((m3) => {
          if (m3.type !== "Event") {
            return false;
          }
          const sme = m3;
          return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
        }), (0, operators_1.map)((m3) => m3));
      }
      /**
       * Set session metadata in SessionConfig object
       * @param key
       * @param value
       * @returns an Observable that completes when successful
       */
      setSessionMetadata(key, value) {
        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          metadata: { [key]: value }
        });
        return this.onceConnected$.pipe((0, operators_1.flatMap)((_3) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to set session metadata");
          }
        }));
      }
      /**
       * Publish an event and emit event ID when successful
       * @param event event name
       * @param data event data
       * @param callWebhook whether the webhook should be invoked
       * @returns an Observable that emits event ID when successful
       */
      publishEvent(event, data, callWebhook = false) {
        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          event,
          data,
          callWebhook
        });
        return this.onceLinked$.pipe((0, operators_1.flatMap)((_3) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to publish event");
          }
          return res.eventId;
        }));
      }
      sendData(message) {
        this.ws.sendData(JSON.stringify(message));
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now();
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
          this.ws.disconnect();
          return;
        }
        try {
          this.ws.sendData("h");
        } catch (_a) {
        }
      }
      makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
        const reqId = message.id;
        try {
          this.sendData(message);
        } catch (err) {
          return (0, rxjs_1.throwError)(err);
        }
        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout2, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)((m3) => m3.id === reqId), (0, operators_1.take)(1));
      }
      authenticate() {
        const msg = (0, ClientMessage_1.ClientMessageHostSession)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          sessionKey: this.sessionKey
        });
        return this.makeRequest(msg).pipe((0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to authentcate");
          }
        }));
      }
      sendIsLinked() {
        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
      sendGetSessionConfig() {
        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
    };
    exports.WalletSDKConnection = WalletSDKConnection;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletUIError.js
var require_WalletUIError = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletUIError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletUIError = void 0;
    var WalletUIError = class extends Error {
      constructor(message, errorCode) {
        super(message);
        this.message = message;
        this.errorCode = errorCode;
      }
    };
    exports.WalletUIError = WalletUIError;
    WalletUIError.UserRejectedRequest = new WalletUIError("User rejected request");
    WalletUIError.SwitchEthereumChainUnsupportedChainId = new WalletUIError("Unsupported chainId", 4902);
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js
var require_aes256gcm = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = void 0;
    var util_1 = require_util3();
    async function encrypt(plainText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      const ivBytes = crypto.getRandomValues(new Uint8Array(12));
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const enc = new TextEncoder();
      const encryptedResult = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBytes
      }, secretKey, enc.encode(plainText));
      const tagLength = 16;
      const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
      const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
      const authTagBytes = new Uint8Array(authTag);
      const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
      const concatted = new Uint8Array([
        ...ivBytes,
        ...authTagBytes,
        ...encryptedPlaintextBytes
      ]);
      return (0, util_1.uint8ArrayToHex)(concatted);
    }
    exports.encrypt = encrypt;
    function decrypt(cipherText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      return new Promise((resolve, reject) => {
        void async function() {
          const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
          const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);
          const ivBytes = encrypted.slice(0, 12);
          const authTagBytes = encrypted.slice(12, 28);
          const encryptedPlaintextBytes = encrypted.slice(28);
          const concattedBytes = new Uint8Array([
            ...encryptedPlaintextBytes,
            ...authTagBytes
          ]);
          const algo = {
            name: "AES-GCM",
            iv: new Uint8Array(ivBytes)
          };
          try {
            const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
            const decoder = new TextDecoder();
            resolve(decoder.decode(decrypted));
          } catch (err) {
            reject(err);
          }
        }();
      });
    }
    exports.decrypt = decrypt;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js
var require_Web3Method = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Method = void 0;
    var Web3Method;
    (function(Web3Method2) {
      Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
      Web3Method2["signEthereumMessage"] = "signEthereumMessage";
      Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
      Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
      Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
      Web3Method2["scanQRCode"] = "scanQRCode";
      Web3Method2["generic"] = "generic";
      Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
      Web3Method2["addEthereumChain"] = "addEthereumChain";
      Web3Method2["switchEthereumChain"] = "switchEthereumChain";
      Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
      Web3Method2["watchAsset"] = "watchAsset";
      Web3Method2["selectProvider"] = "selectProvider";
    })(Web3Method = exports.Web3Method || (exports.Web3Method = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js
var require_RelayMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelayMessageType = void 0;
    var RelayMessageType;
    (function(RelayMessageType2) {
      RelayMessageType2["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
      RelayMessageType2["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
      RelayMessageType2["LINKED"] = "LINKED";
      RelayMessageType2["UNLINKED"] = "UNLINKED";
      RelayMessageType2["WEB3_REQUEST"] = "WEB3_REQUEST";
      RelayMessageType2["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
      RelayMessageType2["WEB3_RESPONSE"] = "WEB3_RESPONSE";
    })(RelayMessageType = exports.RelayMessageType || (exports.RelayMessageType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js
var require_Web3RequestCanceledMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestCanceledMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestCanceledMessage(id) {
      return { type: RelayMessage_1.RelayMessageType.WEB3_REQUEST_CANCELED, id };
    }
    exports.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js
var require_Web3RequestMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_REQUEST }, params);
    }
    exports.Web3RequestMessage = Web3RequestMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js
var require_Web3Response = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumAddressFromSignedMessageResponse = exports.SubmitEthereumTransactionResponse = exports.SignEthereumTransactionResponse = exports.SignEthereumMessageResponse = exports.isRequestEthereumAccountsResponse = exports.SelectProviderResponse = exports.WatchAssetReponse = exports.RequestEthereumAccountsResponse = exports.SwitchEthereumChainResponse = exports.AddEthereumChainResponse = exports.ErrorResponse = void 0;
    var Web3Method_1 = require_Web3Method();
    function ErrorResponse(method, errorMessage, errorCode) {
      return { method, errorMessage, errorCode };
    }
    exports.ErrorResponse = ErrorResponse;
    function AddEthereumChainResponse(addResponse) {
      return {
        method: Web3Method_1.Web3Method.addEthereumChain,
        result: addResponse
      };
    }
    exports.AddEthereumChainResponse = AddEthereumChainResponse;
    function SwitchEthereumChainResponse(switchResponse) {
      return {
        method: Web3Method_1.Web3Method.switchEthereumChain,
        result: switchResponse
      };
    }
    exports.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
    function RequestEthereumAccountsResponse(addresses) {
      return { method: Web3Method_1.Web3Method.requestEthereumAccounts, result: addresses };
    }
    exports.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
    function WatchAssetReponse(success) {
      return { method: Web3Method_1.Web3Method.watchAsset, result: success };
    }
    exports.WatchAssetReponse = WatchAssetReponse;
    function SelectProviderResponse(selectedProviderKey) {
      return { method: Web3Method_1.Web3Method.selectProvider, result: selectedProviderKey };
    }
    exports.SelectProviderResponse = SelectProviderResponse;
    function isRequestEthereumAccountsResponse(res) {
      return res && res.method === Web3Method_1.Web3Method.requestEthereumAccounts;
    }
    exports.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
    function SignEthereumMessageResponse(signature) {
      return { method: Web3Method_1.Web3Method.signEthereumMessage, result: signature };
    }
    exports.SignEthereumMessageResponse = SignEthereumMessageResponse;
    function SignEthereumTransactionResponse(signedData) {
      return { method: Web3Method_1.Web3Method.signEthereumTransaction, result: signedData };
    }
    exports.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
    function SubmitEthereumTransactionResponse(txHash) {
      return { method: Web3Method_1.Web3Method.submitEthereumTransaction, result: txHash };
    }
    exports.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
    function EthereumAddressFromSignedMessageResponse(address) {
      return {
        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
        result: address
      };
    }
    exports.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js
var require_Web3ResponseMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWeb3ResponseMessage = exports.Web3ResponseMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3ResponseMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
    }
    exports.Web3ResponseMessage = Web3ResponseMessage;
    function isWeb3ResponseMessage(msg) {
      return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
    }
    exports.isWeb3ResponseMessage = isWeb3ResponseMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js
var require_WalletSDKRelay = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r4 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r4 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i3 = decorators.length - 1; i3 >= 0; i3--)
          if (d3 = decorators[i3])
            r4 = (c3 < 3 ? d3(r4) : c3 > 3 ? d3(target, key, r4) : d3(target, key)) || r4;
      return c3 > 3 && r4 && Object.defineProperty(target, key, r4), r4;
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelay = void 0;
    var bind_decorator_1 = __importDefault(require_bind_decorator());
    var eth_rpc_errors_1 = require_dist();
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var WalletSDKConnection_1 = require_WalletSDKConnection();
    var WalletUIError_1 = require_WalletUIError();
    var types_1 = require_types();
    var util_1 = require_util3();
    var aes256gcm = __importStar(require_aes256gcm());
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3RequestCanceledMessage_1 = require_Web3RequestCanceledMessage();
    var Web3RequestMessage_1 = require_Web3RequestMessage();
    var Web3Response_1 = require_Web3Response();
    var Web3ResponseMessage_1 = require_Web3ResponseMessage();
    var WalletSDKRelay = class extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {
      constructor(options) {
        var _a;
        super();
        this.accountsCallback = null;
        this.chainCallback = null;
        this.dappDefaultChainSubject = new rxjs_1.BehaviorSubject(1);
        this.dappDefaultChain = 1;
        this.appName = "";
        this.appLogoUrl = null;
        this.subscriptions = new rxjs_1.Subscription();
        this.linkAPIUrl = options.linkAPIUrl;
        this.storage = options.storage;
        this.options = options;
        const { session, ui, connection } = this.subscribe();
        this._session = session;
        this.connection = connection;
        this.relayEventManager = options.relayEventManager;
        if (options.diagnosticLogger && options.eventListener) {
          throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        }
        if (options.eventListener) {
          this.diagnostic = {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            log: options.eventListener.onEvent
          };
        } else {
          this.diagnostic = options.diagnosticLogger;
        }
        this._reloadOnDisconnect = (_a = options.reloadOnDisconnect) !== null && _a !== void 0 ? _a : true;
        this.ui = ui;
      }
      subscribe() {
        this.subscriptions.add(this.dappDefaultChainSubject.subscribe((chainId) => {
          if (this.dappDefaultChain !== chainId) {
            this.dappDefaultChain = chainId;
          }
        }));
        const session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();
        const connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);
        this.subscriptions.add(connection.sessionConfig$.subscribe({
          next: (sessionConfig) => {
            this.onSessionConfigChanged(sessionConfig);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "error while invoking session config callback"
            });
          }
        }));
        this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)((m3) => m3.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
        this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
          var _a;
          this.isLinked = linked;
          const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
          if (linked) {
            this.session.linked = linked;
          }
          this.isUnlinkedErrorState = false;
          if (cachedAddresses) {
            const addresses = cachedAddresses.split(" ");
            const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
            if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
              this.isUnlinkedErrorState = true;
              const sessionIdHash = this.getSessionIdHash();
              (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {
                sessionIdHash
              });
            }
          }
        })).subscribe());
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => !!c3.metadata && c3.metadata.__destroyed === "1")).subscribe(() => {
          var _a;
          const alreadyDestroyed = connection.isDestroyed;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {
            alreadyDestroyed,
            sessionIdHash: this.getSessionIdHash()
          });
          return this.resetAndReload();
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.WalletUsername, session.secret))).subscribe({
          next: (walletUsername) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "username"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.AppVersion, session.secret))).subscribe({
          next: (appVersion) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appversion"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.ChainId !== void 0 && c3.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c3) => (0, rxjs_1.zip)(aes256gcm.decrypt(c3.metadata.ChainId, session.secret), aes256gcm.decrypt(c3.metadata.JsonRpcUrl, session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
          next: ([chainId, jsonRpcUrl]) => {
            if (this.chainCallback) {
              this.chainCallback(chainId, jsonRpcUrl);
            }
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.EthereumAddress, session.secret))).subscribe({
          next: (selectedAddress) => {
            if (this.accountsCallback) {
              this.accountsCallback([selectedAddress]);
            }
            if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {
              Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach((id) => {
                const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
                  id,
                  response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                    selectedAddress
                  ])
                });
                this.invokeCallback(Object.assign(Object.assign({}, message), { id }));
              });
              WalletSDKRelay.accountRequestCallbackIds.clear();
            }
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.AppSrc !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.AppSrc, session.secret))).subscribe({
          next: (appSrc) => {
            this.ui.setAppSrc(appSrc);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appSrc"
            });
          }
        }));
        const ui = this.options.uiConstructor({
          linkAPIUrl: this.options.linkAPIUrl,
          version: this.options.version,
          darkMode: this.options.darkMode,
          session,
          connected$: connection.connected$,
          chainId$: this.dappDefaultChainSubject
        });
        connection.connect();
        return { session, ui, connection };
      }
      attachUI() {
        this.ui.attach();
      }
      resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_3) => (0, rxjs_1.of)(null))).subscribe((_3) => {
          var _a, _b, _c;
          const isStandalone = this.ui.isStandalone();
          try {
            this.subscriptions.unsubscribe();
          } catch (err) {
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error unsubscribing"
            });
          }
          (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash()
          });
          this.connection.destroy();
          const storedSession = Session_1.Session.load(this.storage);
          if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
            this.storage.clear();
          } else if (storedSession) {
            (_c = this.diagnostic) === null || _c === void 0 ? void 0 : _c.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: Session_1.Session.hash(storedSession.id)
            });
          }
          if (this._reloadOnDisconnect) {
            this.ui.reloadUI();
            return;
          }
          if (this.accountsCallback) {
            this.accountsCallback([], true);
          }
          const { session, ui, connection } = this.subscribe();
          this._session = session;
          this.connection = connection;
          this.ui = ui;
          if (isStandalone && this.ui.setStandalone)
            this.ui.setStandalone(true);
          this.attachUI();
        }, (err) => {
          var _a;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${err}`,
            sessionIdHash: this.getSessionIdHash()
          });
        });
      }
      setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
      }
      getStorageItem(key) {
        return this.storage.getItem(key);
      }
      get session() {
        return this._session;
      }
      setStorageItem(key, value) {
        this.storage.setItem(key, value);
      }
      signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            address,
            addPrefix,
            typedDataJson: typedDataJson || null
          }
        });
      }
      ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            signature: (0, util_1.hexStringFromBuffer)(signature, true),
            addPrefix
          }
        });
      }
      signEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: false
          }
        });
      }
      signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,
            maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: true
          }
        });
      }
      submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.submitEthereumTransaction,
          params: {
            signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),
            chainId
          }
        });
      }
      scanQRCode(regExp) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.scanQRCode,
          params: { regExp }
        });
      }
      getQRCodeUrl() {
        return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);
      }
      genericRequest(data, action) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.generic,
          params: {
            action,
            data
          }
        });
      }
      sendGenericMessage(request) {
        return this.sendRequest(request);
      }
      sendRequest(request) {
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          if (!this.ui.isStandalone()) {
            hideSnackbarItem = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
              // eslint-disable-line @typescript-eslint/unbound-method
            });
          }
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          if (this.ui.isStandalone()) {
            this.sendRequestStandalone(id, request);
          } else {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
      }
      setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
      }
      setChainCallback(chainCallback) {
        this.chainCallback = chainCallback;
      }
      setDappDefaultChainCallback(chainId) {
        this.dappDefaultChainSubject.next(chainId);
      }
      publishWeb3RequestEvent(id, request) {
        var _a;
        const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id, request });
        const storedSession = Session_1.Session.load(this.storage);
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
        this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
          next: (_3) => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: message.id,
              method: `relay::${message.request.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
              isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
            });
          },
          error: (err) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: message.id,
              response: {
                method: message.request.method,
                errorMessage: err.message
              }
            }));
          }
        }));
      }
      publishWeb3RequestCanceledEvent(id) {
        const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
      }
      publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
          void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
            subscriber.next(encrypted);
            subscriber.complete();
          });
        }).pipe((0, operators_1.mergeMap)((encrypted) => {
          return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
      }
      handleIncomingEvent(event) {
        try {
          this.subscriptions.add((0, rxjs_1.from)(aes256gcm.decrypt(event.data, this.session.secret)).pipe((0, operators_1.map)((c3) => JSON.parse(c3))).subscribe({
            next: (json) => {
              const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;
              if (!message) {
                return;
              }
              this.handleWeb3ResponseMessage(message);
            },
            error: () => {
              var _a;
              (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "incomingEvent"
              });
            }
          }));
        } catch (_a) {
          return;
        }
      }
      handleWeb3ResponseMessage(message) {
        var _a;
        const { response } = message;
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {
          eventId: message.id,
          method: `relay::${response.method}`,
          sessionIdHash: this.getSessionIdHash()
        });
        if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
          WalletSDKRelay.accountRequestCallbackIds.forEach((id) => this.invokeCallback(Object.assign(Object.assign({}, message), { id })));
          WalletSDKRelay.accountRequestCallbackIds.clear();
          return;
        }
        this.invokeCallback(message);
      }
      handleErrorResponse(id, method, error, errorCode) {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id,
          response: (0, Web3Response_1.ErrorResponse)(method, (error !== null && error !== void 0 ? error : WalletUIError_1.WalletUIError.UserRejectedRequest).message, errorCode)
        }));
      }
      invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
          callback(message.response);
          this.relayEventManager.callbacks.delete(message.id);
        }
      }
      requestEthereumAccounts() {
        const request = {
          method: Web3Method_1.Web3Method.requestEthereumAccounts,
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        };
        const hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          var _a;
          this.relayEventManager.callbacks.set(id, (response) => {
            this.ui.hideRequestEthereumAccounts();
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;
          if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
            let location2;
            try {
              if ((0, util_1.isInIFrame)() && window.top) {
                location2 = window.top.location;
              } else {
                location2 = window.location;
              }
            } catch (e3) {
              location2 = window.location;
            }
            location2.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(location2.href)}`;
            return;
          }
          if (this.ui.inlineAccountsResponse()) {
            const onAccounts = (accounts) => {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
              }));
            };
            this.ui.requestEthereumAccounts({
              onCancel: cancel,
              onAccounts
            });
          } else {
            const err = eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
            this.ui.requestEthereumAccounts({
              onCancel: () => cancel(err)
            });
          }
          WalletSDKRelay.accountRequestCallbackIds.add(id);
          if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      selectProvider(providerOptions) {
        const request = {
          method: Web3Method_1.Web3Method.selectProvider,
          params: {
            providerOptions
          }
        };
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request.method, error);
        };
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)
            }));
          };
          const approve = (selectedProviderKey) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)
            }));
          };
          if (this.ui.selectProvider)
            this.ui.selectProvider({
              onApprove: approve,
              onCancel: _cancel,
              providerOptions
            });
        });
        return { cancel, promise };
      }
      watchAsset(type, address, symbol, decimals, image, chainId) {
        const request = {
          method: Web3Method_1.Web3Method.watchAsset,
          params: {
            type,
            options: {
              address,
              symbol,
              decimals,
              image
            },
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineWatchAsset()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
            // eslint-disable-line @typescript-eslint/unbound-method
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.WatchAssetReponse)(false)
            }));
          };
          const approve = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.WatchAssetReponse)(true)
            }));
          };
          if (this.ui.inlineWatchAsset()) {
            this.ui.watchAsset({
              onApprove: approve,
              onCancel: _cancel,
              type,
              address,
              symbol,
              decimals,
              image,
              chainId
            });
          }
          if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { cancel, promise };
      }
      addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
        const request = {
          method: Web3Method_1.Web3Method.addEthereumChain,
          params: {
            chainId,
            rpcUrls,
            blockExplorerUrls,
            chainName,
            iconUrls,
            nativeCurrency
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineAddEthereumChain(chainId)) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
            // eslint-disable-line @typescript-eslint/unbound-method
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.AddEthereumChainResponse)({
                isApproved: false,
                rpcUrl: ""
              })
            }));
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
            }));
          };
          if (this.ui.inlineAddEthereumChain(chainId)) {
            this.ui.addEthereumChain({
              onCancel: _cancel,
              onApprove: approve,
              chainId: request.params.chainId,
              rpcUrls: request.params.rpcUrls,
              blockExplorerUrls: request.params.blockExplorerUrls,
              chainName: request.params.chainName,
              iconUrls: request.params.iconUrls,
              nativeCurrency: request.params.nativeCurrency
            });
          }
          if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      switchEthereumChain(chainId, address) {
        const request = {
          method: Web3Method_1.Web3Method.switchEthereumChain,
          params: Object.assign({ chainId }, { address })
        };
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request.method, error);
        };
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            if (response.errorMessage && response.errorCode) {
              return reject(eth_rpc_errors_1.ethErrors.provider.custom({
                code: response.errorCode,
                message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
              }));
            } else if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (error) => {
            if (typeof error === "number") {
              const errorCode = error;
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, WalletUIError_1.WalletUIError.SwitchEthereumChainUnsupportedChainId.message, errorCode)
              }));
            } else if (error instanceof WalletUIError_1.WalletUIError) {
              this.handleErrorResponse(id, Web3Method_1.Web3Method.switchEthereumChain, error, error.errorCode);
            } else {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                  isApproved: false,
                  rpcUrl: ""
                })
              }));
            }
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                isApproved: true,
                rpcUrl
              })
            }));
          };
          this.ui.switchEthereumChain({
            onCancel: _cancel,
            onApprove: approve,
            chainId: request.params.chainId,
            address: request.params.address
          });
          if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      inlineAddEthereumChain(chainId) {
        return this.ui.inlineAddEthereumChain(chainId);
      }
      getSessionIdHash() {
        return Session_1.Session.hash(this._session.id);
      }
      sendRequestStandalone(id, request) {
        const _cancel = (error) => {
          this.handleErrorResponse(id, request.method, error);
        };
        const onSuccess = (response) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response
          }));
        };
        switch (request.method) {
          case Web3Method_1.Web3Method.signEthereumMessage:
            this.ui.signEthereumMessage({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.signEthereumTransaction:
            this.ui.signEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.submitEthereumTransaction:
            this.ui.submitEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
            this.ui.ethereumAddressFromSignedMessage({
              request,
              onSuccess
            });
            break;
          default:
            _cancel();
            break;
        }
      }
      onSessionConfigChanged(_nextSessionConfig) {
      }
    };
    WalletSDKRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();
    __decorate([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "resetAndReload", null);
    __decorate([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "handleIncomingEvent", null);
    exports.WalletSDKRelay = WalletSDKRelay;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js
var require_WalletSDKRelayEventManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelayEventManager = void 0;
    var util_1 = require_util3();
    var WalletSDKRelayEventManager = class {
      constructor() {
        this._nextRequestId = 0;
        this.callbacks = /* @__PURE__ */ new Map();
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const id = this._nextRequestId;
        const idStr = (0, util_1.prepend0x)(id.toString(16));
        const callback = this.callbacks.get(idStr);
        if (callback) {
          this.callbacks.delete(idStr);
        }
        return id;
      }
    };
    exports.WalletSDKRelayEventManager = WalletSDKRelayEventManager;
  }
});

// node_modules/@coinbase/wallet-sdk/package.json
var require_package = __commonJS({
  "node_modules/@coinbase/wallet-sdk/package.json"(exports, module) {
    module.exports = {
      name: "@coinbase/wallet-sdk",
      version: "3.6.4",
      description: "Coinbase Wallet JavaScript SDK",
      keywords: [
        "cipher",
        "cipherbrowser",
        "coinbase",
        "coinbasewallet",
        "eth",
        "ether",
        "ethereum",
        "etherium",
        "injection",
        "toshi",
        "wallet",
        "walletlink",
        "web3"
      ],
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: "https://github.com/coinbase/coinbase-wallet-sdk.git",
      author: "Coinbase, Inc.",
      license: "Apache-2.0",
      scripts: {
        "pretest:unit": "node compile-assets.js",
        "test:unit": "jest",
        "test:unit:coverage": "yarn test:unit && open coverage/lcov-report/index.html",
        "test:karma": "yarn build-npm && karma start",
        prebuild: `rm -rf ./build && node -p "'export const LIB_VERSION = ' + JSON.stringify(require('./package.json').version) + ';'" > src/version.ts`,
        build: "node compile-assets.js && webpack --config webpack.config.js",
        "build-npm": "tsc -p ./tsconfig.build.json",
        "build:dev": "export LINK_API_URL='http://localhost:3000'; yarn build",
        "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --exec 'yarn build:dev'",
        "build:prod": `yarn prebuild && yarn build && yarn build-npm && cp ./package.json ../../README.md ./LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
        "lint:types": "tsc --noEmit",
        "lint:prettier": 'prettier --check "{src,__tests__}/**/*.(js|ts|tsx)"',
        "lint:eslint": "eslint ./src --ext .ts,.tsx",
        lint: "yarn lint:eslint && yarn lint:types && yarn lint:prettier",
        "fix:eslint": "yarn lint:eslint --fix",
        "fix:prettier": "prettier . --write",
        release: "./scripts/release.sh"
      },
      dependencies: {
        "@metamask/safe-event-emitter": "2.0.0",
        "@solana/web3.js": "^1.70.1",
        "bind-decorator": "^1.0.11",
        "bn.js": "^5.1.1",
        buffer: "^6.0.3",
        clsx: "^1.1.0",
        "eth-block-tracker": "4.4.3",
        "eth-json-rpc-filters": "5.1.0",
        "eth-rpc-errors": "4.0.2",
        "json-rpc-engine": "6.1.0",
        keccak: "^3.0.1",
        preact: "^10.5.9",
        qs: "^6.10.3",
        rxjs: "^6.6.3",
        "sha.js": "^2.4.11",
        "stream-browserify": "^3.0.0",
        util: "^0.12.4"
      },
      devDependencies: {
        "@babel/core": "^7.17.9",
        "@babel/plugin-proposal-decorators": "^7.17.9",
        "@babel/plugin-transform-react-jsx": "^7.17.3",
        "@babel/preset-env": "^7.16.11",
        "@babel/preset-typescript": "^7.16.7",
        "@peculiar/webcrypto": "^1.3.3",
        "@testing-library/jest-dom": "^5.16.4",
        "@testing-library/preact": "^2.0.1",
        "@types/bn.js": "^4.11.6",
        "@types/jest": "^27.4.1",
        "@types/node": "^14.14.20",
        "@types/qs": "^6.9.7",
        "@types/sha.js": "^2.4.0",
        "@typescript-eslint/eslint-plugin": "^5.7.0",
        "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
        "@typescript-eslint/parser": "^5.7.0",
        "babel-jest": "^27.5.1",
        browserify: "17.0.0",
        "copy-webpack-plugin": "^6.4.1",
        "core-js": "^3.8.2",
        eslint: "^8.4.1",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.3",
        "eslint-plugin-preact": "^0.1.0",
        "eslint-plugin-prettier": "^4.0.0",
        "eslint-plugin-simple-import-sort": "^7.0.0",
        jasmine: "3.8.0",
        jest: "^27.5.1",
        "jest-chrome": "^0.7.2",
        "jest-websocket-mock": "^2.3.0",
        karma: "^6.4.0",
        "karma-browserify": "8.1.0",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        nodemon: "^2.0.6",
        prettier: "^2.5.1",
        "raw-loader": "^4.0.2",
        "regenerator-runtime": "^0.13.7",
        sass: "^1.50.0",
        svgo: "^2.8.0",
        "ts-jest": "^27.1.4",
        "ts-loader": "^8.0.13",
        "ts-node": "^10.7.0",
        tslib: "^2.0.3",
        typescript: "^4.1.3",
        watchify: "4.0.0",
        webpack: "^5.72.0",
        "webpack-cli": "^4.9.2",
        "whatwg-fetch": "^3.5.0"
      },
      engines: {
        node: ">= 10.0.0"
      }
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
var require_CoinbaseWalletSDK = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletSDK = void 0;
    var wallet_logo_1 = require_wallet_logo();
    var ScopedLocalStorage_1 = require_ScopedLocalStorage();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var WalletSDKUI_1 = require_WalletSDKUI();
    var WalletSDKRelay_1 = require_WalletSDKRelay();
    var WalletSDKRelayEventManager_1 = require_WalletSDKRelayEventManager();
    var util_1 = require_util3();
    var LINK_API_URL = process.env.LINK_API_URL || "https://www.walletlink.org";
    var SDK_VERSION = process.env.SDK_VERSION || require_package().version || "unknown";
    var CoinbaseWalletSDK = class {
      /**
       * Constructor
       * @param options Coinbase Wallet SDK constructor options
       */
      constructor(options) {
        var _a, _b, _c;
        this._appName = "";
        this._appLogoUrl = null;
        this._relay = null;
        this._relayEventManager = null;
        const linkAPIUrl = options.linkAPIUrl || LINK_API_URL;
        let uiConstructor;
        if (!options.uiConstructor) {
          uiConstructor = (opts) => new WalletSDKUI_1.WalletSDKUI(opts);
        } else {
          uiConstructor = options.uiConstructor;
        }
        if (typeof options.overrideIsMetaMask === "undefined") {
          this._overrideIsMetaMask = false;
        } else {
          this._overrideIsMetaMask = options.overrideIsMetaMask;
        }
        this._overrideIsCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
        this._overrideIsCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        if (options.diagnosticLogger && options.eventListener) {
          throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        }
        if (options.eventListener) {
          this._diagnosticLogger = {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            log: options.eventListener.onEvent
          };
        } else {
          this._diagnosticLogger = options.diagnosticLogger;
        }
        this._reloadOnDisconnect = (_c = options.reloadOnDisconnect) !== null && _c !== void 0 ? _c : true;
        const url = new URL(linkAPIUrl);
        const origin = `${url.protocol}//${url.host}`;
        this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`);
        this._storage.setItem("version", CoinbaseWalletSDK.VERSION);
        if (this.walletExtension || this.coinbaseBrowser) {
          return;
        }
        this._relayEventManager = new WalletSDKRelayEventManager_1.WalletSDKRelayEventManager();
        this._relay = new WalletSDKRelay_1.WalletSDKRelay({
          linkAPIUrl,
          version: SDK_VERSION,
          darkMode: !!options.darkMode,
          uiConstructor,
          storage: this._storage,
          relayEventManager: this._relayEventManager,
          diagnosticLogger: this._diagnosticLogger,
          reloadOnDisconnect: this._reloadOnDisconnect
        });
        this.setAppInfo(options.appName, options.appLogoUrl);
        if (!!options.headlessMode)
          return;
        this._relay.attachUI();
      }
      /**
       * Create a Web3 Provider object
       * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
       * @param chainId Ethereum Chain ID (Default: 1)
       * @returns A Web3 Provider
       */
      makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setProviderInfo(jsonRpcUrl, chainId);
          }
          if (this._reloadOnDisconnect === false && typeof extension.disableReloadOnDisconnect === "function")
            extension.disableReloadOnDisconnect();
          return extension;
        }
        const dappBrowser = this.coinbaseBrowser;
        if (dappBrowser) {
          return dappBrowser;
        }
        const relay = this._relay;
        if (!relay || !this._relayEventManager || !this._storage) {
          throw new Error("Relay not initialized, should never happen");
        }
        if (!jsonRpcUrl)
          relay.setConnectDisabled(true);
        return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
          relayProvider: () => Promise.resolve(relay),
          relayEventManager: this._relayEventManager,
          storage: this._storage,
          jsonRpcUrl,
          chainId,
          qrUrl: this.getQrUrl(),
          diagnosticLogger: this._diagnosticLogger,
          overrideIsMetaMask: this._overrideIsMetaMask,
          overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
          overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
        });
      }
      /**
       * Set application information
       * @param appName Application name
       * @param appLogoUrl Application logo image URL
       */
      setAppInfo(appName, appLogoUrl) {
        var _a;
        this._appName = appName || "DApp";
        this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setAppInfo(this._appName, this._appLogoUrl);
          }
        } else {
          (_a = this._relay) === null || _a === void 0 ? void 0 : _a.setAppInfo(this._appName, this._appLogoUrl);
        }
      }
      /**
       * Disconnect. After disconnecting, this will reload the web page to ensure
       * all potential stale state is cleared.
       */
      disconnect() {
        var _a;
        const extension = this.walletExtension;
        if (extension) {
          void extension.close();
        } else {
          (_a = this._relay) === null || _a === void 0 ? void 0 : _a.resetAndReload();
        }
      }
      /**
       * Return QR URL for mobile wallet connection, will return null if extension is installed
       */
      getQrUrl() {
        var _a, _b;
        return (_b = (_a = this._relay) === null || _a === void 0 ? void 0 : _a.getQRCodeUrl()) !== null && _b !== void 0 ? _b : null;
      }
      /**
       * Official Coinbase Wallet logo for developers to use on their frontend
       * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
       * @param width Width of the logo (Optional)
       * @returns SVG Data URI
       */
      getCoinbaseWalletLogo(type, width = 240) {
        return (0, wallet_logo_1.walletLogo)(type, width);
      }
      get walletExtension() {
        var _a;
        return (_a = window.coinbaseWalletExtension) !== null && _a !== void 0 ? _a : window.walletLinkExtension;
      }
      get coinbaseBrowser() {
        var _a, _b;
        try {
          const ethereum = (_a = window.ethereum) !== null && _a !== void 0 ? _a : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;
          if (!ethereum) {
            return void 0;
          }
          if ("isCoinbaseBrowser" in ethereum && ethereum.isCoinbaseBrowser) {
            return ethereum;
          } else {
            return void 0;
          }
        } catch (e3) {
          return void 0;
        }
      }
      isCipherProvider(provider) {
        return typeof provider.isCipher === "boolean" && provider.isCipher;
      }
    };
    exports.CoinbaseWalletSDK = CoinbaseWalletSDK;
    CoinbaseWalletSDK.VERSION = SDK_VERSION;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletProvider = exports.CoinbaseWalletSDK = void 0;
    var CoinbaseWalletSDK_1 = require_CoinbaseWalletSDK();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var CoinbaseWalletSDK_2 = require_CoinbaseWalletSDK();
    Object.defineProperty(exports, "CoinbaseWalletSDK", { enumerable: true, get: function() {
      return CoinbaseWalletSDK_2.CoinbaseWalletSDK;
    } });
    var CoinbaseWalletProvider_2 = require_CoinbaseWalletProvider();
    Object.defineProperty(exports, "CoinbaseWalletProvider", { enumerable: true, get: function() {
      return CoinbaseWalletProvider_2.CoinbaseWalletProvider;
    } });
    exports.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    if (typeof window !== "undefined") {
      window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.CoinbaseWalletProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
      window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.WalletLinkProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
    }
  }
});
export default require_dist3();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=dist-PIMJJISA.js.map
